{"version":3,"file":"tf-backend-webgl.es2017.js","sources":["../src/canvas_util.ts","../src/tex_util.ts","../src/webgl_util.ts","../src/flags_webgl.ts","../src/addn_gpu.ts","../src/addn_packed_gpu.ts","../src/argminmax_gpu.ts","../src/packing_util.ts","../src/glsl_version.ts","../src/shader_compiler_util.ts","../src/shader_compiler.ts","../src/argminmax_packed_gpu.ts","../src/avg_pool_backprop_gpu.ts","../src/batchnorm_gpu.ts","../src/batchnorm_packed_gpu.ts","../src/binaryop_complex_gpu.ts","../src/binaryop_gpu.ts","../src/binaryop_packed_gpu.ts","../src/clip_gpu.ts","../src/clip_packed_gpu.ts","../src/complex_abs_gpu.ts","../src/concat_gpu.ts","../src/concat_packed_gpu.ts","../src/conv_backprop_gpu.ts","../src/conv_backprop_gpu_depthwise.ts","../src/conv_gpu.ts","../src/conv_gpu_depthwise.ts","../src/conv_packed_gpu_depthwise.ts","../src/crop_and_resize_gpu.ts","../src/cumsum_gpu.ts","../src/decode_matrix_gpu.ts","../src/decode_matrix_packed_gpu.ts","../src/depth_to_space_gpu.ts","../src/diag_gpu.ts","../src/encode_float_gpu.ts","../src/encode_float_packed_gpu.ts","../src/encode_matrix_gpu.ts","../src/encode_matrix_packed_gpu.ts","../src/fft_gpu.ts","../src/fill_gpu.ts","../src/gather_gpu.ts","../src/gather_nd_gpu.ts","../src/gpgpu_util.ts","../src/gpgpu_context.ts","../src/gpgpu_math.ts","../src/im2col_packed_gpu.ts","../src/lrn_gpu.ts","../src/lrn_grad_gpu.ts","../src/lrn_packed_gpu.ts","../src/max_pool_backprop_gpu.ts","../src/mulmat_packed_gpu.ts","../src/multinomial_gpu.ts","../src/onehot_gpu.ts","../src/pack_gpu.ts","../src/pad_gpu.ts","../src/pad_packed_gpu.ts","../src/pool_gpu.ts","../src/reduce_gpu.ts","../src/reshape_packed_gpu.ts","../src/resize_bilinear_backprop_gpu.ts","../src/resize_bilinear_gpu.ts","../src/resize_bilinear_packed_gpu.ts","../src/resize_nearest_neighbor_backprop_gpu.ts","../src/resize_nearest_neighbor_gpu.ts","../src/reverse_gpu.ts","../src/reverse_packed_gpu.ts","../src/scatter_gpu.ts","../src/segment_gpu.ts","../src/select_gpu.ts","../src/slice_gpu.ts","../src/slice_packed_gpu.ts","../src/strided_slice_gpu.ts","../src/texture_manager.ts","../src/tile_gpu.ts","../src/unaryop_gpu.ts","../src/unaryop_packed_gpu.ts","../src/unpack_gpu.ts","../src/backend_webgl.ts","../src/version.ts","../src/kernels/Div_impl.ts","../src/kernels/Div.ts","../src/kernels/FromPixels_utils/from_pixels_gpu.ts","../src/kernels/FromPixels_utils/from_pixels_packed_gpu.ts","../src/kernels/FromPixels.ts","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js","../node_modules/@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js","../src/kernel_utils/shared.ts","../src/kernel_utils/reduce.ts","../src/kernel_utils/reshape.ts","../src/kernels/Max_impl.ts","../src/transpose_gpu.ts","../src/transpose_packed_gpu.ts","../src/kernels/Transpose_impl.ts","../src/kernels/Max.ts","../src/kernels/MaxPoolWithArgmax_impl.ts","../src/kernels/MaxPoolWithArgmax.ts","../src/kernels/NonMaxSuppressionV3.ts","../src/kernels/NonMaxSuppressionV5.ts","../src/kernels/Square.ts","../src/kernels/SquaredDifference.ts","../src/kernels/Transpose.ts","../src/register_all_kernels.ts","../src/webgl.ts","../src/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nconst contexts: {[key: string]: WebGLRenderingContext} = {};\n\nconst WEBGL_ATTRIBUTES: WebGLContextAttributes = {\n  alpha: false,\n  antialias: false,\n  premultipliedAlpha: false,\n  preserveDrawingBuffer: false,\n  depth: false,\n  stencil: false,\n  failIfMajorPerformanceCaveat: true\n};\n\nexport function setWebGLContext(\n    webGLVersion: number, gl: WebGLRenderingContext) {\n  contexts[webGLVersion] = gl;\n}\n\nexport function getWebGLContext(webGLVersion: number): WebGLRenderingContext {\n  if (!(webGLVersion in contexts)) {\n    contexts[webGLVersion] = getWebGLRenderingContext(webGLVersion);\n  }\n  const gl = contexts[webGLVersion];\n  if (gl.isContextLost()) {\n    delete contexts[webGLVersion];\n    return getWebGLContext(webGLVersion);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return contexts[webGLVersion];\n}\n\nfunction createCanvas(webGLVersion: number) {\n  if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n    return new OffscreenCanvas(300, 150);\n  } else if (typeof document !== 'undefined') {\n    return document.createElement('canvas');\n  } else {\n    throw new Error('Cannot create a canvas in this context');\n  }\n}\n\nfunction getWebGLRenderingContext(webGLVersion: number): WebGLRenderingContext {\n  if (webGLVersion !== 1 && webGLVersion !== 2) {\n    throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n  }\n  const canvas = createCanvas(webGLVersion);\n\n  canvas.addEventListener('webglcontextlost', (ev: Event) => {\n    ev.preventDefault();\n    delete contexts[webGLVersion];\n  }, false);\n  if (webGLVersion === 1) {\n    return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES)) as\n        WebGLRenderingContext;\n  }\n  return canvas.getContext('webgl2', WEBGL_ATTRIBUTES) as WebGLRenderingContext;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\nimport {backend_util, DataId, DataType, Tensor, util} from '@tensorflow/tfjs-core';\n\nexport enum PackingScheme {\n  /**\n   * All values in a single texel are densely packed without any constraints.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 4]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   010|011   020|021\n   * -------   -------   -------\n   * 002|003   012|013   022|023\n   *\n   * 100|101   110|111   120|121\n   * -------   -------   -------\n   * 102|103   112|113   122|123\n   *\n   */\n  DENSE,\n\n  /**\n   * Single texels contain only values from the same batch, and from adjacent\n   * rows and columns.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 5]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   */\n  SHARED_BATCH\n}\n\nexport enum TextureUsage {\n  RENDER,\n  UPLOAD,\n  PIXELS,\n  DOWNLOAD\n}\n\nexport enum PhysicalTextureType {\n  UNPACKED_FLOAT16,\n  UNPACKED_FLOAT32,\n  PACKED_4X1_UNSIGNED_BYTE,\n  PACKED_2X2_FLOAT32,\n  PACKED_2X2_FLOAT16\n}\n\nexport interface TextureData {\n  // Required.\n  shape: number[];\n  dtype: DataType;\n\n  // Optional.\n  values?: backend_util.BackendValues;\n  texture?: WebGLTexture;\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensors, with a parent joining the two with the\n  // complexTensors field. When this is defined, texture will be null.\n  complexTensors?: {real: Tensor, imag: Tensor};\n  /** [rows, columns] shape of the texture. */\n  texShape?: [number, number];\n  usage?: TextureUsage;\n  isPacked?: boolean;\n\n  // Available when the tensor has been sliced.\n  slice?: {\n    // Offset in the 'flat index' space.\n    flatOffset: number;\n    // Used for counting how many sliced tensors point to the same texture.\n    origDataId: DataId;\n  };\n}\n\nexport function getUnpackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns, rows];\n}\n\nexport function getUnpackedArraySizeFromMatrixSize(\n    matrixSize: number, channelsPerTexture: number): number {\n  return matrixSize * channelsPerTexture;\n}\n\nexport function getColorMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns * 4, rows];\n}\n\n/**\n * Get shape for densely packed RGBA texture.\n */\nexport function getDenseTexShape(shape: number[]): [number, number] {\n  const size = util.sizeFromShape(shape);\n  const texelsNeeded = Math.ceil(size / 4);\n  return util.sizeToSquarishShape(texelsNeeded);\n}\n\nexport function getMatrixSizeFromUnpackedArraySize(\n    unpackedSize: number, channelsPerTexture: number): number {\n  if (unpackedSize % channelsPerTexture !== 0) {\n    throw new Error(\n        `unpackedSize (${unpackedSize}) must be a multiple of ` +\n        `${channelsPerTexture}`);\n  }\n  return unpackedSize / channelsPerTexture;\n}\n\nexport function decodeMatrixFromUnpackedColorRGBAArray(\n    unpackedArray: Float32Array, matrix: Float32Array, channels: number) {\n  const requiredSize = unpackedArray.length * channels / 4;\n  if (matrix.length < requiredSize) {\n    throw new Error(\n        `matrix length (${matrix.length}) must be >= ${requiredSize}`);\n  }\n  let dst = 0;\n  for (let src = 0; src < unpackedArray.length; src += 4) {\n    for (let c = 0; c < channels; c++) {\n      matrix[dst++] = unpackedArray[src + c];\n    }\n  }\n}\n\nexport function getPackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [\n    Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n  ];\n}\n\nexport function getPackedRGBAArraySizeFromMatrixShape(\n    rows: number, columns: number): number {\n  const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return w * h * 4;\n}\n\nexport interface TextureConfig {\n  internalFormatFloat: number;\n  textureFormatFloat: number;\n  internalFormatPackedHalfFloat: number;\n  internalFormatHalfFloat: number;\n  internalFormatPackedFloat: number;\n\n  // The format to use during a gl.readPixels call.\n  downloadTextureFormat: number;\n  // How many channels need to be unpacked after a gl.readPixels call.\n  downloadUnpackNumChannels: number;\n\n  defaultNumChannels: number;\n  textureTypeHalfFloat: number;\n  textureTypeFloat: number;\n}\n\nexport function getTextureConfig(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension?: any): TextureConfig {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n\n  let internalFormatFloat: number;\n  let internalFormatHalfFloat: number;\n  let internalFormatPackedHalfFloat: number;\n  let internalFormatPackedFloat: number;\n  let textureFormatFloat: number;\n\n  let downloadTextureFormat: number;\n  let downloadUnpackNumChannels: number;\n\n  let defaultNumChannels: number;\n  let textureTypeHalfFloat: number;\n  let textureTypeFloat: number;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    internalFormatFloat = glany.R32F;\n    internalFormatHalfFloat = glany.R16F;\n    internalFormatPackedHalfFloat = glany.RGBA16F;\n    internalFormatPackedFloat = glany.RGBA32F;\n    textureFormatFloat = glany.RED;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 1;\n    textureTypeHalfFloat = glany.HALF_FLOAT;\n    textureTypeFloat = glany.FLOAT;\n  } else {\n    internalFormatFloat = gl.RGBA;\n    internalFormatHalfFloat = gl.RGBA;\n    internalFormatPackedHalfFloat = gl.RGBA;\n    internalFormatPackedFloat = glany.RGBA;\n    textureFormatFloat = gl.RGBA;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 4;\n    textureTypeHalfFloat = textureHalfFloatExtension != null ?\n        textureHalfFloatExtension.HALF_FLOAT_OES :\n        null;\n    textureTypeFloat = gl.FLOAT;\n  }\n  downloadTextureFormat = gl.RGBA;\n\n  return {\n    internalFormatFloat,\n    internalFormatHalfFloat,\n    internalFormatPackedHalfFloat,\n    internalFormatPackedFloat,\n    textureFormatFloat,\n    downloadTextureFormat,\n    downloadUnpackNumChannels,\n    defaultNumChannels,\n    textureTypeHalfFloat,\n    textureTypeFloat\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {getTextureConfig} from './tex_util';\n\nexport function callAndCheck<T>(\n    gl: WebGLRenderingContext, debugMode: boolean, func: () => T): T {\n  const returnValue = func();\n  if (debugMode) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\n\nfunction checkWebGLError(gl: WebGLRenderingContext) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\n\nexport function canBeRepresented(num: number): boolean {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n      (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWebGLErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\n\nexport function getExtensionOrThrow(\n    gl: WebGLRenderingContext, debug: boolean, extensionName: string): {} {\n  return throwIfNull<{}>(\n      gl, debug, () => gl.getExtension(extensionName),\n      'Extension \"' + extensionName + '\" not supported on this browser.');\n}\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, debug: boolean,\n    vertexShaderSource: string): WebGLShader {\n  const vertexShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, debug, () => gl.createShader(gl.VERTEX_SHADER),\n      'Unable to create vertex WebGLShader.');\n  callAndCheck(\n      gl, debug, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, debug, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\n\nexport function createFragmentShader(\n    gl: WebGLRenderingContext, debug: boolean,\n    fragmentShaderSource: string): WebGLShader {\n  const fragmentShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, debug, () => gl.createShader(gl.FRAGMENT_SHADER),\n      'Unable to create fragment WebGLShader.');\n  callAndCheck(\n      gl, debug, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, debug, () => gl.compileShader(fragmentShader));\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(\n        fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\n\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(\n    shaderSource: string, shaderInfoLog: string) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map(\n      (line, lineNumber) =>\n          util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\n      `%c ${util.rightPad(errorLine[0], maxLineLength)}`,\n      'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(\n    gl: WebGLRenderingContext, debug: boolean): WebGLProgram {\n  return throwIfNull<WebGLProgram>(\n      gl, debug, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\n\nexport function linkProgram(\n    gl: WebGLRenderingContext, debug: boolean, program: WebGLProgram) {\n  callAndCheck(gl, debug, () => gl.linkProgram(program));\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n\nexport function validateProgram(\n    gl: WebGLRenderingContext, debug: boolean, program: WebGLProgram) {\n  callAndCheck(gl, debug, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\n\nexport function createStaticVertexBuffer(\n    gl: WebGLRenderingContext, debug: boolean,\n    data: Float32Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, debug, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, debug, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, debug, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function createStaticIndexBuffer(\n    gl: WebGLRenderingContext, debug: boolean, data: Uint16Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, debug, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, debug, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, debug,\n      () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function getNumChannels(): number {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\n\nexport function createTexture(\n    gl: WebGLRenderingContext, debug: boolean): WebGLTexture {\n  return throwIfNull<WebGLTexture>(\n      gl, debug, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\n\nexport function validateTextureSize(width: number, height: number) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if ((width <= 0) || (height <= 0)) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if ((width > maxTextureSize) || (height > maxTextureSize)) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error(\n        'Requested texture size ' + requested +\n        ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\n\nexport function createFramebuffer(\n    gl: WebGLRenderingContext, debug: boolean): WebGLFramebuffer {\n  return throwIfNull<WebGLFramebuffer>(\n      gl, debug, () => gl.createFramebuffer(),\n      'Unable to create WebGLFramebuffer.');\n}\n\nexport function bindVertexBufferToProgramAttribute(\n    gl: WebGLRenderingContext, debug: boolean, program: WebGLProgram,\n    attribute: string, buffer: WebGLBuffer, arrayEntriesPerItem: number,\n    itemStrideInBytes: number, itemOffsetInBytes: number): boolean {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, debug, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, debug,\n      () => gl.vertexAttribPointer(\n          loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes,\n          itemOffsetInBytes));\n  callAndCheck(gl, debug, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\n\nexport function bindTextureUnit(\n    gl: WebGLRenderingContext, debug: boolean, texture: WebGLTexture,\n    textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, debug, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\n\nexport function unbindTextureUnit(\n    gl: WebGLRenderingContext, debug: boolean, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, debug, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function getProgramUniformLocationOrThrow(\n    gl: WebGLRenderingContext, debug: boolean, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return throwIfNull<WebGLUniformLocation>(\n      gl, debug, () => gl.getUniformLocation(program, uniformName),\n      'uniform \"' + uniformName + '\" not present in program.');\n}\n\nexport function getProgramUniformLocation(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return gl.getUniformLocation(program, uniformName);\n}\n\nexport function bindTextureToProgramUniformSampler(\n    gl: WebGLRenderingContext, debug: boolean, program: WebGLProgram,\n    texture: WebGLTexture, uniformSamplerLocation: WebGLUniformLocation,\n    textureUnit: number) {\n  callAndCheck(\n      gl, debug, () => bindTextureUnit(gl, debug, texture, textureUnit));\n  callAndCheck(\n      gl, debug, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\n\nexport function bindCanvasToFramebuffer(\n    gl: WebGLRenderingContext, debug: boolean) {\n  callAndCheck(gl, debug, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(\n      gl, debug, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(\n      gl, debug, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\n\nexport function bindColorTextureToFramebuffer(\n    gl: WebGLRenderingContext, debug: boolean, texture: WebGLTexture,\n    framebuffer: WebGLFramebuffer) {\n  callAndCheck(\n      gl, debug, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl, debug,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\n\nexport function unbindColorTextureFromFramebuffer(\n    gl: WebGLRenderingContext, debug: boolean, framebuffer: WebGLFramebuffer) {\n  callAndCheck(\n      gl, debug, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl, debug,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\n\nexport function validateFramebuffer(gl: WebGLRenderingContext) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error(\n        'Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\n\nexport function getFramebufferErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull<T>(\n    gl: WebGLRenderingContext, debug: boolean, returnTOrNull: () => T | null,\n    failureMessage: string): T {\n  const tOrNull: T|null = callAndCheck(gl, debug, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl: WebGLRenderingContext, textureUnit: number) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [\n    shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n  ];\n}\n\nexport function getShapeAs3D(shape: number[]): [number, number, number] {\n  let shapeAs3D: [number, number, number] = [1, 1, 1];\n  const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n  if (!isScalar) {\n    shapeAs3D =\n        [getBatchDim(shape), ...getRowsCols(shape)] as [number, number, number];\n  }\n  return shapeAs3D;\n}\n\nexport function getTextureShapeFromLogicalShape(\n    logShape: number[], isPacked = false): [number, number] {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map(\n        (d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (\n      logShape.length === 2 && logShape[0] <= maxTexSize &&\n      logShape[1] <= maxTexSize) {\n    return logShape as [number, number];\n  } else if (\n      logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n      logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (\n      logShape.length === 3 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n      logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (\n      logShape.length === 4 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n\n      const batchDim = getBatchDim(logShape);\n      let rows = 2, cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2) as [number, number];\n    }\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n: number): boolean {\n  return n % 2 === 0;\n}\n\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1: number[], shape2: number[]): boolean {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {  // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n      shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {  // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) &&\n        (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE: number;\nlet MAX_TEXTURES_IN_SHADER: number;\n\nexport function getWebGLMaxTextureSize(webGLVersion: number): number {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\n\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\n\nexport function getMaxTexturesInShader(webGLVersion: number): number {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\n\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion: number):\n    number {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion: number;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n      webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\n\nexport function hasExtension(gl: WebGLRenderingContext, extensionName: string) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nexport function isWebGLVersionEnabled(webGLVersion: 1|2) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    return false;\n  }\n  return false;\n}\n\nexport function isCapableOfRenderingToFloatTexture(webGLVersion: number):\n    boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion: number): boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension =\n          gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(\n          gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl: WebGLRenderingContext):\n    boolean {\n  const texConfig = getTextureConfig(gl);\n\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension: any): boolean {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion: number) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n\n  // tslint:disable-next-line:no-any\n  const isEnabled = (gl as any).fenceSync != null;\n  return isEnabled;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {device_util, env} from '@tensorflow/tfjs-core';\n\nimport {getMaxTexturesInShader, getWebGLDisjointQueryTimerVersion, getWebGLMaxTextureSize, isCapableOfRenderingToFloatTexture, isDownloadFloatTextureEnabled, isWebGLFenceEnabled, isWebGLVersionEnabled} from './webgl_util';\n\nconst ENV = env();\n\n/**\n * This file contains WebGL-specific flag registrations.\n */\n\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);\n\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', () => {\n  if (isWebGLVersionEnabled(2)) {\n    return 2;\n  } else if (isWebGLVersionEnabled(1)) {\n    return 1;\n  }\n  return 0;\n});\n\nENV.registerFlag(\n    'WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);\n\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', () => true);\n\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);\n\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));\n\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the depthwise conv op. */\n// TODO: https://github.com/tensorflow/tfjs/issues/1679\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => false);\n\n/** Whether we will pack binary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack unary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack array ops. */\nENV.registerFlag(\n    'WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack image ops. */\nENV.registerFlag(\n    'WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURE_SIZE',\n    () => getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURES_IN_SHADER',\n    () => getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {\n  const webGLVersion = ENV.getNumber('WEBGL_VERSION');\n\n  if (webGLVersion === 0) {\n    return 0;\n  }\n  return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag(\n    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE',\n    () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n        !device_util.isMobile());\n\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag(\n    'WEBGL_RENDER_FLOAT32_CAPABLE',\n    () => isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {\n  return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n      false :\n      ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag(\n    'WEBGL_DOWNLOAD_FLOAT_ENABLED',\n    () => isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/** Whether the fence API is available. */\nENV.registerFlag(\n    'WEBGL_FENCE_API_ENABLED',\n    () => isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {\n  // Use uniform uploads only when 32bit floats are supported. In\n  // 16bit\n  // environments there are problems with comparing a 16bit texture value\n  // with a 32bit uniform value.\n  const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n  return useUniforms ? 4 : 0;\n});\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`float v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        float result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        vec4 result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ArgMinMaxProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo, op: 'max'|'min',\n      firstPass: boolean) {\n    const windowSize = reduceInfo.windowSize;\n    const batchSize = reduceInfo.batchSize;\n    const inSize = reduceInfo.inSize;\n    const outSize = Math.ceil(inSize / windowSize);\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    this.outputShape = [batchSize, outSize];\n    const compOp = (op === 'max') ? '>' : '<';\n    const indexSnippet = firstPass ?\n        'inOffset + i;' :\n        'round(getBestIndicesA(batch, inOffset + i));';\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          int inIdx = ${indexSnippet};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${compOp} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {env} from '@tensorflow/tfjs-core';\n\nexport type GLSL = {\n  version: string,\n  attribute: string,\n  varyingVs: string,\n  varyingFs: string,\n  texture2D: string,\n  output: string,\n  defineOutput: string,\n  defineSpecialNaN: string,\n  defineSpecialInf: string,\n  defineRound: string\n};\n\nexport function getGlslDifferences(): GLSL {\n  let version: string;\n  let attribute: string;\n  let varyingVs: string;\n  let varyingFs: string;\n  let texture2D: string;\n  let output: string;\n  let defineOutput: string;\n  let defineSpecialNaN: string;\n  let defineSpecialInf: string;\n  let defineRound: string;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    version = '#version 300 es';\n    attribute = 'in';\n    varyingVs = 'out';\n    varyingFs = 'in';\n    texture2D = 'texture';\n    output = 'outputColor';\n    defineOutput = 'out vec4 outputColor;';\n\n    // Use custom isnan definition to work across differences between\n    // implementations on various platforms. While this should happen in ANGLE\n    // we still see differences between android and windows (on chrome) when\n    // using isnan directly.\n    defineSpecialNaN = `\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;\n    // In webgl 2 we do not need to specify a custom isinf so there is no\n    // need for a special INFINITY constant.\n    defineSpecialInf = ``;\n    defineRound = `\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  } else {\n    version = '';\n    attribute = 'attribute';\n    varyingVs = 'varying';\n    varyingFs = 'varying';\n    texture2D = 'texture2D';\n    output = 'gl_FragColor';\n    defineOutput = '';\n    // WebGL1 has no built in isnan so we define one here.\n    defineSpecialNaN = `\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;\n    defineSpecialInf = `\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;\n    defineRound = `\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  }\n\n  return {\n    version,\n    attribute,\n    varyingVs,\n    varyingFs,\n    texture2D,\n    output,\n    defineOutput,\n    defineSpecialNaN,\n    defineSpecialInf,\n    defineRound\n  };\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(\n    coords: string[], shape: number[], index = 'index'): string {\n  const strides = util.computeStrides(shape);\n  return strides\n      .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\nfunction buildVec(x: string[]): string {\n  if (x.length === 1) {\n    return `${x[0]}`;\n  }\n  return `vec${x.length}(${x.join(',')})`;\n}\n\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x: string[], y: string[]): string {\n  if (x.length !== y.length) {\n    throw new Error(\n        `Vectors to be dotted must be of the same length -` +\n        `got ${x.length} and ${y.length}`);\n  }\n\n  const slices: string[] = [];\n  const nearestVec4 = Math.floor(x.length / 4);\n  const nearestVec4Remainder = x.length % 4;\n\n  for (let i = 0; i < nearestVec4; i++) {\n    const xSlice = x.slice(i * 4, i * 4 + 4);\n    const ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    let xSlice = x.slice(nearestVec4 * 4);\n    let ySlice = y.slice(nearestVec4 * 4);\n    if (xSlice.length === 1) {\n      xSlice = xSlice.map(d => `float(${d})`);\n      ySlice = ySlice.map(d => `float(${d})`);\n    }\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  return slices.map((d, i) => `dot(${d})`).join('+');\n}\n\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape: [number, number, number]): string {\n  const strides = util.computeStrides(shape).map(d => d.toString());\n\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\n\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nconst {getBroadcastDims} = backend_util;\nimport {getGlslDifferences, GLSL} from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\n\nexport type ShapeInfo = {\n  logicalShape: number[],\n  texShape: [number, number],\n  isUniform: boolean,\n  isPacked: boolean,\n  flatOffset: number\n};\n\nexport type InputInfo = {\n  name: string,\n  shapeInfo: ShapeInfo\n};\n\nexport function makeShader(\n    inputsInfo: InputInfo[], outputShape: ShapeInfo, userCode: string,\n    usesPackedTextures: boolean): string {\n  const prefixSnippets: string[] = [];\n  inputsInfo.forEach(x => {\n    const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n\n    // Snippet when we decided to upload the values as uniform.\n    if (x.shapeInfo.isUniform) {\n      prefixSnippets.push(\n          `uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);\n    } else {\n      prefixSnippets.push(`uniform sampler2D ${x.name};`);\n      prefixSnippets.push(`uniform int offset${x.name};`);\n    }\n  });\n  const inputPrefixSnippet = prefixSnippets.join('\\n');\n\n  const inputSamplingSnippet =\n      inputsInfo\n          .map(x => getInputSamplingSnippet(x, outputShape, usesPackedTextures))\n          .join('\\n');\n  const outTexShape = outputShape.texShape;\n  const glsl = getGlslDifferences();\n  const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n  let outputSamplingSnippet: string;\n  let floatTextureSetOutputSnippet: string;\n  let shaderPrefix = getShaderPrefix(glsl);\n\n  if (outputShape.isPacked) {\n    outputSamplingSnippet =\n        getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n  } else {\n    outputSamplingSnippet =\n        getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n  }\n\n  if (usesPackedTextures) {\n    shaderPrefix += SHADER_PACKED_PREFIX;\n  }\n\n  const source = [\n    shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n    inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode\n  ].join('\\n');\n  return source;\n}\n\nfunction getSamplerFromInInfo(inInfo: InputInfo): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getSamplerScalar(inInfo);\n    case 1:\n      return getSampler1D(inInfo);\n    case 2:\n      return getSampler2D(inInfo);\n    case 3:\n      return getSampler3D(inInfo);\n    case 4:\n      return getSampler4D(inInfo);\n    case 5:\n      return getSampler5D(inInfo);\n    case 6:\n      return getSampler6D(inInfo);\n    default:\n      throw new Error(\n          `${shape.length}-D input sampling` +\n          ` is not yet supported`);\n  }\n}\n\nfunction getPackedSamplerFromInInfo(inInfo: InputInfo): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getPackedSamplerScalar(inInfo);\n    case 1:\n      return getPackedSampler1D(inInfo);\n    case 2:\n      return getPackedSampler2D(inInfo);\n    case 3:\n      return getPackedSampler3D(inInfo);\n    default:\n      return getPackedSamplerND(inInfo);\n  }\n}\n\nfunction getInputSamplingSnippet(\n    inInfo: InputInfo, outShapeInfo: ShapeInfo,\n    usesPackedTextures = false): string {\n  let res = '';\n  if (usesPackedTextures) {\n    res += getPackedSamplerFromInInfo(inInfo);\n  } else {\n    res += getSamplerFromInInfo(inInfo);\n  }\n\n  const inShape = inInfo.shapeInfo.logicalShape;\n  const outShape = outShapeInfo.logicalShape;\n  if (inShape.length <= outShape.length) {\n    if (usesPackedTextures) {\n      res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n    } else {\n      res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n    }\n  }\n  return res;\n}\n\nfunction getPackedOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number]): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutputPacked1DCoords(outShape as [number], outTexShape);\n    case 2:\n      return getOutputPacked2DCoords(outShape as [number, number], outTexShape);\n    case 3:\n      return getOutputPacked3DCoords(\n          outShape as [number, number, number], outTexShape);\n    default:\n      return getOutputPackedNDCoords(outShape, outTexShape);\n  }\n}\n\nfunction getOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number]): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutput1DCoords(outShape as [number], outTexShape);\n    case 2:\n      return getOutput2DCoords(outShape as [number, number], outTexShape);\n    case 3:\n      return getOutput3DCoords(\n          outShape as [number, number, number], outTexShape);\n    case 4:\n      return getOutput4DCoords(\n          outShape as [number, number, number, number], outTexShape);\n    case 5:\n      return getOutput5DCoords(\n          outShape as [number, number, number, number, number], outTexShape);\n    case 6:\n      return getOutput6DCoords(\n          outShape as [number, number, number, number, number, number],\n          outTexShape);\n    default:\n      throw new Error(\n          `${outShape.length}-D output sampling is not yet supported`);\n  }\n}\n\nfunction getFloatTextureSampleSnippet(glsl: GLSL): string {\n  return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${glsl.texture2D}(textureSampler, uv).r;\n    }\n  `;\n}\n\nfunction getFloatTextureSetRSnippet(glsl: GLSL): string {\n  return `\n    void setOutput(float val) {\n      ${glsl.output} = vec4(val, 0, 0, 0);\n    }\n  `;\n}\n\nfunction getFloatTextureSetRGBASnippet(glsl: GLSL): string {\n  return `\n    void setOutput(vec4 val) {\n      ${glsl.output} = val;\n    }\n  `;\n}\n\nfunction getShaderPrefix(glsl: GLSL): string {\n  const SHADER_PREFIX = `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFs} vec2 resultUV;\n    ${glsl.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${glsl.defineSpecialNaN}\n    ${glsl.defineSpecialInf}\n    ${glsl.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;\n\n  return SHADER_PREFIX;\n}\n\nconst SAMPLE_1D_SNIPPET = `\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_2D_SNIPPET = `\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_3D_SNIPPET = `\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SHADER_PACKED_PREFIX = `\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;\n\nfunction getOutputScalarCoords() {\n  return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\n\nfunction getOutputPacked1DCoords(\n    shape: [number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (packedTexShape[0] === 1) {\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);\n      }\n    `;\n  }\n\n  if (packedTexShape[1] === 1) {\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);\n      }\n    `;\n  }\n\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);\n    }\n  `;\n}\n\nfunction getOutput1DCoords(\n    shape: [number], texShape: [number, number]): string {\n  if (texShape[0] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n  }\n  if (texShape[1] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n  }\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\n\nfunction getOutputPacked3DCoords(\n    shape: [number, number, number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getOutput3DCoords(\n    shape: [number, number, number], texShape: [number, number]): string {\n  const coordsFromIndexSnippet =\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n\nfunction getOutputPackedNDCoords(\n    shape: number[], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n  const texelsInBatch =\n      texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n  let texelsInBatchN = texelsInBatch;\n  let batches = ``;\n  let coords = 'b, r, c';\n\n  for (let b = 2; b < shape.length - 1; b++) {\n    texelsInBatchN *= shape[shape.length - b - 1];\n    batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n    coords = `b${b}, ` + coords;\n  }\n\n  return `\n    ivec${shape.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      ${batches}\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec${shape.length}(${coords});\n    }\n  `;\n}\n\nfunction getOutput4DCoords(\n    shape: [number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2'], shape);\n\n  return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\n\nfunction getOutput5DCoords(\n    shape: [number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3'], shape);\n\n  return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\n\nfunction getOutput6DCoords(\n    shape: [number, number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n\n  return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `;\n}\n\nfunction getOutputPacked2DCoords(\n    shape: [number, number], texShape: [number, number]): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (util.arraysEqual(shape, texShape)) {\n    return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${\n        packedTexShape[1]}));\n      }\n    `;\n  }\n\n  // texels needed to accommodate a logical row\n  const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n  /**\n   * getOutputCoords\n   *\n   * resTexRC: The rows and columns of the texels. If you move over one\n   * texel to the right in the packed texture, you are moving over one column\n   * (not two).\n   *\n   * index: The texel index\n   */\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getOutput2DCoords(\n    shape: [number, number], texShape: [number, number]): string {\n  if (util.arraysEqual(shape, texShape)) {\n    return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n  }\n  if (shape[1] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n  }\n  if (shape[0] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n  }\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getFlatOffsetUniformName(texName: string): string {\n  return `offset${texName}`;\n}\n\nfunction getPackedSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const glsl = getGlslDifferences();\n  return `\n    vec4 ${funcName}() {\n      return ${glsl.texture2D}(${texName}, halfCR);\n    }\n  `;\n}\n\nfunction getSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  if (inputInfo.shapeInfo.isUniform) {\n    return `float ${funcName}() {return ${texName};}`;\n  }\n  const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;\n  if (texNumR === 1 && texNumC === 1) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n\n  const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler1D(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const glsl = getGlslDifferences();\n\n  return `\n    vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler1D(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int index) {\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const tNumR = texShape[0];\n  const tNumC = texShape[1];\n\n  if (tNumC === 1 && tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  if (tNumC === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler2D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const glsl = getGlslDifferences();\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n  }\n\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const valuesPerRow = Math.ceil(shape[1] / 2);\n\n  return `\n    vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${\n      packedTexShape[1]}, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler2D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const offset = getFlatOffsetUniformName(texName);\n  if (texNumC === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n  if (texNumR === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  return `\n  float ${funcName}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${shape[1]} + col + ${offset};\n    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\n\nfunction getPackedSampler3D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  if (shape[0] === 1) {\n    const squeezedShape = shape.slice(1);\n    const keptDims = [1, 2];\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['b', 'row', 'col'];\n    return `\n        ${getPackedSamplerFromInInfo(newInputInfo)}\n        vec4 ${funcName}(int b, int row, int col) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n  const glsl = getGlslDifferences();\n\n  return `\n    vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler3D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride0 = shape[1] * shape[2];\n  const stride1 = shape[2];\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col', 'depth'];\n    return `\n        ${getSamplerFromInInfo(newInputInfo)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${stride0}, ${stride1}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n        float ${funcName}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n  }\n\n  if (texNumC === stride1 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n    float ${funcName}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n      float ${funcName}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};\n        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\n\nfunction getPackedSamplerND(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const rank = shape.length;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n  let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n  let params = `int b, int row, int col`;\n  let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n  for (let b = 2; b < rank - 1; b++) {\n    params = `int b${b}, ` + params;\n    texelsInBatch *= shape[rank - b - 1];\n    index = `b${b} * ${texelsInBatch} + ` + index;\n  }\n  const glsl = getGlslDifferences();\n  return `\n    vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler4D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride2 = shape[3];\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${stride1}, ${stride2}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride2 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} +\n          depth * ${stride2} + depth2;\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler5D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride3 = shape[4];\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          depth3;\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${stride1}, ${stride2}, ${stride3}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  if (texNumC === stride3 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3]},\n               ${shape[2] * shape[3]}, ${shape[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler6D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  const stride4 = shape[5];\n  const stride3 = shape[4] * stride4;\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${stride4}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride4 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},\n               ${shape[2] * shape[3] * shape[4]},\n               ${shape[3] * shape[4]},\n               ${shape[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getUniformSampler(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n\n  if (inSize < 2) {\n    return `return ${texName};`;\n  }\n  return `\n    for (int i = 0; i < ${inSize}; i++) {\n      if (i == index) {\n        return ${texName}[i];\n      }\n    }\n  `;\n}\n\nfunction getPackedSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n\n  const type = getCoordsDataType(outRank);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  let output = `return outputValue;`;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n  const isInputScalar = inSize === 1;\n  const outSize = util.sizeFromShape(outShapeInfo.logicalShape);\n  const isOutputScalar = outSize === 1;\n\n  if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n    output = `\n      return vec4(outputValue.xy, outputValue.xy);\n    `;\n  } else if (isInputScalar && !isOutputScalar) {\n    if (outRank === 1) {\n      output = `\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;\n    } else {\n      output = `\n        return vec4(outputValue.x);\n      `;\n    }\n  } else if (broadcastDims.length) {\n    const rows = inRank - 2;\n    const cols = inRank - 1;\n\n    if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.x);`;\n    } else if (broadcastDims.indexOf(rows) > -1) {\n      output = `return vec4(outputValue.x, outputValue.y, ` +\n          `outputValue.x, outputValue.y);`;\n    } else if (broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.xx, outputValue.zz);`;\n    }\n  }\n\n  return `\n    vec4 ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});\n      ${output}\n    }\n  `;\n}\n\nfunction getSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const outTexShape = outShapeInfo.texShape;\n  const inTexShape = inputInfo.shapeInfo.texShape;\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n      inputInfo.shapeInfo.flatOffset == null &&\n      util.arraysEqual(inTexShape, outTexShape)) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n  }\n\n  const type = getCoordsDataType(outRank);\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(\n    inInfo: InputInfo, squeezedShape: number[]): InputInfo {\n  // Deep copy.\n  const newInputInfo: InputInfo = JSON.parse(JSON.stringify(inInfo));\n  newInputInfo.shapeInfo.logicalShape = squeezedShape;\n  return newInputInfo;\n}\n\nfunction getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map(d => params[d]).join(', ');\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ArgMinMaxPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      shape: number[], windowSize: number, op: 'max'|'min',\n      firstPass: boolean) {\n    util.assert(\n        shape.length > 2,\n        () => `Packed arg${\n            op.charAt(0).toUpperCase() +\n            op.slice(1)} supports only inputs with rank above 2.`);\n    const inSize = shape[shape.length - 1];\n    const outSize = Math.ceil(inSize / windowSize);\n    this.outputShape = shape.slice(0, -1);\n    if (outSize > 1) {\n      this.outputShape.push(outSize);\n    }\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    const outShape = this.outputShape;\n    const rank = outShape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n\n    let sourceLocSetup;\n    let sourceRank;\n    if (outSize === 1) {\n      sourceRank = rank + 1;\n      const sourceLocDType = getCoordsDataType(sourceRank);\n      sourceLocSetup = `\n        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 1]};\n        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 2]};\n        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 1]};\n        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 2]};`;\n    } else {\n      sourceRank = rank;\n      sourceLocSetup = `\n        ${dtype} sourceLocR = coords;\n        ++${coords[rank - 1]};\n        ${dtype} sourceLocG = coords;\n        ++${coords[rank - 2]};\n        ${dtype} sourceLocA = coords;\n        --${coords[rank - 1]};\n        ${dtype} sourceLocB = coords;\n        --${coords[rank - 2]};`;\n    }\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n    const inChannel = '.' + channels[sourceRank - 1];  // e.g. \".b\" for rank 3.\n    const intChannels = channels.map(x => 'int ' + x);\n    const srcRCoords =\n        getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n    const srcGCoords =\n        getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n    const srcBCoords =\n        getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n    const srcACoords =\n        getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n\n    const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n    const fetchCandidateIdx = firstPass ? '' : `\n          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),\n                             getBestIndicesAChannel(${srcGCoords.join()}),\n                             getBestIndicesAChannel(${srcBCoords.join()}),\n                             getBestIndicesAChannel(${srcACoords.join()})));`;\n\n    const fetchValue = `vec4(\n            getAChannel(${srcRCoords.join()}),\n            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,\n            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;\n\n    const getBestIndicesAChannelSnippet = firstPass ? '' : `\n      float getBestIndicesAChannel(${intChannels.join()}) {\n        return getChannel(getBestIndicesA(${channels.join()}),\n                                          vec2(${channels.slice(-2).join()}));\n      }`;\n\n    this.userCode = `\n      float getAChannel(${intChannels.join()}) {\n        return getChannel(getA(${channels.join()}),\n                               vec2(${channels.slice(-2).join()}));\n      }\n      ${getBestIndicesAChannelSnippet}\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};\n        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};\n        ${sourceLocSetup}\n        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},\n          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${fetchValue};\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          inIdx = srcIdx;\n          ${fetchCandidateIdx}\n          vec4 candidate = ${fetchValue};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AvgPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth};\n            wC+= ${dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class AvgPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = '0.0';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = '1.0';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = 'vec4(0.0)';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = 'vec4(1.0)';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        vec4 offset = ${offsetSnippet};\n        vec4 scale = ${scaleSnippet};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nexport const COMPLEX_MULTIPLY = {\n  REAL: 'return areal * breal - aimag * bimag;',\n  IMAG: 'return areal * bimag + aimag * breal;'\n};\n\nexport class BinaryOpComplexProgram implements GPGPUProgram {\n  variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n\n    this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${op}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nconst CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\n\nexport const ADD = 'return a + b;';\nexport const SUB = 'return a - b;';\nexport const MUL = 'return a * b;';\n\n// Without the equality check div produces 0.9999 for a = b, which when\n// floored can cause errors.\nexport const DIV = `\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;\n\n// We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\nexport const INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;\n\nexport const POW = `\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\n\nexport const EQUAL = `return float(a == b);`;\n\nexport const NOT_EQUAL = `return float(a != b);`;\n\nexport const LESS = `return float(a < b);`;\n\nexport const LESS_EQUAL = `return float(a <= b);`;\n\nexport const GREATER = `return float(a > b);`;\n\nexport const GREATER_EQUAL = `return float(a >= b);`;\n\nexport const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\n\nexport const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\n\nexport const MAX = CHECK_NAN_SNIPPET + `\n  return max(a, b);\n`;\nexport const MIN = CHECK_NAN_SNIPPET + `\n  return min(a, b);\n`;\nexport const MOD = `if (b == 0.0) return NAN;\n  return mod(a, b);`;\n\nexport const ATAN2 = CHECK_NAN_SNIPPET + `\n  return atan(a, b);\n`;\n\nexport const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\n\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\n\nexport class BinaryOpProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nconst CHECK_NAN_SNIPPET = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n\n// We do the same as in ./binaryop_gpu, with vec4 and ivec4.\n// On Linux, the vectorized implementation produces NaNs when a and b are 0.\nexport const DIV = `\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;\n\nexport const INT_DIV = `\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;\n\nexport const POW = `\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const PRELU = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\n\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\n\nexport const ATAN2 = `\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const EQUAL = `\n  return vec4(equal(a, b));\n`;\n\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\n\nexport const LESS = `\n  return vec4(lessThan(a, b));\n`;\n\nexport const LESS_EQUAL = `\n  return vec4(lessThanEqual(a, b));\n`;\n\nexport const GREATER = `\n  return vec4(greaterThan(a, b));\n`;\n\nexport const GREATER_EQUAL = `\n  return vec4(greaterThanEqual(a, b));\n`;\n\nexport const LOGICAL_AND = `\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;\n\nexport const LOGICAL_OR = `\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;\n\nexport const MAX = `\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const MIN = `\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport const MOD = `\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\n\nexport class BinaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n  supportsBroadcasting = true;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      op: string, aShape: number[], bShape: number[],\n      checkOutOfBounds = false) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const rank = this.outputShape.length;\n    let checkOutOfBoundsString = '';\n    if (checkOutOfBounds) {\n      if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n        checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n      } else {\n        const dtype = getCoordsDataType(rank);\n        checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n        if (rank === 1) {\n          checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n        } else {\n          const channels = getChannels('coords', rank);\n          checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n        }\n      }\n    }\n\n    this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ClipProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  // Caching uniform locations for speed.\n  minLoc: WebGLUniformLocation;\n  maxLoc: WebGLUniformLocation;\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(min: number, max: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.minLoc == null) {\n        this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n        this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n      }\n      gpgpu.gl.uniform1f(this.minLoc, min);\n      gpgpu.gl.uniform1f(this.maxLoc, max);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ClipPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  userCode: string;\n  outputShape: number[];\n\n  // Caching uniform locations for speed.\n  minLoc: WebGLUniformLocation;\n  maxLoc: WebGLUniformLocation;\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(min: number, max: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.minLoc == null) {\n        this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n        this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n      }\n      gpgpu.gl.uniform1f(this.minLoc, min);\n      gpgpu.gl.uniform1f(this.maxLoc, max);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ComplexAbsProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n    this.userCode = `\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ConcatProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n  constructor(shapes: Array<[number, number]>) {\n    this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][1];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][1];\n    }\n\n    const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      snippets.push(\n          `else if (yC < ${offsets[i]}) ` +\n          `setOutput(getT${i}(yR, yC-${shift}));`);\n    }\n    const lastIndex = offsets.length;\n    const lastShift = offsets[offsets.length - 1];\n    snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ConcatPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(shapes: number[][], axis: number) {\n    this.outputShape = backend_util.computeOutShape(shapes, axis);\n    const shape = this.outputShape;\n    const rank = shape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][axis];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][axis];\n    }\n\n    const channel = channels[axis];\n    const lastChannels = channels.slice(-2);\n    const allChannels = channels.join();\n\n    let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      // Note: the >= comparison below may seem unnecessary given the check\n      // above but is needed to workaround branch execution issues on some\n      // devices. It makes all the conditions exclusive without relying on\n      // execution order.\n      getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n    }\n    const lastIndex = offsets.length;\n    const shift = offsets[offsets.length - 1];\n    getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n\n    this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n  }\n}\n\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels: string[], channel: string, shift: number) {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              if (${isChannelsLast}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n\n    this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padFront = filterDepth - 1 - convInfo.padInfo.front;\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class DepthwiseConv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivationWeights = false) {\n    this.outputShape = convInfo.outShape;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nexport class Conv3DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.outShape;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n\n    this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${\n        strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false) {\n    this.outputShape = convInfo.outShape;\n\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${xNumRows}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${xNumCols}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConvPacked2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false) {\n    this.outputShape = convInfo.outShape;\n\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const texelsAcross = filterWidth;\n\n    let mainLoop = `int xR; int xC; int xCOffset;`;\n\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `\n          vec4 xTexelR${r}C${c * 2} = vec4(0.);\n          vec4 wR${r}C${c} = vec4(0.);\n          vec4 xR${r}C${c} = vec4(0.);`;\n      }\n    }\n\n    /**\n     * This vectorized implementation works by gathering the values needed for\n     * each output channel's dot product into vec4's and then multiplying them\n     * all together (this happens in the final double for-loop below). Most of\n     * the main loop consists of constructing these vec4's with the minimum\n     * number of texture2D calls, which means making use of all four returned\n     * values from a texture2D call at once.\n     */\n    for (let r = 0; r < filterHeight; r++) {\n      for (let texelC = 0; texelC < texelsAcross; texelC++) {\n        const c = texelC * 2;\n\n        mainLoop += `\n          xR = xRCorner + ${r * dilationHeight};\n          xC = xCCorner + ${c * dilationWidth};\n        `;\n\n        if (strideWidth === 1) {\n          if (c < filterWidth) {\n            // If padding is odd, the outer texels have to be composed.\n            if (padLeft % 2 === 1) {\n              // TODO: Ensure vec4 previous does not result in redundant sample,\n              // and avoid setting xTexelRC's that exceed the boundary in the\n              // first place rather than resetting them to vec4(0)).\n\n              // To compute xCOffset:\n              // - If padding is odd, we must add 1 to ensure we ask for an\n              // even-numbered row.\n              // - We subtract 2 to access the previous texel.\n\n              mainLoop += `\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${\n                  xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    xTexelR${r}C${c}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${\n                  xNumCols}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);\n                } else {\n                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);\n                }\n              `;\n            } else {\n              // Padding is even, so xRC corresponds to a single texel.\n              mainLoop += `\n                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xR${r}C${c} = xTexelR${r}C${c};\n              `;\n            }\n\n            if (c + 1 < filterWidth) {\n              // If dilation is even, the second entry should match the first\n              // (either both are composed or both are single samples). But if\n              // dilation is odd, then the second entry should be the opposite\n              // of the first (if the first is composed, the second is a single\n              // sample, and vice versa.)\n\n              const nextTexelOffset = padLeft % 2 === 0 ?\n                  util.nearestLargerEven(dilationWidth) :\n                  dilationWidth;\n\n              if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                  (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `;\n\n                // If dilation > 1 then the xRC's will not be able to share any\n                // values, so each xRC will require two unique calls to getX.\n                if (dilationWidth > 1) {\n                  mainLoop += `\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${xNumRows} &&\n                      xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${r}C${c} = vec4(0.);\n                    }\n                  `;\n                }\n\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);\n                `;\n              } else {\n                mainLoop += `\n                  xCOffset = xC + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};\n                `;\n              }\n            }\n          }\n        } else {  // stride > 1\n          if (c < filterWidth) {\n            mainLoop += `\n              if(xR >= 0 && xR < ${xNumRows}) {\n            `;\n\n            // Depending on whether padLeft is even or odd, we want either the\n            // xy or zw channels from X texels for xR${r}C${c}. If padLeft is\n            // even, xR${r}C${c + 1} is simply the zw channels of texels we've\n            // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will\n            // need to come from the xy channels of a new texel, hence the `vec4\n            // final` initialized below.\n            if (padLeft % 2 === 1) {\n              mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);\n                `;\n              }\n            } else {\n              mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n                `;\n              }\n            }\n\n            mainLoop += `}`;\n          }\n        }\n\n        if (c < filterWidth) {\n          mainLoop += `\n            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);\n            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);\n          `;\n\n          if (c + 1 < filterWidth) {\n            mainLoop += `\n              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);\n              wR${r}C${c + 1} =\n                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;\n          }\n        }\n      }\n    }\n\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;\n      }\n    }\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${mainLoop}\n\n        vec4 result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class CropAndResizeProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      imageShape: [number, number, number, number], boxShape: [number, number],\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number) {\n    const [batch, imageHeight, imageWidth, depth] = imageShape;\n    const [numBoxes, ] = boxShape;\n    const [cropHeight, cropWidth] = cropSize;\n    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n    const methodId = method === 'bilinear' ? 1 : 0;\n\n    const [inputHeightFloat, inputWidthFloat] =\n        [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n\n    const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n        [\n          `${(imageHeight - 1) / (cropHeight - 1)}`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n        [\n          `${(imageWidth - 1) / (cropWidth - 1)}`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class CumSumProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(shape: number[], exclusive: boolean, reverse: boolean) {\n    this.outputShape = shape;\n    const rank = shape.length;\n    const finalDim = shape[shape.length - 1];\n    const comparator = reverse ? '<' : '>';\n\n    this.userCode = `\n      int getIndex(int i) {\n        ${reverse ? `return ${finalDim} -i - 1;` : 'return i;'}\n      }\n\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = 0.0;\n        for (int i = ${finalDim} - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx ${comparator} end) {\n            continue;\n          }\n          if (idx == end && ${exclusive}) {\n            continue;\n          }\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n}\n\nfunction getCoords(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {getDenseTexShape, PackingScheme} from './tex_util';\n\nexport class DecodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: [number, number, number];\n  packedInputs = false;\n  packedOutput = true;\n  outPackingScheme = PackingScheme.DENSE;\n\n  constructor(outputShape: [number, number, number]) {\n    const texShape = getDenseTexShape(outputShape);\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        shader_util.getLogicalCoordinatesFromFlatIndex(\n            ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {getDenseTexShape, PackingScheme} from './tex_util';\n\nexport class DecodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: [number, number, number];\n  outPackingScheme = PackingScheme.DENSE;\n\n  constructor(outputShape: [number, number, number]) {\n    const texShape = getDenseTexShape(outputShape);\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        shader_util.getLogicalCoordinatesFromFlatIndex(\n            ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthToSpaceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  blockSize: number;\n  dataFormat: string;\n\n  constructor(\n      outputShape: number[], blockSize: number, dataFormat: 'NHWC'|'NCHW') {\n    this.outputShape = outputShape;\n    this.blockSize = blockSize;\n    this.dataFormat = dataFormat;\n    this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${blockSize};\n      int offset_h = imod(h, ${blockSize});\n      int in_w = w / ${blockSize};\n      int offset_w = imod(w, ${blockSize});\n      int offset_d = (offset_h * ${blockSize} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `;\n  }\n\n  private getHeightCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[1]`;\n    } else {\n      return `coords[2]`;\n    }\n  }\n\n  private getWidthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[2]`;\n    } else {\n      return `coords[3]`;\n    }\n  }\n\n  private getDepthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[3]`;\n    } else {\n      return `coords[1]`;\n    }\n  }\n\n  private getOutputDepthSize(): number {\n    if (this.dataFormat === 'NHWC') {\n      return this.outputShape[3];\n    } else {\n      return this.outputShape[1];\n    }\n  }\n\n  private getInputSamplingString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `getX(b, in_h, in_w, in_d)`;\n    } else {\n      return `getX(b, in_d, in_h, in_w)`;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DiagProgram implements GPGPUProgram {\n  variableNames = ['X'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(size: number) {\n    this.outputShape = [size, size];\n    this.userCode = `\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = false;\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: [number, number, number]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nexport class EncodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(\n      outputShape: [number, number, number], texShape: [number, number],\n      inputIsUnsignedByte = false) {\n    const glsl = getGlslDifferences();\n    const [height, width] = texShape;\n    this.outputShape = outputShape;\n\n    let output = `result`;\n    if (inputIsUnsignedByte) {\n      output = `floor(result * 255. + 0.5)`;\n    }\n\n    this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / ${width};\n        int c = imod(flatIndex, ${width});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n        vec4 values = ${glsl.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${glsl.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\n\nexport class EncodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(\n      outputShape: [number, number, number], texShape: [number, number],\n      inputIsUnsignedByte = false) {\n    const glsl = getGlslDifferences();\n    const [height, width] = texShape;\n    this.outputShape = outputShape;\n\n    let mainLoop = '';\n    let output = 'result';\n    if (inputIsUnsignedByte) {\n      output = 'floor(result * 255. + 0.5)';\n    }\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        const channel = row * 2 + col;\n\n        mainLoop += `\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${outputShape[2]}) {\n            localCoords[2] += ${col};\n            if(localCoords[1] + ${row} < ${outputShape[1]}) {\n              localCoords[1] += ${row};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${width};\n              c = imod(flatIndex, ${width});\n              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n              values = ${glsl.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${channel}] = values[0];\n              } else if(offset == 1) {\n                result[${channel}] = values[1];\n              } else if(offset == 2) {\n                result[${channel}] = values[2];\n              } else {\n                result[${channel}] = values[3];\n              }\n            }\n          }\n        `;\n      }\n    }\n\n    this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${mainLoop}\n\n        ${glsl.output} = ${output};\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport const COMPLEX_FFT = {\n  REAL: 'return real * expR - imag * expI;',\n  IMAG: 'return real * expI + imag * expR;'\n};\n\nexport class FFTProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(op: string, inputShape: [number, number], inverse: boolean) {\n    const innerDim = inputShape[1];\n    this.outputShape = inputShape;\n\n    const exponentMultiplierSnippet =\n        inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n    const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n\n    this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${op}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FillProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  valueLoc: WebGLUniformLocation;\n\n  constructor(shape: number[], value: number) {\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n\n    this.userCode = `\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(value: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.valueLoc == null) {\n        this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n      }\n      gpgpu.gl.uniform1f(this.valueLoc, value);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class GatherProgram implements GPGPUProgram {\n  variableNames = ['A', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], indicesLength: number, axis: number) {\n    const outputShape: number[] = aShape.slice();\n    outputShape[axis] = indicesLength;\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape, axis);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\nfunction getSourceCoords(aShape: number[], axis: number): string {\n  const rank = aShape.length;\n  if (rank > 4) {\n    throw Error(`Gather for rank ${rank} is not yet supported`);\n  }\n  if (rank === 1) {\n    return `int(getIndices(resRC))`;\n  }\n\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    if (i === axis) {\n      sourceCoords.push(`int(getIndices(${currentCoords[i]}))`);\n    } else {\n      sourceCoords.push(`${currentCoords[i]}`);\n    }\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class GatherNDProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  constructor(\n      private sliceDim: number, private strides: number[], shape: number[]) {\n    this.outputShape = shape;\n    const stridesType = getCoordsDataType(strides.length);\n    const dtype = getCoordsDataType(shape.length);\n    const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';\n    this.userCode = `\n        ${stridesType} strides = ${stridesType}(${this.strides});\n         void main() {\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${strideString};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {PixelData, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {getGlslDifferences} from './glsl_version';\nimport * as tex_util from './tex_util';\nimport {TextureConfig} from './tex_util';\nimport * as webgl_util from './webgl_util';\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, debug: boolean): WebGLShader {\n  const glsl = getGlslDifferences();\n  const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n  return webgl_util.createVertexShader(gl, debug, vertexShaderSource);\n}\n\nexport function createVertexBuffer(\n    gl: WebGLRenderingContext, debug: boolean): WebGLBuffer {\n  // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n  const vertexArray = new Float32Array(\n      [-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, debug, vertexArray);\n}\n\nexport function createIndexBuffer(\n    gl: WebGLRenderingContext, debug: boolean): WebGLBuffer {\n  // OpenGL (and WebGL) have \"CCW == front\" winding\n  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, debug, triangleVertexIndices);\n}\n\nfunction createAndConfigureTexture(\n    gl: WebGLRenderingContext, debug: boolean, width: number, height: number,\n    internalFormat: number, textureFormat: number,\n    textureType: number): WebGLTexture {\n  webgl_util.validateTextureSize(width, height);\n  const texture = webgl_util.createTexture(gl, debug);\n\n  const tex2d = gl.TEXTURE_2D;\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(tex2d, texture));\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.texImage2D(\n          tex2d, 0, internalFormat, width, height, 0, textureFormat,\n          textureType, null));\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n  return texture;\n}\n\nexport function createFloat32MatrixTexture(\n    gl: WebGLRenderingContext, debug: boolean, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, debug, width, height, textureConfig.internalFormatFloat,\n      textureConfig.textureFormatFloat, gl.FLOAT);\n}\n\nexport function createFloat16MatrixTexture(\n    gl: WebGLRenderingContext, debug: boolean, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, debug, width, height, textureConfig.internalFormatHalfFloat,\n      textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\n\nexport function createUnsignedBytesMatrixTexture(\n    gl: WebGLRenderingContext, debug: boolean, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, debug, width, height, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE);\n}\n\nexport function createPackedMatrixTexture(\n    gl: WebGLRenderingContext, debug: boolean, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, debug, width, height, textureConfig.internalFormatPackedFloat,\n      gl.RGBA, gl.FLOAT);\n}\n\nexport function createFloat16PackedMatrixTexture(\n    gl: WebGLRenderingContext, debug: boolean, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLTexture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, debug, width, height, textureConfig.internalFormatPackedHalfFloat,\n      gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\n\nexport function bindVertexProgramAttributeStreams(\n    gl: WebGLRenderingContext, debug: boolean, program: WebGLProgram,\n    vertexBuffer: WebGLBuffer): boolean {\n  const posOffset = 0;               // x is the first buffer element\n  const uvOffset = 3 * 4;            // uv comes after [x y z]\n  const stride = (3 * 4) + (2 * 4);  // xyz + uv, each entry is 4-byte float.\n  webgl_util.callAndCheck(\n      gl, debug, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n  const success = webgl_util.bindVertexBufferToProgramAttribute(\n      gl, debug, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success &&\n      webgl_util.bindVertexBufferToProgramAttribute(\n          gl, debug, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\n\nexport function uploadDenseMatrixToTexture(\n    gl: WebGLRenderingContext, debug: boolean, texture: WebGLTexture,\n    width: number, height: number, data: TypedArray,\n    textureConfig: TextureConfig) {\n  webgl_util.callAndCheck(\n      gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n\n  let dataForUpload: TypedArray, texelDataType: number, internalFormat: number;\n  if (data instanceof Uint8Array) {\n    dataForUpload = new Uint8Array(width * height * 4);\n    texelDataType = gl.UNSIGNED_BYTE;\n    internalFormat = gl.RGBA;\n  } else {\n    dataForUpload = new Float32Array(width * height * 4);\n    texelDataType = gl.FLOAT;\n    internalFormat = textureConfig.internalFormatPackedFloat;\n  }\n\n  dataForUpload.set(data);\n\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.texImage2D(\n          gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA,\n          texelDataType, dataForUpload));\n\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function uploadPixelDataToTexture(\n    gl: WebGLRenderingContext, debug: boolean, texture: WebGLTexture,\n    pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n    HTMLVideoElement) {\n  webgl_util.callAndCheck(\n      gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n  if ((pixels as PixelData).data instanceof Uint8Array) {\n    webgl_util.callAndCheck(\n        gl, debug,\n        () => gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA,\n            gl.UNSIGNED_BYTE, (pixels as PixelData).data));\n  } else {\n    webgl_util.callAndCheck(\n        gl, debug,\n        () => gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,\n            pixels as ImageData | HTMLImageElement | HTMLCanvasElement |\n                HTMLVideoElement));\n  }\n\n  webgl_util.callAndCheck(gl, debug, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function createBufferFromOutputTexture(\n    gl2: WebGL2RenderingContext, debug: boolean, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLBuffer {\n  // Create and bind the buffer.\n  const buffer = gl2.createBuffer();\n  webgl_util.callAndCheck(\n      gl2, debug, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n\n  // Initialize the buffer to the size of the texture in bytes.\n  const bytesPerFloat = 4;\n  const valuesPerTexel = 4;\n  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n\n  webgl_util.callAndCheck(\n      gl2, debug,\n      () => gl2.bufferData(\n          gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n\n  // Enqueue a command on the GPU command queue to copy of texture into the\n  // buffer.\n  webgl_util.callAndCheck(\n      gl2, debug,\n      () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n\n  webgl_util.callAndCheck(\n      gl2, debug, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n\n  return buffer;\n}\n\nexport function downloadFloat32MatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer,\n    size: number): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget = new Float32Array(size);\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(\n    gl: WebGLRenderingContext, debug: boolean, rows: number, columns: number,\n    textureConfig: TextureConfig) {\n  const [w, h] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n\n  const numChannels = 4;\n  const downloadTarget = new Uint8Array(\n      tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.readPixels(\n          0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE,\n          downloadTarget));\n\n  // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n  // decoding of the 4 bytes that back each 32 bit float.\n  return new Float32Array(downloadTarget.buffer);\n}\n\nexport function downloadPackedMatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer, batch: number, rows: number,\n    cols: number, physicalRows: number, physicalCols: number,\n    textureConfig: TextureConfig): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget =\n      new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(\n          physicalRows, physicalCols));\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadMatrixFromPackedOutputTexture(\n    gl: WebGLRenderingContext, debug: boolean, physicalRows: number,\n    physicalCols: number): Float32Array {\n  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n  webgl_util.callAndCheck(\n      gl, debug,\n      () => gl.readPixels(\n          0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n\n  return packedRGBA;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext, setWebGLContext} from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport {TextureConfig} from './tex_util';\nimport {WebGL1DisjointQueryTimerExtension, WebGL2DisjointQueryTimerExtension} from './webgl_types';\nimport * as webgl_util from './webgl_util';\n\nexport interface FenceContext {\n  query: WebGLQuery|WebGLSync;\n  isFencePassed(): boolean;\n}\n\nexport class GPGPUContext {\n  gl: WebGLRenderingContext;\n  textureFloatExtension: {};\n  textureHalfFloatExtension: {};\n  colorBufferFloatExtension: {};\n  colorBufferHalfFloatExtension: {};\n  disjointQueryTimerExtension: WebGL2DisjointQueryTimerExtension|\n      WebGL1DisjointQueryTimerExtension;\n  vertexBuffer: WebGLBuffer;\n  indexBuffer: WebGLBuffer;\n  framebuffer: WebGLFramebuffer;\n  outputTexture: WebGLTexture|null = null;\n  program: WebGLProgram|null = null;\n  private disposed = false;\n  private disjoint: boolean;\n  private textureConfig: TextureConfig;\n\n  constructor(gl?: WebGLRenderingContext) {\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n\n      this.textureFloatExtension =\n          webgl_util.getExtensionOrThrow(this.gl, this.debug, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension = webgl_util.getExtensionOrThrow(\n            this.gl, this.debug, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support half float textures, yet the ' +\n            'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = webgl_util.getExtensionOrThrow(\n            this.gl, this.debug, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support color renderable half floats, yet ' +\n            'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl, this.debug);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl, this.debug);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl, this.debug);\n\n    this.textureConfig =\n        tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  private get debug(): boolean {\n    return env().getBool('DEBUG');\n  }\n\n  public dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n          ' This is probably a resource leak, delete the program with ' +\n          'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound output matrix ' +\n          'texture.  This is probably a resource leak, delete the output ' +\n          'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n          'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, this.debug, () => gl.finish());\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  public createFloat32MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(\n        this.gl, this.debug, rows, columns, this.textureConfig);\n  }\n\n  public createFloat16MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(\n        this.gl, this.debug, rows, columns, this.textureConfig);\n  }\n\n  public createUnsignedBytesMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(\n        this.gl, this.debug, rows, columns, this.textureConfig);\n  }\n\n  public uploadPixelDataToTexture(\n      texture: WebGLTexture,\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, this.debug, texture, pixels);\n  }\n\n  public uploadDenseMatrixToTexture(\n      texture: WebGLTexture, width: number, height: number, data: TypedArray) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(\n        this.gl, this.debug, texture, width, height, data, this.textureConfig);\n  }\n\n  public createFloat16PackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(\n        this.gl, this.debug, rows, columns, this.textureConfig);\n  }\n\n  public createPackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(\n        this.gl, this.debug, rows, columns, this.textureConfig);\n  }\n\n  public deleteMatrixTexture(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(\n          this.gl, this.debug, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(\n        this.gl, this.debug, () => this.gl.deleteTexture(texture));\n  }\n\n  public downloadByteEncodedFloatMatrixFromOutputTexture(\n      texture: WebGLTexture, rows: number, columns: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(\n            this.gl, this.debug, rows, columns, this.textureConfig));\n  }\n\n  public downloadPackedMatrixFromBuffer(\n      buffer: WebGLBuffer, batch: number, rows: number, columns: number,\n      physicalRows: number, physicalCols: number): Float32Array {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(\n        this.gl, buffer, batch, rows, columns, physicalRows, physicalCols,\n        this.textureConfig);\n  }\n\n  public downloadFloat32MatrixFromBuffer(buffer: WebGLBuffer, size: number):\n      Float32Array {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  public createBufferFromTexture(\n      texture: WebGLTexture, rows: number, columns: number): WebGLBuffer {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(\n        this.gl as WebGL2RenderingContext, this.debug, rows, columns,\n        this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  public createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let query: WebGLQuery|WebGLSync;\n    let isFencePassed: () => boolean;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl as WebGL2RenderingContext;\n\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED ||\n            status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (\n        env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(\n          query,\n          env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {query, isFencePassed};\n  }\n\n  public downloadMatrixFromPackedTexture(\n      texture: WebGLTexture, physicalRows: number,\n      physicalCols: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadMatrixFromPackedOutputTexture(\n            this.gl, this.debug, physicalRows, physicalCols));\n  }\n\n  private vertexAttrsAreBound = false;\n\n  public createProgram(fragmentShaderSource: string): WebGLProgram {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    const fragmentShader: WebGLShader =\n        webgl_util.createFragmentShader(gl, this.debug, fragmentShaderSource);\n    const vertexShader: WebGLShader =\n        gpgpu_util.createVertexShader(gl, this.debug);\n    const program: WebGLProgram = webgl_util.createProgram(\n        gl,\n        this.debug,\n    );\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.attachShader(program, vertexShader));\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, this.debug, program);\n    if (this.debug) {\n      webgl_util.validateProgram(gl, this.debug, program);\n    }\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(\n          gl, this.debug, this.program, this.vertexBuffer);\n    }\n    return program;\n  }\n\n  public deleteProgram(program: WebGLProgram) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(\n          this.gl, this.debug, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  public setProgram(program: WebGLProgram|null) {\n    this.throwIfDisposed();\n    this.program = program;\n    if ((this.program != null) && this.debug) {\n      webgl_util.validateProgram(this.gl, this.debug, this.program);\n    }\n    webgl_util.callAndCheck(\n        this.gl, this.debug, () => this.gl.useProgram(program));\n  }\n\n  public getUniformLocation(\n      program: WebGLProgram, uniformName: string,\n      shouldThrow = true): WebGLUniformLocation {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(\n          this.gl, this.debug, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(\n          this.gl, program, uniformName);\n    }\n  }\n\n  public getAttributeLocation(program: WebGLProgram, attribute: string):\n      number {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(\n        this.gl, this.debug,\n        () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  public getUniformLocationNoThrow(program: WebGLProgram, uniformName: string):\n      WebGLUniformLocation {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  public setInputMatrixTexture(\n      inputMatrixTexture: WebGLTexture, uniformLocation: WebGLUniformLocation,\n      textureUnit: number) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(\n        this.gl, this.debug, this.program, inputMatrixTexture, uniformLocation,\n        textureUnit);\n  }\n\n  public setOutputMatrixTexture(\n      outputMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  public setOutputPackedMatrixTexture(\n      outputPackedMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.throwIfDisposed();\n    const [width, height] =\n        tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  public setOutputMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    this.setOutputMatrixWriteRegionDriver(\n        startColumn, startRow, numColumns, numRows);\n  }\n\n  public setOutputPackedMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  public debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.debug, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  public executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(\n        gl, this.debug,\n        () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  public blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, this.debug, () => this.gl.finish());\n  }\n\n  private getQueryTimerExtension(): WebGL1DisjointQueryTimerExtension\n      |WebGL2DisjointQueryTimerExtension {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension =\n          webgl_util.getExtensionOrThrow(\n              this.gl, this.debug,\n              env().getNumber(\n                  'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                  'EXT_disjoint_timer_query_webgl2' :\n                  'EXT_disjoint_timer_query') as\n              WebGL1DisjointQueryTimerExtension |\n          WebGL2DisjointQueryTimerExtension;\n    }\n    return this.disjointQueryTimerExtension;\n  }\n\n  private getQueryTimerExtensionWebGL2(): WebGL2DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension();\n  }\n\n  private getQueryTimerExtensionWebGL1(): WebGL1DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension() as WebGL1DisjointQueryTimerExtension;\n  }\n\n  beginQuery(): WebGLQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT() as WebGLQuery;\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  public async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await util.repeatedTry(\n        () => this.disposed ||  // while testing contexts are created / disposed\n                                // in rapid succession, so without this check we\n                                // may poll for the query timer indefinitely\n            this.isQueryAvailable(\n                query,\n                env().getNumber(\n                    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(\n        query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  private getQueryTime(query: WebGLQuery, queryTimerVersion: number): number {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const timeElapsedNanos =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  private isQueryAvailable(query: WebGLQuery, queryTimerVersion: number):\n      boolean {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const available =\n          gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const available =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  private bindTextureToFrameBuffer(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(\n        this.gl, this.debug, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  private unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(\n          this.gl, this.debug, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(\n          this.gl, this.debug, this.framebuffer);\n    }\n  }\n\n  private downloadMatrixDriver(\n      texture: WebGLTexture,\n      downloadAndDecode: () => Float32Array): Float32Array {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n\n    return result;\n  }\n\n  private setOutputMatrixTextureDriver(\n      outputMatrixTextureMaybePacked: WebGLTexture, width: number,\n      height: number) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(\n        gl, this.debug, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(\n        gl, this.debug, () => gl.scissor(0, 0, width, height));\n  }\n\n  private setOutputMatrixWriteRegionDriver(\n      x: number, y: number, width: number, height: number) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(\n        this.gl, this.debug, () => this.gl.scissor(x, y, width, height));\n  }\n\n  private throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  private throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean,\n  resolveFn: () => void\n};\n\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, Tensor, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport * as shader_compiler from './shader_compiler';\nimport {InputInfo, ShapeInfo} from './shader_compiler';\nimport {PackingScheme, TextureData, TextureUsage} from './tex_util';\n\nexport interface GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  /** If true, this program expects packed input textures. Defaults to false. */\n  packedInputs?: boolean;\n  /** If true, this program produces a packed texture. Defaults to false. */\n  packedOutput?: boolean;\n  /**\n   * Affects what type of texture we allocate for the output. Defaults to\n   * `TextureUsage.RENDER`.\n   */\n  outTexUsage?: TextureUsage;\n  /**\n   * The type of scheme to use when packing texels for the output values.\n   * See `PackingScheme` for details. Defaults to `PackingScheme.SHARED_BATCH`.\n   */\n  outPackingScheme?: PackingScheme;\n}\n\nexport interface GPGPUBinary {\n  webGLProgram: WebGLProgram;\n  program: GPGPUProgram;\n  uniformLocations: {[name: string]: WebGLUniformLocation};\n  source: string;\n  inShapeInfos: ShapeInfo[];\n  outShapeInfo: ShapeInfo;\n  infLoc: WebGLUniformLocation;\n  nanLoc: WebGLUniformLocation;\n}\n\nexport interface TensorData {\n  shape: number[];\n  texData: TextureData;\n  isUniform: boolean;\n  // Available when we decide to upload as uniform instead of texture.\n  uniformValues?: TypedArray;\n}\n\nexport function compileProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, program: GPGPUProgram, inputs: TensorData[],\n    output: TensorData): GPGPUBinary {\n  const userCode = program.userCode;\n  const inputInfos: InputInfo[] = inputs.map((input, i) => {\n    const shapeInfo: ShapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n    if (input.texData != null && input.texData.slice != null &&\n        input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n    return {name: program.variableNames[i], shapeInfo};\n  });\n  const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n  const outShapeInfo: ShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  const source = shader_compiler.makeShader(\n      inputInfos, outShapeInfo, userCode, program.packedInputs);\n\n  const webGLProgram = gpgpu.createProgram(source);\n\n  // Add special uniforms (NAN, INFINITY)\n  let infLoc: WebGLUniformLocation = null;\n  const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  }\n\n  // Add user-defined uniforms\n  const uniformLocations: {[name: string]: WebGLUniformLocation} = {};\n  for (let i = 0; i < program.variableNames.length; i++) {\n    const varName = program.variableNames[i];\n    const shouldThrow = false;\n    uniformLocations[varName] =\n        gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[`offset${varName}`] =\n        gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n  }\n\n  return {\n    program,\n    source,\n    webGLProgram,\n    uniformLocations,\n    inShapeInfos,\n    outShapeInfo,\n    infLoc,\n    nanLoc,\n  };\n}\n\nfunction validateBinaryAndProgram(\n    shapeInfos: ShapeInfo[], inputs: TensorData[]) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(\n        `Binary was compiled with ${shapeInfos.length} inputs, but ` +\n        `was executed with ${inputs.length} inputs`);\n  }\n\n  shapeInfos.forEach((s, i) => {\n    const shapeA = s.logicalShape;\n    const input = inputs[i];\n    const shapeB = input.shape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(\n          `Binary was compiled with different shapes than ` +\n          `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n    }\n    // The input is uploaded as uniform.\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n\n    const texShapeA = s.texShape;\n    const texShapeB = input.isUniform ? null : input.texData.texShape;\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(\n          `Binary was compiled with different texture shapes than the` +\n          ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n    }\n  });\n}\n\nexport function runProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, binary: GPGPUBinary, inputs: TensorData[],\n    output: TensorData,\n    customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) =>\n        void): void {\n  validateBinaryAndProgram(binary.inShapeInfos, inputs);\n  validateBinaryAndProgram([binary.outShapeInfo], [output]);\n\n  const outTex = output.texData.texture;\n  const outTexShape = output.texData.texShape;\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  }\n  gpgpu.setProgram(binary.webGLProgram);\n\n  // Set special uniforms (NAN, INFINITY)\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  }\n\n  // Set user-defined inputs\n  inputs.forEach((input, i) => {\n    const varName = binary.program.variableNames[i];\n    const varLoc = binary.uniformLocations[varName];\n    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        let vals = input.uniformValues;\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n      return;\n    }\n\n    // If the input was sliced, upload the flat offset index.\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n\n    gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n  });\n\n  if (customSetup != null) {\n    customSetup(gpgpu, binary.webGLProgram);\n  }\n  gpgpu.executeProgram();\n}\n\nexport function makeShaderKey(\n    program: GPGPUProgram, inputs: TensorData[], output: TensorData): string {\n  let keyInputs = '';\n  inputs.concat(output).forEach(x => {\n    const hasOffset = x.texData != null && x.texData.slice != null &&\n        x.texData.slice.flatOffset > 0;\n    const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n    keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n  });\n  const keyUserCode = program.userCode;\n  let key = program.constructor.name;\n  // Fast string concat. See https://jsperf.com/string-concatenation/14.\n  key += '_' + keyInputs + '_' + keyUserCode;\n  return key;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Im2ColPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      outputShape: number[], inputShape: number[],\n      convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = outputShape;\n\n    const {\n      filterWidth,\n      inChannels,\n      strideWidth,\n      strideHeight,\n      padInfo,\n      outWidth,\n      dilationWidth,\n      dilationHeight,\n      dataFormat\n    } = convInfo;\n    const {left, top} = padInfo;\n    const itemsPerBlockRow = inChannels * filterWidth;\n    const glsl = getGlslDifferences();\n    const isChannelsLast = dataFormat === 'channelsLast';\n    const rowDim = isChannelsLast ? 0 : 1;\n    const colDim = isChannelsLast ? 1 : 2;\n\n    let unrolled = ``;\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        unrolled += `\n          blockIndex = rc.y + ${col};\n          pos = rc.x + ${row};\n\n          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {\n            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${\n            top};\n            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});\n\n            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${\n            strideWidth}. - ${left}.);\n              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${\n            itemsPerBlockRow}.) / ${inChannels}.));\n\n              if(d1 < ${inputShape[colDim]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${inChannels}.));\n\n                if (${isChannelsLast}) {\n                  innerDims = vec2(d1, ch);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;\n      }\n    }\n\n    this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${unrolled}\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${rad}; j <= ${rad}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${maxD}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${powOperator};\n        setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNGradProgram implements GPGPUProgram {\n  variableNames = ['inputImage', 'outputImage', 'dy'];\n  outputShape: number[] = [];\n  userCode: string;\n  depthRadius: number;\n  bias: number;\n  alpha: number;\n  beta: number;\n  depth: number;\n\n  constructor(\n      inputShape: number[], depthRadius: number, bias: number, alpha: number,\n      beta: number) {\n    this.outputShape = inputShape;\n    this.depth = inputShape[3];\n    this.depthRadius = depthRadius;\n    this.bias = bias;\n    this.alpha = alpha;\n    this.beta = beta;\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${depthRadius})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${depthRadius} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${alpha}) * norm + float(${bias});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${alpha})\n                * float(${beta})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${beta});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${rad};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${rad}; j <= ${rad}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${powOperator};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MaxPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n          wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${effectiveFilterWidth} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class MaxPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex =\n        effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n           wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${lastIndex} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                  wR * ${effectiveFilterWidth} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MatMulPackedProgram implements GPGPUProgram {\n  variableNames = ['matrixA', 'matrixB'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      aShape: [number, number, number], outputShape: [number, number, number],\n      transposeA = false, transposeB = false, addBias = false,\n      activation: string = null, hasPreluActivation = false) {\n    this.outputShape = outputShape;\n\n    const sharedDim = transposeA ? aShape[1] : aShape[2];\n    const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n\n    const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n    const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n    const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n    const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          vec4 a = getMatrixA(rc.x, ${aSample});\n          vec4 b = getMatrixB(rc.x, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MultinomialProgram implements GPGPUProgram {\n  variableNames = ['probs'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  seedLoc: WebGLUniformLocation;\n\n  constructor(batchSize: number, numOutcomes: number, numSamples: number) {\n    this.outputShape = [batchSize, numSamples];\n\n    this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${numOutcomes - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${numOutcomes - 1}));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(seed: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.seedLoc == null) {\n        this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n      }\n      gpgpu.gl.uniform1f(this.seedLoc, seed);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class OneHotProgram implements GPGPUProgram {\n  variableNames = ['indices'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  seedLoc: WebGLUniformLocation;\n\n  constructor(\n      numIndices: number, depth: number, onValue: number, offValue: number) {\n    this.outputShape = [numIndices, depth];\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${offValue}), float(${onValue}),\n                      float(index == coords.y)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(\n      outputShape:\n          number[]) {  // TODO(https://github.com/tensorflow/tfjs/issues/893):\n                       // Only input / output 3D tensors.\n    this.outputShape = outputShape;\n    const rank = outputShape.length;\n\n    if (rank === 0) {\n      this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n    } else {\n      const channels = getChannels('rc', rank);\n      const dtype = getCoordsDataType(rank);\n      const outOfBoundsCondition =\n          getOutOfBoundsCondition(rank, outputShape, channels);\n      const setup = getSetup(\n          rank, outputShape[outputShape.length - 1],\n          outputShape[outputShape.length - 2], channels);\n      const output = getOutput(outputShape, channels);\n\n      this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n    }\n  }\n}\n\nfunction getSourceCoordsArr(rank: number, dims: string[]): string[] {\n  const coords = [];\n\n  for (let row = 0; row <= 1; row++) {\n    for (let col = 0; col <= 1; col++) {\n      let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n\n      for (let d = 2; d < rank; d++) {\n        coord = `${dims[dims.length - 1 - d]},` + coord;\n      }\n\n      coords.push(coord);\n    }\n  }\n  return coords;\n}\n\nfunction getOutOfBoundsCondition(\n    rank: number, shape: number[], dims: string[]): string {\n  if (rank === 1) {\n    return `rc > ${shape[0]}`;\n  }\n\n  let cond = '';\n  for (let i = rank - 2; i < rank; i++) {\n    cond += `${dims[i]} >= ${shape[i]}`;\n    if (i < rank - 1) {\n      cond += '||';\n    }\n  }\n\n  return cond;\n}\n\nfunction getSetup(\n    rank: number, cols: number, rows: number, dims: string[]): string {\n  if (rank === 1) {\n    return '';\n  }\n\n  const innerDims = dims.slice(-2);\n\n  return `\n    int r = ${innerDims[0]};\n    int c = ${innerDims[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${cols};\n    bool rEdge = rp1 >= ${rows};\n  `;\n}\n\nfunction getOutput(shape: number[], dims: string[]): string {\n  const rank = shape.length;\n  const sourceCoords = getSourceCoordsArr(rank, dims);\n  if (rank === 1) {\n    return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  }\n\n  return `getA(${sourceCoords[0]}),\n          cEdge ? 0. : getA(${sourceCoords[1]}),\n          rEdge ? 0. : getA(${sourceCoords[2]}),\n          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PadProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const type = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const unpackedCoords =\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n\n    if (rank === 1) {\n      this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${constantValue}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n      return;\n    }\n    this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${constantValue}));\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PadPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const coords = getChannels('rc', rank);\n    const source = getChannels('source', rank);\n    const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n    const innerDims =\n        rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n\n    const componentSetup = [\n      `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n      rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n      rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n    ];\n\n    const paddingArea = rank === 1 ?\n        'rc < start || rc >= end' :\n        'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n    let mainLoop = '';\n    for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n      mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(${constantValue});\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n    }\n    mainLoop += (rank === 1 ? `} ` : `}}`);\n\n    this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Pool2DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${\n        convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n    const flattenPositionStr =\n        `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${\n          flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                                                    flattenPositionStr) :\n                             `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n\nexport class Pool3DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv3DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${\n          flattenPositions ?\n              (includeBatchInIndex ?\n                   `(((batch * ${convInfo.inDepth} + xD) * ${\n                       convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${\n                       convInfo.inChannels} + ch` :\n                   `((xD * ${convInfo.inHeight} + xR) * ${\n                       convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n              `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ReduceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo,\n      reduceType: 'all'|'any'|'max'|'min'|'sum'|'prod') {\n    const windowSize = reduceInfo.windowSize;\n    const batchSize = reduceInfo.batchSize;\n    const inSize = reduceInfo.inSize;\n    const outSize = Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n\n    let initializationValue = '0.0';\n    let compareOp = ``;\n\n    if (reduceType === 'prod') {\n      initializationValue = '1.0';\n    } else if (reduceType === 'min') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '1.0 / 1e-20';\n      compareOp = `min`;\n    } else if (reduceType === 'max') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n      compareOp = `max`;\n    }\n\n    let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (reduceType === 'sum') {\n      returnValue = `sumValue`;\n    } else if (reduceType === 'prod') {\n      returnValue = `prodValue`;\n    } else if (reduceType === 'all') {\n      returnValue = `allValue`;\n    } else if (reduceType === 'any') {\n      returnValue = `anyValue`;\n    }\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    let vecType = `vec4`;\n\n    if (reduceType === 'all') {\n      initializationValue = '1.0';\n      updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    } else if (reduceType === 'any') {\n      initializationValue = '0.0';\n      updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nexport class ReshapePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(outputShape: [number, number, number], inputShape: [\n    number, number, number\n  ]) {\n    this.outputShape = outputShape;\n\n    let mainLoop = ``;\n    for (let i = 0; i < 4; i++) {\n      let thisRC = `thisRC = rc;`;\n      if (i % 2 === 1) {\n        thisRC += `thisRC.z += 1;`;\n      }\n      if (i > 1) {\n        thisRC += `thisRC.y += 1;`;\n      }\n\n      mainLoop += `\n        ${thisRC}\n        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i > 0 ? '}' : ''}\n      `;\n    }\n\n    this.userCode = `\n      ${getReshapedInputCoords(inputShape)}\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${outputShape[1]};\n        int cols = ${outputShape[2]};\n\n        ${mainLoop}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nfunction getReshapedInputCoords(shape: [number, number, number]): string {\n  const coordsFromIndexSnippet =\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor4D} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(dy: Tensor4D, x: Tensor4D, alignCorners: boolean) {\n    this.outputShape = x.shape;\n    const [, xHeight, xWidth, ] = x.shape;\n    const [, yHeight, yWidth] = dy.shape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor4D} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeigborBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(dy: Tensor4D, x: Tensor4D, alignCorners: boolean) {\n    this.outputShape = x.shape;\n    const [, xHeight, xWidth, ] = x.shape;\n    const [, yHeight, yWidth] = dy.shape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${effectiveXSize[0]}) *\n                (float(dyR) / float(${effectiveYSize[0]}));\n\n            float sourceFracCol =\n                float(${effectiveXSize[1]}) *\n                  (float(dyC) / float(${effectiveYSize[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${xHeight}) - 1),\n                ${alignCorners} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${xWidth}) - 1),\n                ${alignCorners} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeighborProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = alignCorners ? '0.5' : '0.0';\n\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReverseProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n\n    if (rank === 1) {\n      this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${xShape[0]} - coord - 1));\n        }\n      `;\n      return;\n    }\n    const getInCoord = (i: number) => {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - coords[${i}] - 1`;\n      }\n      return `coords[${i}]`;\n    };\n    const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');\n    const type = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${type} coords = getOutputCoords();\n        setOutput(getX(${inCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReversePackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn =\n        `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels: string[]): string {\n      return getChannel(channels);\n    }\n\n    function getG(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels: string[]): string {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels: string[]): string {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i: number, channels1: string[]): string {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ScatterProgram implements GPGPUProgram {\n  variableNames = ['updates', 'indices', 'defaultValue'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      updateSize: number, sliceDim: number, indicesRank: number,\n      updatesRank: number, strides: number[], shape: number[],\n      summingDupeIndex = true) {\n    this.outputShape = shape;\n    const stridesType = getCoordsDataType(strides.length);\n    const dtype = getCoordsDataType(shape.length);\n    let indicesString = '';\n    if (indicesRank === 1) {\n      indicesString = 'i';\n    } else if (indicesRank === 2) {\n      indicesString = 'i, j';\n    }\n    const indicesSnippet = `getIndices(${indicesString})`;\n\n    let updatesString = '';\n    if (updatesRank === 1) {\n      updatesString = 'i';\n    } else if (updatesRank === 2) {\n      updatesString = 'i, coords[1]';\n    }\n    const updatesSnippet = `getUpdates(${updatesString})`;\n\n    const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n    this.userCode = `\n        ${stridesType} strides = ${stridesType}(${strides});\n\n        void main() {\n          ${dtype} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${updateSize}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${sliceDim}; j++) {\n              int index = round(${indicesSnippet});\n              flattenedIndex += index * ${strideString};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${updatesSnippet};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class SegmentOpProgram implements GPGPUProgram {\n  variableNames = ['x', 'segmentIds'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      segOpInfo: backend_util.segment_util.SegOpInfo,\n      segOpType: 'unsortedSegmentSum') {\n    const windowSize = segOpInfo.windowSize;\n    const batchSize = segOpInfo.batchSize;\n    const inSize = segOpInfo.inSize;\n    const numSegments = segOpInfo.numSegments;\n    const outSize = numSegments * Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n\n    const initializationValue = '0.0';\n    const returnValue = `sumValue`;\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n\n    let checkValueOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n\n    let checkSegmentIdOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SelectProgram implements GPGPUProgram {\n  variableNames = ['c', 'a', 'b'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(cRank: number, shape: number[], rank: number) {\n    this.outputShape = shape;\n\n    let cCoords;\n    let abCoords;\n    if (rank > 4) {\n      throw Error(`Where for rank ${rank} is not yet supported`);\n    }\n\n    if (rank === 1) {\n      abCoords = `resRC`;\n      cCoords = `resRC`;\n    } else {\n      const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n      const cCoordVars = [];\n      const abCoordVars = [];\n      for (let i = 0; i < shape.length; i++) {\n        abCoordVars.push(`${currentCoords[i]}`);\n        if (i < cRank) {\n          cCoordVars.push(`${currentCoords[i]}`);\n        }\n      }\n      cCoords = cCoordVars.join();\n      abCoords = abCoordVars.join();\n    }\n\n    const dtype = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        float cVal = getC(${cCoords});\n        if (cVal >= 1.0) {\n          setOutput(getA(${abCoords}));\n        } else {\n          setOutput(getB(${abCoords}));\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SliceProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  // Caching uniform location for speed.\n  startLoc: WebGLUniformLocation;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n\n    const dtype = getCoordsDataType(this.rank);\n    const uniformPart = `uniform int start[${this.rank}];`;\n    const sourceCoords = getCoords(this.rank);\n\n    let body: string;\n    const coordSum = destSize.map((_, i) => {\n      return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n    });\n    body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n    this.userCode = `\n      ${uniformPart}\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n  }\n\n  getCustomSetupFunc(start: number[]) {\n    if (start.length !== this.rank) {\n      throw Error(\n          `The rank (${this.rank}) of the program must match the ` +\n          `length of start (${start.length})`);\n    }\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.startLoc == null) {\n        this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n        if (this.startLoc == null) {\n          // This means the compiler has optimized and realized it doesn't need\n          // the uniform.\n          return;\n        }\n      }\n      gpgpu.gl.uniform1iv(this.startLoc, start);\n    };\n  }\n}\n\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\n\nfunction getCoords(rank: number): string {\n  if (rank === 1) {\n    return 'sourceLoc';\n  } else if (rank <= 6) {\n    return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n  } else {\n    throw Error(`Slicing for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SlicePackedProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  // Caching uniform location for speed.\n  startLoc: WebGLUniformLocation;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n\n    const dtype = getCoordsDataType(this.rank);\n    const coords = getChannels('coords', this.rank);\n    const sourceLoc = getChannels('sourceLoc', this.rank);\n\n    const innerDims =\n        this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;\n    const getChannel =\n        `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;\n    const upperRow = `\n      result.x = ${getChannel};\n      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n        ++${sourceLoc[this.rank - 1]};\n        result.y = ${getChannel};\n        --${sourceLoc[this.rank - 1]};\n      }\n    `;\n    const lowerRow = this.rank === 1 ? '' : `\n      --${coords[this.rank - 1]};\n      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {\n        ++${sourceLoc[this.rank - 2]};\n        result.z = ${getChannel};\n        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n          ++${sourceLoc[this.rank - 1]};\n          result.w = ${getChannel};\n        }\n      }\n    `;\n\n    const sourceLocSetup = this.rank <= 4 ?\n        `sourceLoc = coords +\n            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :\n        destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)\n            .join('\\n');\n    this.userCode = `\n      uniform int start[${this.rank}];\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        ${dtype} sourceLoc;\n        ${sourceLocSetup}\n        vec4 result = vec4(0.);\n        ${upperRow}\n        ${lowerRow}\n        setOutput(result);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(start: number[]) {\n    if (start.length !== this.rank) {\n      throw Error(\n          `The rank (${this.rank}) of the program must match the ` +\n          `length of start (${start.length})`);\n    }\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.startLoc == null) {\n        this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n        if (this.startLoc == null) {\n          // This means the compiler has optimized and realized it doesn't need\n          // the uniform.\n          return;\n        }\n      }\n      gpgpu.gl.uniform1iv(this.startLoc, start);\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class StridedSliceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      begin: number[], strides: number[], size: number[]) {\n    this.outputShape = size;\n    const rank = size.length;\n    const inputDtype = getCoordsDataType(size.length);\n    const dtype = getCoordsDataType(size.length);\n\n    let newCoords = '';\n    if (rank === 1) {\n      newCoords = 'coords * strides + begin';\n    } else {\n      let outputAxis = 0;\n      newCoords =\n          size.map((_, i) => {\n                outputAxis++;\n                return size.length === 1 ?\n                    `coords * strides[${i}] + begin[${i}]` :\n                    `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n              })\n              .join(',');\n    }\n\n    this.userCode = `\n      ${inputDtype} begin = ${inputDtype}(${begin});\n      ${inputDtype} strides = ${inputDtype}(${strides});\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        setOutput(getX(${newCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {PhysicalTextureType, TextureUsage} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private freeTextures: {[shape: string]: WebGLTexture[]} = {};\n  private logEnabled = false;\n  private usedTextures: {[shape: string]: WebGLTexture[]} = {};\n\n  constructor(private gpgpu: GPGPUContext) {}\n\n  acquireTexture(\n      shapeRC: [number, number], usage: TextureUsage,\n      isPacked: boolean): WebGLTexture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n    this.numUsedTextures++;\n    this.log();\n\n    let newTexture: WebGLTexture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n\n    } else if (\n        physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: WebGLTexture, shape: [number, number],\n      logicalTexType: TextureUsage, isPacked: boolean): void {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType =\n        getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    this.freeTextures[shapeKey].push(texture);\n    this.numFreeTextures++;\n    this.numUsedTextures--;\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n    if (texIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex);\n      });\n    }\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked: boolean):\n    PhysicalTextureType {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(\n    logicalTexType: TextureUsage, isPacked: boolean): PhysicalTextureType {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (\n      logicalTexType === TextureUsage.DOWNLOAD ||\n      logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number], physicalTexType: PhysicalTextureType,\n    isPacked: boolean): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TileProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], reps: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[i] * reps[i];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\nfunction getSourceCoords(aShape: number[]): string {\n  const rank = aShape.length;\n  if (rank > 5) {\n    throw Error(`Tile for rank ${rank} is not yet supported`);\n  }\n  if (rank === 1) {\n    return `imod(resRC, ${aShape[0]})`;\n  }\n\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class UnaryOpProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n\nconst CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;\n\nexport const LINEAR = `return x;`;\n\nexport const ABS = `return abs(x);`;\n\nexport const RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\n\nexport const RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\n\nexport const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\n\nexport const SELU = `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${backend_util.SELU_SCALEALPHA};\n  float scale = ${backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;\n\nexport function STEP(alpha = 0.0) {\n  return CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${alpha});\n  `;\n}\n\nexport const NEG = `return -x;`;\n\nexport const CEIL = `return ceil(x);`;\n\nexport const FLOOR = `return floor(x);`;\n\nexport const SIGN = `\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;\n\nexport const IS_NAN = `return float(isnan(x));`;\n\nexport const IS_INF = `return float(isinf(x));`;\n\nexport const IS_FINITE = `return float(!isnan(x) && !isinf(x));`;\n\nexport const ROUND = `\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;\n\nexport const EXP = `return exp(x);`;\n\nexport const EXPM1 = `return exp(x) - 1.0;`;\n\nexport const LOG = `if (x < 0.0) return NAN;\n  return log(x);`;\n\nexport const LOG1P = `return log(1.0 + x);`;\n\nexport const SQRT = `return sqrt(x);`;\n\nexport const RSQRT = `return inversesqrt(x);`;\n\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n\n/**\n * mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n *\n * epsilon is the difference between 1.0 and the next representable\n * float. For a single precision 32 bit float this should be 2^-23, see:\n * https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\n *\n * too_large = (x > -threshold) is value above which exp(x) may overflow\n * but softplus(x) == x is within machine epsilon\n *\n * too_small = (x < threshold) is value below which exp(x) may underflow,\n * but softplus(x) == exp(x) is within machine epsilon.\n */\nexport const SOFTPLUS = `\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;\n\nexport const SIN = CHECK_NAN_SNIPPET + `\n  return sin(x);\n`;\n\nexport const COS = CHECK_NAN_SNIPPET + `\n  return cos(x);\n`;\n\nexport const TAN = `return tan(x);`;\n\nexport const ASIN = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;\n\nexport const ACOS = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;\n\nexport const ATAN = CHECK_NAN_SNIPPET + `\n  return atan(x);\n`;\n\nexport const SINH = `\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\n\nexport const COSH = `\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\n\nexport const TANH = `\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;\n\nexport const ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;\n\nexport const ACOSH = CHECK_NAN_SNIPPET + `\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));`;\n\nexport const ATANH = CHECK_NAN_SNIPPET + `\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;\n\nexport const ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${backend_util.ERF_P};\n  float a1 = ${backend_util.ERF_A1};\n  float a2 = ${backend_util.ERF_A2};\n  float a3 = ${backend_util.ERF_A3};\n  float a4 = ${backend_util.ERF_A4};\n  float a5 = ${backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;\n\nexport const SQUARE = `return x * x;`;\n\nexport const RECIPROCAL = `return 1.0 / x;`;\n\nexport const LOGICAL_NOT = `return float(!(x >= 1.0));`;\n\nexport const TO_INT = `return float(int(x));`;\n\nexport const CLONE = 'return x;';\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport const LINEAR = `return x;`;\n\nexport const LOG = `\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n`;\n\nexport const RELU = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const RELU6 = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const ELU = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\n\nexport class UnaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels, getSourceCoords} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class UnpackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = false;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(outputShape: number[]) {\n    this.outputShape = outputShape;\n    const rank = outputShape.length;\n\n    const channels = getChannels('rc', rank);\n    const dtype = getCoordsDataType(rank);\n    const sourceCoords = getSourceCoords(rank, channels);\n    const innerDims = channels.slice(-2);\n    const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n\n    this.userCode = `\n      void main() {\n        ${dtype} rc = getOutputCoords();\n        vec4 packedInput = getA(${sourceCoords});\n\n        setOutput(getChannel(packedInput, ${coords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import webgl flags.\nimport './flags_webgl';\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {complex, DataId, div, engine, env, imag, max, MemoryInfo, range, real, RecursiveArray, scalar, softmax, tensor, tidy, TimingInfo, transpose} from '@tensorflow/tfjs-core';\nimport {backend_util, buffer, kernel_impls, slice_util, util} from '@tensorflow/tfjs-core';\nimport {DataStorage, DataType, KernelBackend, NumericDataType, Rank, Scalar, ShapeMap, Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D, Tensor5D, TensorInfo, TypedArray, upcastType} from '@tensorflow/tfjs-core';\n\nconst {segment_util} = backend_util;\nconst split = kernel_impls.split;\nconst tile = kernel_impls.tile;\nconst topkImpl = kernel_impls.topkImpl;\nconst whereImpl = kernel_impls.whereImpl;\n\nimport {AddNProgram} from './addn_gpu';\nimport {AddNPackedProgram} from './addn_packed_gpu';\nimport {ArgMinMaxProgram} from './argminmax_gpu';\nimport {ArgMinMaxPackedProgram} from './argminmax_packed_gpu';\nimport {AvgPool2DBackpropProgram, AvgPool3DBackpropProgram} from './avg_pool_backprop_gpu';\nimport {BatchNormProgram} from './batchnorm_gpu';\nimport {BatchNormPackedProgram} from './batchnorm_packed_gpu';\nimport * as binaryop_complex_gpu from './binaryop_complex_gpu';\nimport {BinaryOpComplexProgram} from './binaryop_complex_gpu';\nimport * as binaryop_gpu from './binaryop_gpu';\nimport {BinaryOpProgram} from './binaryop_gpu';\nimport * as binaryop_packed_gpu from './binaryop_packed_gpu';\nimport {BinaryOpPackedProgram} from './binaryop_packed_gpu';\nimport {getWebGLContext} from './canvas_util';\nimport {ClipProgram} from './clip_gpu';\nimport {ClipPackedProgram} from './clip_packed_gpu';\nimport {ComplexAbsProgram} from './complex_abs_gpu';\nimport {ConcatProgram} from './concat_gpu';\nimport {ConcatPackedProgram} from './concat_packed_gpu';\nimport {Conv2DDerFilterProgram, Conv2DDerInputProgram, Conv3DDerFilterProgram, Conv3DDerInputProgram} from './conv_backprop_gpu';\nimport {DepthwiseConv2DDerFilterProgram, DepthwiseConv2DDerInputProgram} from './conv_backprop_gpu_depthwise';\nimport {Conv2DProgram, Conv3DProgram} from './conv_gpu';\nimport {DepthwiseConv2DProgram} from './conv_gpu_depthwise';\nimport {DepthwiseConvPacked2DProgram} from './conv_packed_gpu_depthwise';\nimport {CropAndResizeProgram} from './crop_and_resize_gpu';\nimport {CumSumProgram} from './cumsum_gpu';\nimport {DecodeMatrixProgram} from './decode_matrix_gpu';\nimport {DecodeMatrixPackedProgram} from './decode_matrix_packed_gpu';\nimport {DepthToSpaceProgram} from './depth_to_space_gpu';\nimport {DiagProgram} from './diag_gpu';\nimport {EncodeFloatProgram} from './encode_float_gpu';\nimport {EncodeFloatPackedProgram} from './encode_float_packed_gpu';\nimport {EncodeMatrixProgram} from './encode_matrix_gpu';\nimport {EncodeMatrixPackedProgram} from './encode_matrix_packed_gpu';\nimport * as fft_gpu from './fft_gpu';\nimport {FFTProgram} from './fft_gpu';\nimport {FillProgram} from './fill_gpu';\nimport {GatherProgram} from './gather_gpu';\nimport {GatherNDProgram} from './gather_nd_gpu';\nimport {GPGPUContext} from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport {GPGPUBinary, GPGPUProgram, TensorData} from './gpgpu_math';\nimport {Im2ColPackedProgram} from './im2col_packed_gpu';\nimport {LRNProgram} from './lrn_gpu';\nimport {LRNGradProgram} from './lrn_grad_gpu';\nimport {LRNPackedProgram} from './lrn_packed_gpu';\nimport {MaxPool2DBackpropProgram, MaxPool3DBackpropProgram} from './max_pool_backprop_gpu';\nimport {MatMulPackedProgram} from './mulmat_packed_gpu';\nimport {MultinomialProgram} from './multinomial_gpu';\nimport {OneHotProgram} from './onehot_gpu';\nimport {PackProgram} from './pack_gpu';\nimport {PadProgram} from './pad_gpu';\nimport {PadPackedProgram} from './pad_packed_gpu';\nimport {Pool2DProgram, Pool3DProgram} from './pool_gpu';\nimport {ReduceProgram} from './reduce_gpu';\nimport {ReshapePackedProgram} from './reshape_packed_gpu';\nimport {ResizeBilinearBackpropProgram} from './resize_bilinear_backprop_gpu';\nimport {ResizeBilinearProgram} from './resize_bilinear_gpu';\nimport {ResizeBilinearPackedProgram} from './resize_bilinear_packed_gpu';\nimport {ResizeNearestNeigborBackpropProgram} from './resize_nearest_neighbor_backprop_gpu';\nimport {ResizeNearestNeighborProgram} from './resize_nearest_neighbor_gpu';\nimport {ReverseProgram} from './reverse_gpu';\nimport {ReversePackedProgram} from './reverse_packed_gpu';\nimport {ScatterProgram} from './scatter_gpu';\nimport {SegmentOpProgram} from './segment_gpu';\nimport {SelectProgram} from './select_gpu';\nimport {SliceProgram} from './slice_gpu';\nimport {SlicePackedProgram} from './slice_packed_gpu';\nimport {StridedSliceProgram} from './strided_slice_gpu';\nimport * as tex_util from './tex_util';\nimport {TextureData, TextureUsage} from './tex_util';\nimport {TextureManager} from './texture_manager';\nimport {TileProgram} from './tile_gpu';\nimport * as unary_op from './unaryop_gpu';\nimport {UnaryOpProgram} from './unaryop_gpu';\nimport * as unary_packed_op from './unaryop_packed_gpu';\nimport {UnaryOpPackedProgram} from './unaryop_packed_gpu';\nimport {UnpackProgram} from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nimport {BackendValues} from '@tensorflow/tfjs-core';\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\ntype KernelInfo = {\n  name: string; query: Promise<number>;\n};\n\nexport type TimerNode = RecursiveArray<KernelInfo>|KernelInfo;\nexport interface CPUTimerQuery {\n  startMs: number;\n  endMs?: number;\n}\n\nexport interface WebGLMemoryInfo extends MemoryInfo {\n  numBytesInGPU: number;\n  unreliable: boolean;\n}\n\nexport interface WebGLTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\nconst binaryCaches: {[webGLVersion: string]: {[key: string]: GPGPUBinary}} = {};\n\nexport function getBinaryCache(webGLVersion: number) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n\nfunction mapActivationToShaderProgram(\n    activation: backend_util.Activation, packed = false): string {\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return binaryop_packed_gpu.PRELU;\n    }\n    return binaryop_gpu.PRELU;\n  }\n  throw new Error(`Activation ${\n      activation} has not been implemented for the WebGL backend.`);\n}\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD = 128;\n\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning(): number {\n  if (env().global.screen == null) {\n    return 1024;  // 1 GB.\n  }\n  return (env().global.screen.height * env().global.screen.width *\n          window.devicePixelRatio) *\n      BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n\n// Empirically determined minimal shared dimension in matmul before we forward\n// to a.mul(b).sum() in order to take advantage of GPU parallelism. See\n// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.\nexport const MATMUL_SHARED_DIM_THRESHOLD = 1000;\n\nexport class MathBackendWebGL extends KernelBackend {\n  texData: DataStorage<TextureData>;\n  gpgpu: GPGPUContext;\n\n  // Maps data ids that have a pending read operation, to list of subscribers.\n  private pendingRead = new WeakMap<DataId, Array<(arr: TypedArray) => void>>();\n  // List of data ids that are scheduled for disposal, but are waiting on a\n  // pending read operation.\n  private pendingDisposal = new WeakSet<DataId>();\n  // Used to count the number of 'shallow' sliced tensors that point to the\n  // same data id.\n  private dataRefCount = new WeakMap<DataId, number>();\n  private numBytesInGPU = 0;\n\n  private canvas: HTMLCanvasElement|OffscreenCanvas;\n\n  private programTimersStack: TimerNode[];\n  private activeTimers: TimerNode[];\n  // Accumulated time spent (including blocking) in uploading data to webgl.\n  private uploadWaitMs = 0;\n  // Accumulated time spent (including blocking in downloading data from webgl.\n  private downloadWaitMs = 0;\n  private cpuBackend: KernelBackend;\n\n  // Number of bits of precision of this backend.\n  private floatPrecisionValue: 32|16;\n\n  private textureManager: TextureManager;\n  private binaryCache: {[key: string]: GPGPUBinary};\n  private gpgpuCreatedLocally: boolean;\n  private numMBBeforeWarning: number;\n  private warnedAboutMemory = false;\n\n  constructor(gpgpu?: GPGPUContext) {\n    super();\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    if (gpgpu == null) {\n      const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      this.gpgpu = new GPGPUContext(gl);\n      this.canvas = gl.canvas;\n      this.gpgpuCreatedLocally = true;\n    } else {\n      this.gpgpu = gpgpu;\n      this.binaryCache = {};\n      this.gpgpuCreatedLocally = false;\n      this.canvas = gpgpu.gl.canvas;\n    }\n    this.textureManager = new TextureManager(this.gpgpu);\n    this.numMBBeforeWarning = numMBBeforeWarning();\n\n    this.texData = new DataStorage(this, engine());\n  }\n\n  numDataIds() {\n    return this.texData.numDataIds() +\n        (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) -\n        this.pendingDeletes;\n  }\n\n  write(values: BackendValues, shape: number[], dtype: DataType): DataId {\n    if (env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {};\n    this.texData.set(\n        dataId, {shape, dtype, values, usage: TextureUsage.UPLOAD});\n    return dataId;\n  }\n\n  move(dataId: DataId, values: BackendValues, shape: number[], dtype: DataType):\n      void {\n    if (env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    this.texData.set(\n        dataId, {shape, dtype, values, usage: TextureUsage.UPLOAD});\n  }\n\n  readSync(dataId: DataId): BackendValues {\n    const texData = this.texData.get(dataId);\n    const {values, dtype, complexTensors, slice, shape, isPacked} = texData;\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.readSync(res.dataId);\n      this.disposeData(res.dataId);\n      return data;\n    }\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n    if (dtype === 'string') {\n      return values;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let result: Float32Array;\n    if (dtype === 'complex64') {\n      const realValues = complexTensors.real.dataSync() as Float32Array;\n      const imagValues = complexTensors.imag.dataSync() as Float32Array;\n      result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    } else {\n      result = this.getValuesFromTexture(dataId);\n    }\n\n    if (shouldTimeProgram) {\n      this.downloadWaitMs += util.now() - start;\n    }\n    return this.convertAndCacheOnCPU(dataId, result);\n  }\n\n  async read(dataId: DataId): Promise<BackendValues> {\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<TypedArray>(resolve => subscribers.push(resolve));\n    }\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, complexTensors, isPacked} = texData;\n\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.read(res.dataId);\n      this.disposeData(res.dataId);\n      return data;\n    }\n\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n\n    if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n        env().getNumber('WEBGL_VERSION') === 2) {\n      throw new Error(\n          `tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n          `WEBGL_VERSION=2 not yet supported.`);\n    }\n\n    let buffer = null;\n    let tmpDownloadTarget: TensorInfo;\n\n    if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n      // Possibly copy the texture into a buffer before inserting a fence.\n      tmpDownloadTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n\n      buffer = this.gpgpu.createBufferFromTexture(\n          tmpData.texture, ...tex_util.getDenseTexShape(shape));\n    }\n\n    this.pendingRead.set(dataId, []);\n\n    if (dtype !== 'complex64') {\n      // Create a fence and wait for it to resolve.\n      await this.gpgpu.createAndWaitForFence();\n    }\n\n    // Download the values from the GPU.\n    let vals: Float32Array;\n    if (dtype === 'complex64') {\n      const ps = await Promise.all(\n          [complexTensors.real.data(), complexTensors.imag.data()]);\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else if (buffer == null) {\n      vals = this.getValuesFromTexture(dataId);\n    } else {\n      const size = util.sizeFromShape(shape);\n      vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n    }\n    if (tmpDownloadTarget != null) {\n      this.disposeData(tmpDownloadTarget.dataId);\n    }\n    const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n\n    const subscribers = this.pendingRead.get(dataId);\n    this.pendingRead.delete(dataId);\n\n    // Notify all pending reads.\n    subscribers.forEach(resolve => resolve(dTypeVals));\n    if (this.pendingDisposal.has(dataId)) {\n      this.pendingDisposal.delete(dataId);\n      this.disposeData(dataId);\n      this.pendingDeletes--;\n    }\n    return dTypeVals;\n  }\n\n  private checkNumericalProblems(values: BackendValues): void {\n    if (values == null) {\n      return;\n    }\n    for (let i = 0; i < values.length; i++) {\n      const num = values[i] as number;\n      if (!webgl_util.canBeRepresented(num)) {\n        if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n          throw Error(\n              `The value ${num} cannot be represented with your ` +\n              `current settings. Consider enabling float32 rendering: ` +\n              `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n        }\n        throw Error(`The value ${num} cannot be represented on this device.`);\n      }\n    }\n  }\n\n  private getValuesFromTexture(dataId: DataId): Float32Array {\n    const {shape, dtype, isPacked} = this.texData.get(dataId);\n    const size = util.sizeFromShape(shape);\n    if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n      const tmpTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpTarget.dataId);\n      const vals = this.gpgpu\n                       .downloadMatrixFromPackedTexture(\n                           tmpData.texture, ...tex_util.getDenseTexShape(shape))\n                       .subarray(0, size);\n\n      this.disposeData(tmpTarget.dataId);\n\n      return vals;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK') && isPacked === true;\n    const outputShape =\n        shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n    const program = shouldUsePackedProgram ?\n        new EncodeFloatPackedProgram(outputShape as [number, number, number]) :\n        new EncodeFloatProgram(outputShape);\n    const output = this.runWebGLProgram(\n        program, [{shape: outputShape, dtype, dataId}], 'float32');\n    const tmpData = this.texData.get(output.dataId);\n    const vals =\n        this.gpgpu\n            .downloadByteEncodedFloatMatrixFromOutputTexture(\n                tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])\n            .subarray(0, size);\n    this.disposeData(output.dataId);\n\n    return vals;\n  }\n\n  async time(f: () => void): Promise<WebGLTimingInfo> {\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    // needing to split these up because util.flatten only accepts certain types\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n\n    const res: WebGLTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null  // will be filled by the engine\n    };\n\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n\n      res['kernelMs'] = util.sum(kernelMs);\n      res['getExtraProfileInfo'] = () =>\n          kernelMs.map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n              .map(d => `${d.name}: ${d.ms}`)\n              .join(', ');\n    } else {\n      res['kernelMs'] = {\n        error: 'WebGL query timers are not supported in this environment.'\n      };\n    }\n\n    this.uploadWaitMs = 0;\n    this.downloadWaitMs = 0;\n    return res;\n  }\n  memory(): WebGLMemoryInfo {\n    return {unreliable: false, numBytesInGPU: this.numBytesInGPU} as\n        WebGLMemoryInfo;\n  }\n\n  private startTimer(): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.beginQuery();\n    }\n    return {startMs: util.now(), endMs: null};\n  }\n\n  private endTimer(query: WebGLQuery|CPUTimerQuery): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      this.gpgpu.endQuery();\n      return query;\n    }\n    (query as CPUTimerQuery).endMs = util.now();\n    return query;\n  }\n\n  private async getQueryTime(query: WebGLQuery|CPUTimerQuery): Promise<number> {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.waitForQueryAndGetTime(query as WebGLQuery);\n    }\n    const timerQuery = query as CPUTimerQuery;\n    return timerQuery.endMs - timerQuery.startMs;\n  }\n\n  private pendingDeletes = 0;\n\n  disposeData(dataId: DataId): void {\n    if (this.pendingDisposal.has(dataId)) {\n      return;\n    }\n    if (this.pendingRead.has(dataId)) {\n      this.pendingDisposal.add(dataId);\n      this.pendingDeletes++;\n      return;\n    }\n    // No-op if already disposed.\n    if (!this.texData.has(dataId)) {\n      return;\n    }\n\n    this.releaseGPUData(dataId);\n    const {complexTensors} = this.texData.get(dataId);\n    if (complexTensors != null) {\n      complexTensors.real.dispose();\n      complexTensors.imag.dispose();\n    }\n    this.texData.delete(dataId);\n  }\n\n  private releaseGPUData(dataId: DataId): void {\n    const {texture, dtype, texShape, usage, isPacked, slice} =\n        this.texData.get(dataId);\n    const key = slice && slice.origDataId || dataId;\n    const refCount = this.dataRefCount.get(key);\n    if (refCount > 1) {\n      this.dataRefCount.set(key, refCount - 1);\n    } else {\n      this.dataRefCount.delete(key);\n      if (texture != null) {\n        this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n        this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n      }\n    }\n    const texData = this.texData.get(dataId);\n    texData.texture = null;\n    texData.texShape = null;\n    texData.isPacked = false;\n    texData.slice = null;\n  }\n\n  getTexture(dataId: DataId): WebGLTexture {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId).texture;\n  }\n\n  /**\n   * Returns internal information for the specific data bucket. Used in unit\n   * tests.\n   */\n  getDataInfo(dataId: DataId): TextureData {\n    return this.texData.get(dataId);\n  }\n\n  private getCPUBackend(): KernelBackend|null {\n    if (!env().getBool('WEBGL_CPU_FORWARD')) {\n      return null;\n    }\n\n    if (this.cpuBackend == null) {\n      this.cpuBackend = engine().findBackend('cpu');\n    }\n\n    return this.cpuBackend;\n  }\n\n  /*\n  Tests whether all the inputs to an op are small and on the CPU. This heuristic\n  determines when it would be faster to execute a kernel on the CPU. WebGL\n  kernels opt into running this check and forwarding when appropriate.\n  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n  sustainable strategy for optimizing backend execution of ops.\n   */\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    return this.getCPUBackend() != null &&\n        inputs.every(\n            input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  getGPGPUContext(): GPGPUContext {\n    return this.gpgpu;\n  }\n\n  complex<T extends Tensor>(real: T, imag: T): T {\n    const result = this.makeOutput(real.shape, 'complex64');\n    const resultData = this.texData.get(result.dataId);\n    // The backend owns the reference to the underlying real and imaginary\n    // clones. These will explicitly get disposed when the complex tensor is\n    // disposed.\n    resultData.complexTensors = {\n      real: engine().keep(real.clone()),\n      imag: engine().keep(imag.clone())\n    };\n\n    return result as T;\n  }\n  real<T extends Tensor>(input: T): T {\n    const resultData = this.texData.get(input.dataId);\n    return resultData.complexTensors.real.clone() as T;\n  }\n  imag<T extends Tensor>(input: T): T {\n    const resultData = this.texData.get(input.dataId);\n    return resultData.complexTensors.imag.clone() as T;\n  }\n\n  slice<T extends Tensor>(x: T, begin: number[], size: number[]): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.slice(x, begin, size);\n    }\n    // Short-circuit computation if the slice is zero-sized.\n    if (util.sizeFromShape(size) === 0) {\n      return tensor([], size, x.dtype) as T;\n    }\n    const {isPacked} = this.texData.get(x.dataId);\n    const isContinous = slice_util.isSliceContinous(x.shape, begin, size);\n    if (isPacked || !isContinous) {\n      const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n          new SlicePackedProgram(size) :\n          new SliceProgram(size);\n      const customSetup = program.getCustomSetupFunc(begin);\n      return this.compileAndRun(program, [x], null, customSetup);\n    }\n    this.uploadToGPU(x.dataId);\n    return this.shallowSlice(x, begin, size) as T;\n  }\n\n  private shallowSlice(x: Tensor, begin: number[], size: number[]): Tensor {\n    const xTexData = this.texData.get(x.dataId);\n    const t = this.makeOutput(size, x.dtype);\n    const newTexData = this.texData.get(t.dataId);\n    // Copy texture data from the original tensor.\n    Object.assign(newTexData, xTexData);\n    newTexData.shape = size;\n    newTexData.dtype = x.dtype;\n    let flatOffset = slice_util.computeFlatOffset(begin, x.strides);\n    if (xTexData.slice) {\n      // We are slicing an already sliced tensor, so we have to accumulate\n      // the offset.\n      flatOffset += xTexData.slice.flatOffset;\n    }\n    newTexData.slice = {\n      flatOffset,\n      // Point to the original dataId, which is used to do ref counting.\n      origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n    };\n\n    // Increase the ref count for that data bucket.\n    const refCount = this.dataRefCount.get(newTexData.slice.origDataId) || 1;\n    this.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n\n    return t;\n  }\n\n  stridedSlice<T extends Tensor>(\n      x: T, begin: number[], end: number[], strides: number[]): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.stridedSlice(x, begin, end, strides);\n    }\n\n    const outShape = slice_util.computeOutShape(begin, end, strides);\n\n    if (outShape.some(axis => axis === 0)) {\n      return tensor([], outShape) as T;\n    }\n\n    const program = new StridedSliceProgram(begin, strides, outShape);\n    return this.compileAndRun(program, [x]);\n  }\n\n  reverse<T extends Tensor>(x: T, axis: number[]): T {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new ReversePackedProgram(x.shape, axis) :\n        new ReverseProgram(x.shape, axis);\n    return this.compileAndRun(program, [x]);\n  }\n\n  concat(tensors: Tensor[], axis: number): Tensor {\n    if (tensors[0].dtype === 'complex64') {\n      const reals = tensors.map((t) => real(t));\n      const imags = tensors.map((t) => imag(t));\n      return complex(this.concat(reals, axis), this.concat(imags, axis));\n    }\n    if (this.shouldExecuteOnCPU(tensors)) {\n      return this.cpuBackend.concat(tensors, axis);\n    }\n\n    if (tensors.length === 1) {\n      return tensors[0];\n    }\n    if (tensors.length > env().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n      const midIndex = Math.floor(tensors.length / 2);\n      const leftSide = this.concat(tensors.slice(0, midIndex), axis);\n      const rightSide = this.concat(tensors.slice(midIndex), axis);\n      return this.concat([leftSide, rightSide], axis);\n    }\n    if (env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') && tensors[0].rank > 1) {\n      const program = new ConcatPackedProgram(tensors.map(t => t.shape), axis);\n      return this.compileAndRun(program, tensors);\n    }\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    const outShape =\n        backend_util.computeOutShape(tensors.map(t => t.shape), axis);\n    const tensors2D =\n        tensors.map(t => t.as2D(-1, util.sizeFromShape(t.shape.slice(axis))));\n    const program = new ConcatProgram(tensors2D.map(t => t.shape));\n    const res: Tensor = this.compileAndRun(program, tensors2D);\n    return res.reshape(outShape);\n  }\n\n  neg<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.neg(x);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.NEG, x.dtype) as T;\n    }\n    const program = new UnaryOpProgram(x.shape, unary_op.NEG);\n    return this.compileAndRun(program, [x]);\n  }\n\n  batchMatMul(\n      a: Tensor3D, b: Tensor3D, transposeA: boolean,\n      transposeB: boolean): Tensor3D {\n    const outerShapeA = transposeA ? a.shape[2] : a.shape[1];\n    const outerShapeB = transposeB ? b.shape[1] : b.shape[2];\n    const sharedDim = transposeA ? a.shape[1] : a.shape[2];\n    const [batch, , ] = a.shape;\n\n    // Since the matrices are vectors, it is faster to call mul().sum()\n    // because sum() is O(sqrt(N)) due to divide-and-conquer.\n    if ((outerShapeA === 1 || outerShapeB === 1) &&\n        sharedDim > MATMUL_SHARED_DIM_THRESHOLD) {\n      if (transposeA) {\n        a = transpose(a, [0, 2, 1]);\n      }\n      if (transposeB) {\n        b = transpose(b, [0, 2, 1]);\n      }\n\n      const a3D = outerShapeB === 1 ? a : a.as3D(batch, sharedDim, 1);\n      const axis = outerShapeB === 1 ? 2 : 1;\n      const b3D = outerShapeB === 1 ? b.as3D(batch, 1, sharedDim) : b;\n      return this.multiply(a3D, b3D).sum(axis, true /* keepDims */);\n    }\n\n    const dtype = upcastType(a.dtype, b.dtype);\n\n    const program = new MatMulPackedProgram(\n        a.shape, [batch, outerShapeA, outerShapeB], transposeA, transposeB);\n    return this.compileAndRun<Tensor3D>(program, [a, b], dtype);\n  }\n\n  fusedBatchMatMul(\n      {a, b, transposeA, transposeB, bias, activation, preluActivationWeights}:\n          backend_util.FusedBatchMatMulConfig): Tensor3D {\n    const outerShapeA = transposeA ? a.shape[2] : a.shape[1];\n    const outerShapeB = transposeB ? b.shape[1] : b.shape[2];\n    const [batch, , ] = a.shape;\n\n    const dtype = upcastType(a.dtype, b.dtype);\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, true) : null;\n    const program = new MatMulPackedProgram(\n        a.shape, [batch, outerShapeA, outerShapeB], transposeA, transposeB,\n        hasBias, fusedActivation, hasPreluActivationWeights);\n    const inputs: TensorInfo[] = [a, b];\n    if (bias) {\n      inputs.push(bias);\n    }\n    if (preluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    return this.compileAndRun<Tensor3D>(program, inputs, dtype);\n  }\n\n  multiply(a: Tensor, b: Tensor): Tensor {\n    if (a.dtype === 'complex64') {\n      const aData = this.texData.get(a.dataId);\n      const bData = this.texData.get(b.dataId);\n\n      const realProgram = new BinaryOpComplexProgram(\n          binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n      const imagProgram = new BinaryOpComplexProgram(\n          binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n\n      const inputs = [\n        this.makeComplexComponentTensorInfo(a, aData.complexTensors.real),\n        this.makeComplexComponentTensorInfo(a, aData.complexTensors.imag),\n        this.makeComplexComponentTensorInfo(b, bData.complexTensors.real),\n        this.makeComplexComponentTensorInfo(b, bData.complexTensors.imag)\n      ];\n      const real = this.compileAndRun<Tensor>(realProgram, inputs);\n      const imag = this.compileAndRun<Tensor>(imagProgram, inputs);\n\n      const complex = this.complex(real, imag);\n      real.dispose();\n      imag.dispose();\n      return complex;\n    }\n\n    if (this.shouldExecuteOnCPU([a, b])) {\n      return this.cpuBackend.multiply(a, b);\n    }\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_gpu.MUL, a.dtype);\n    }\n    const program = new BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], a.dtype);\n  }\n\n  batchNorm(\n      x: Tensor4D, mean: Tensor4D|Tensor1D, variance: Tensor4D|Tensor1D,\n      offset?: Tensor4D|Tensor1D, scale?: Tensor4D|Tensor1D,\n      varianceEpsilon?: number): Tensor4D {\n    const inputs = [x, mean, variance];\n\n    let offsetShape = null;\n    if (offset != null) {\n      offsetShape = offset.shape;\n      inputs.push(offset);\n    }\n\n    let scaleShape = null;\n    if (scale != null) {\n      scaleShape = scale.shape;\n      inputs.push(scale);\n    }\n\n    if (env().getBool('WEBGL_PACK_NORMALIZATION')) {\n      const batchNormPackedProgram = new BatchNormPackedProgram(\n          x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n          varianceEpsilon);\n      return this.compileAndRun<Tensor4D>(batchNormPackedProgram, inputs);\n    }\n\n    const batchNormProgram = new BatchNormProgram(\n        x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n        varianceEpsilon);\n    return this.compileAndRun(batchNormProgram, inputs);\n  }\n\n  localResponseNormalization4D(\n      x: Tensor4D, radius: number, bias: number, alpha: number,\n      beta: number): Tensor4D {\n    const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n        new LRNPackedProgram(x.shape, radius, bias, alpha, beta) :\n        new LRNProgram(x.shape, radius, bias, alpha, beta);\n    return this.compileAndRun(program, [x]);\n  }\n\n  LRNGrad(\n      dy: Tensor4D, inputImage: Tensor4D, outputImage: Tensor4D,\n      depthRadius: number, bias: number, alpha: number,\n      beta: number): Tensor4D {\n    const program =\n        new LRNGradProgram(inputImage.shape, depthRadius, bias, alpha, beta);\n    return this.compileAndRun(program, [inputImage, outputImage, dy]);\n  }\n\n  tile<T extends Tensor>(x: T, reps: number[]): T {\n    if (x.dtype === 'string') {\n      const data = this.readSync(x.dataId) as Uint8Array[];\n      const decodedData = data.map(d => util.decodeString(d));\n      const buf = buffer(x.shape, x.dtype, decodedData);\n      return tile(buf, reps) as T;\n    }\n    const program = new TileProgram(x.shape, reps);\n    return this.compileAndRun(program, [x]);\n  }\n\n  pad<T extends Tensor>(\n      x: T, paddings: Array<[number, number]>, constantValue: number): T {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new PadPackedProgram(x.shape, paddings, constantValue) :\n        new PadProgram(x.shape, paddings, constantValue);\n    return this.compileAndRun(program, [x]);\n  }\n\n  gather<T extends Tensor>(x: T, indices: Tensor1D, axis: number): T {\n    if (this.shouldExecuteOnCPU([x, indices])) {\n      return this.cpuBackend.gather(x, indices, axis);\n    }\n    const program = new GatherProgram(x.shape, indices.size, axis);\n    return this.compileAndRun(program, [x, indices]);\n  }\n\n  batchToSpaceND<T extends Tensor>(\n      x: T, blockShape: number[], crops: number[][]): T {\n    util.assert(\n        x.rank <= 4,\n        () => 'batchToSpaceND for rank > 4 with a WebGL backend not ' +\n            'implemented yet');\n    const prod = blockShape.reduce((a, b) => a * b);\n\n    const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n    const permuted =\n        backend_util.getPermuted(reshaped.length, blockShape.length);\n    const reshapedPermuted =\n        backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n    const sliceBeginCoords =\n        backend_util.getSliceBeginCoords(crops, blockShape.length);\n    const sliceSize =\n        backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n\n    return transpose(x.reshape(reshaped), permuted)\n               .reshape(reshapedPermuted)\n               .slice(sliceBeginCoords, sliceSize) as T;\n  }\n\n  spaceToBatchND<T extends Tensor>(\n      x: T, blockShape: number[], paddings: Array<[number, number]>): T {\n    util.assert(\n        x.rank <= 4,\n        () => 'spaceToBatchND for rank > 4 with a WebGL backend not ' +\n            'implemented yet');\n\n    const prod = blockShape.reduce((a, b) => a * b);\n\n    const completePaddings: Array<[number, number]> = [[0, 0]];\n    completePaddings.push(...paddings);\n    for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n      completePaddings.push([0, 0]);\n    }\n\n    const paddedX = x.pad(completePaddings);\n\n    const reshapedPaddedShape =\n        backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n\n    const permutedReshapedPaddedPermutation = backend_util.getPermuted(\n        reshapedPaddedShape.length, blockShape.length, false);\n\n    const flattenShape = backend_util.getReshapedPermuted(\n        paddedX.shape, blockShape, prod, false);\n\n    return transpose(\n               paddedX.reshape(reshapedPaddedShape),\n               permutedReshapedPaddedPermutation)\n               .reshape(flattenShape) as T;\n  }\n\n  private reduce(\n      x: Tensor2D, reduceType: 'all'|'any'|'max'|'min'|'sum'|'prod',\n      dtype: DataType): Tensor2D {\n    const batchSize = x.shape[0];\n    const inSize = x.shape[1];\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const reduceInfo = {windowSize, inSize, batchSize};\n    const program = new ReduceProgram(reduceInfo, reduceType);\n    const output = this.compileAndRun<Tensor2D>(program, [x], dtype);\n    // No need to run another GPGPU program.\n    if (output.shape[1] === 1) {\n      return output;\n    }\n    return this.reduce(output, reduceType, dtype);\n  }\n\n  private argReduce(\n      x: Tensor2D, reduceType: 'max'|'min',\n      bestIndicesA: Tensor2D = null): Tensor2D {\n    let batchSize = x.shape[0];\n    let inSize = x.shape[1];\n    if (bestIndicesA != null) {\n      batchSize = bestIndicesA.shape[0];\n      inSize = bestIndicesA.shape[1];\n    }\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const reduceInfo = {windowSize, inSize, batchSize};\n    const program =\n        new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n    const inputs = [x];\n    if (bestIndicesA != null) {\n      inputs.push(bestIndicesA);\n    }\n    const output = this.compileAndRun<Tensor2D>(program, inputs, 'int32');\n    // No need to run another GPGPU program.\n    if (output.shape[1] === 1) {\n      return output;\n    }\n    return this.argReduce(x, reduceType, output);\n  }\n\n  private argReducePacked(\n      x: Tensor, reduceType: 'max'|'min', bestIndicesA: Tensor = null): Tensor {\n    const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;\n    const inSize = inShape[inShape.length - 1];\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const program = new ArgMinMaxPackedProgram(\n        inShape, windowSize, reduceType, bestIndicesA == null);\n    const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];\n    const output = this.compileAndRun<Tensor>(program, inputs, 'int32');\n    if (output.rank === x.rank) {\n      return this.argReducePacked(x, reduceType, output);\n    }\n    return output;\n  }\n\n  sum(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    const outputDType = tf.sumOutType(x.dtype);\n    return this.reduce(a2D, 'sum', outputDType).reshape(outShape);\n  }\n\n  prod(x: Tensor, axes: number[]): Tensor {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.prod(x, axes);\n    }\n\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    const outputDType = tf.sumOutType(x.dtype);\n    return this.reduce(a2D, 'prod', outputDType).reshape(outShape);\n  }\n\n  unsortedSegmentSum<T extends Tensor>(\n      x: T, segmentIds: Tensor1D, numSegments: number): Tensor {\n    let axis = 0;\n    const permutation = backend_util.getAxesPermutation([axis], x.rank);\n    let permutedX = x;\n    if (permutation != null) {\n      permutedX = transpose(x, permutation);\n      axis = backend_util.getInnerMostAxes(1, x.rank)[0];\n    }\n\n    const outShape =\n        segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n    const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n    const a2D = permutedX.as2D(-1, inSize);\n    const outputDType = tf.sumOutType(x.dtype);\n    let result =\n        this.segOpCompute(\n                a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments)\n            .reshape(outShape);\n    if (permutation != null) {\n      result =\n          transpose(result, backend_util.getUndoAxesPermutation(permutation));\n    }\n    return result;\n  }\n\n  private segOpCompute(\n      x: Tensor2D, segOpType: 'unsortedSegmentSum', segmentIds: Tensor1D,\n      dtype: DataType, numSegments: number): Tensor2D {\n    const batchSize = x.shape[0];\n    const inSize = x.shape[1];\n    const windowSize =\n        segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n    const segOpInfo = {windowSize, inSize, batchSize, numSegments};\n    const program = new SegmentOpProgram(segOpInfo, segOpType);\n    const output =\n        this.compileAndRun<Tensor2D>(program, [x, segmentIds], dtype);\n    // No need to run another GPGPU program.\n    if (output.shape[1] === numSegments) {\n      return output;\n    }\n    segmentIds = range(0, numSegments).tile([inSize / windowSize]);\n    return this.segOpCompute(output, segOpType, segmentIds, dtype, numSegments);\n  }\n\n  private argMinMaxReduce(x: Tensor, axis: number, reduceType: 'min'|'max'):\n      Tensor {\n    const axes = [axis];\n    backend_util.assertAxesAreInnerMostDims(\n        'arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes,\n        x.rank);\n    if (!env().getBool('WEBGL_PACK_REDUCE') || x.rank <= 2) {\n      const [outShape, reduceShape] =\n          backend_util.computeOutAndReduceShapes(x.shape, axes);\n      const inSize = util.sizeFromShape(reduceShape);\n      const a2D = x.as2D(-1, inSize);\n      return this.argReduce(a2D, reduceType).reshape(outShape);\n    }\n    return this.argReducePacked(x, reduceType);\n  }\n\n  argMin(x: Tensor, axis: number): Tensor {\n    return this.argMinMaxReduce(x, axis, 'min');\n  }\n\n  argMax(x: Tensor, axis: number): Tensor {\n    return this.argMinMaxReduce(x, axis, 'max');\n  }\n\n  cumsum(x: Tensor, axis: number, exclusive: boolean, reverse: boolean):\n      Tensor {\n    if (axis !== x.rank - 1) {\n      throw new Error(\n          `WebGL cumsum shader expects an inner-most axis=${x.rank - 1} ` +\n          `but got axis=${axis}`);\n    }\n    const program = new CumSumProgram(x.shape, exclusive, reverse);\n    return this.compileAndRun(program, [x]);\n  }\n\n  equal(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.EQUAL, 'bool');\n    }\n    const program = new BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  notEqual(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.NOT_EQUAL, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  less(a: Tensor, b: Tensor): Tensor {\n    if (this.shouldExecuteOnCPU([a, b])) {\n      return this.cpuBackend.less(a, b);\n    }\n\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LESS, 'bool');\n    }\n\n    const program = new BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  lessEqual(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LESS_EQUAL, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  greater(a: Tensor, b: Tensor): Tensor {\n    if (this.shouldExecuteOnCPU([a, b])) {\n      return this.cpuBackend.greater(a, b);\n    }\n\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.GREATER, 'bool');\n    }\n\n    const program = new BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  greaterEqual(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(\n          a, b, binaryop_packed_gpu.GREATER_EQUAL, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  logicalNot<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);\n    return this.compileAndRun(program, [x]);\n  }\n\n  logicalAnd(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LOGICAL_AND, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  logicalOr(a: Tensor, b: Tensor): Tensor {\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_packed_gpu.LOGICAL_OR, 'bool');\n    }\n    const program =\n        new BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b], 'bool');\n  }\n\n  select(condition: Tensor, a: Tensor, b: Tensor): Tensor {\n    const program = new SelectProgram(condition.rank, a.shape, a.rank);\n    return this.compileAndRun(\n        program, [condition, a, b], upcastType(a.dtype, b.dtype));\n  }\n\n  where(condition: Tensor): Tensor2D {\n    backend_util.warn(\n        'tf.where() in webgl locks the UI thread. ' +\n        'Call tf.whereAsync() instead');\n    const condVals = condition.dataSync();\n    return whereImpl(condition.shape, condVals);\n  }\n\n  topk<T extends Tensor>(x: T, k: number, sorted: boolean): [T, T] {\n    const xVals = x.dataSync();\n    return topkImpl(xVals, x.shape, x.dtype as NumericDataType, k, sorted);\n  }\n\n  min(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);\n  }\n\n  minimum(a: Tensor, b: Tensor): Tensor {\n    if (this.shouldExecuteOnCPU([a, b])) {\n      return this.cpuBackend.minimum(a, b);\n    }\n\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.MIN, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  }\n\n  mod(a: Tensor, b: Tensor): Tensor {\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.MOD, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  }\n\n  maximum(a: Tensor, b: Tensor): Tensor {\n    if (this.shouldExecuteOnCPU([a, b])) {\n      return this.cpuBackend.maximum(a, b);\n    }\n\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.MAX, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  }\n\n  all(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'all', a2D.dtype).reshape(outShape);\n  }\n\n  any(x: Tensor, axes: number[]): Tensor {\n    backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = x.as2D(-1, inSize);\n    return this.reduce(a2D, 'any', a2D.dtype).reshape(outShape);\n  }\n\n  floorDiv(a: Tensor, b: Tensor): Tensor {\n    const op = binaryop_gpu.INT_DIV;\n    const outputDtype = 'int32';\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(\n          a, b, binaryop_packed_gpu.INT_DIV, outputDtype);\n    }\n    const program = new BinaryOpProgram(op, a.shape, b.shape);\n    return this.compileAndRun<Tensor>(program, [a, b], outputDtype);\n  }\n\n  add(a: Tensor, b: Tensor): Tensor {\n    if (a.dtype === 'complex64' && b.dtype === 'complex64') {\n      return this.complexSeparableBinaryOp(a, b, binaryop_gpu.ADD);\n    }\n\n    if (this.shouldExecuteOnCPU([a, b])) {\n      return this.cpuBackend.add(a, b);\n    }\n\n    const dtype = upcastType(a.dtype, b.dtype);\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_gpu.ADD, dtype);\n    }\n    const program = new BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);\n    return this.compileAndRun<Tensor>(program, [a, b], dtype);\n  }\n\n  private packedUnaryOp(x: TensorInfo, op: string, dtype: DataType) {\n    const program = new UnaryOpPackedProgram(x.shape, op);\n    return this.compileAndRun<Tensor>(program, [x], dtype);\n  }\n\n  private packedBinaryOp(\n      a: TensorInfo, b: TensorInfo, op: string, dtype: DataType,\n      checkOutOfBounds = false) {\n    const program =\n        new BinaryOpPackedProgram(op, a.shape, b.shape, checkOutOfBounds);\n    return this.compileAndRun<Tensor>(program, [a, b], dtype);\n  }\n\n  /**\n   * Computes a complex binary operation that can be decomposed into a simple\n   * binary operation on both the real and imagary parts.\n   */\n  private complexSeparableBinaryOp(a: Tensor, b: Tensor, op: string): Tensor {\n    const aData = this.texData.get(a.dataId);\n    const bData = this.texData.get(b.dataId);\n\n    const [real, imag] = [\n      [aData.complexTensors.real, bData.complexTensors.real],\n      [aData.complexTensors.imag, bData.complexTensors.imag]\n    ].map(complexParts => {\n      const [aPart, bPart] = complexParts;\n\n      const aHandle = this.makeComplexComponentTensorInfo(a, aPart);\n      const bHandle = this.makeComplexComponentTensorInfo(b, bPart);\n\n      const program = new BinaryOpProgram(op, a.shape, b.shape);\n      return this.compileAndRun<Tensor>(\n          program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n    });\n\n    const complex = this.complex(real, imag);\n    real.dispose();\n    imag.dispose();\n    return complex;\n  }\n\n  // Returns a TensorInfo with the complex shape and the dataId of the\n  // underlying part. We need to do this because a reshaped complex tensor is\n  // not reflected in its parts.\n  private makeComplexComponentTensorInfo(\n      complexTensor: Tensor, complexPart: Tensor): TensorInfo {\n    return {\n      dataId: complexPart.dataId,\n      dtype: complexPart.dtype,\n      shape: complexTensor.shape\n    };\n  }\n\n  addN<T extends Tensor>(tensors: T[]): T {\n    if (tensors.length === 1) {\n      return tensors[0];\n    }\n\n    // Limit the number of uploaded textures for optimization.\n    if (tensors.length > env().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n      const midIndex = Math.floor(tensors.length / 2);\n      const leftSide = this.addN(tensors.slice(0, midIndex));\n      const rightSide = this.addN(tensors.slice(midIndex));\n      return this.addN([leftSide, rightSide]);\n    }\n\n    const dtype =\n        tensors.map(t => t.dtype).reduce((d1, d2) => upcastType(d1, d2));\n    const shapes = tensors.map(t => t.shape);\n    // We can make sure shapes are identical in op level.\n    const usePackedOp = env().getBool('WEBGL_PACK');\n    const program = usePackedOp ?\n        new AddNPackedProgram(tensors[0].shape, shapes) :\n        new AddNProgram(tensors[0].shape, shapes);\n    return this.compileAndRun<T>(program, tensors, dtype);\n  }\n\n  subtract(a: Tensor, b: Tensor): Tensor {\n    if (a.dtype === 'complex64' && b.dtype === 'complex64') {\n      return this.complexSeparableBinaryOp(a, b, binaryop_gpu.SUB);\n    }\n\n    if (this.shouldExecuteOnCPU([a, b])) {\n      return this.cpuBackend.subtract(a, b);\n    }\n    const dtype = upcastType(a.dtype, b.dtype);\n    if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n      return this.packedBinaryOp(a, b, binaryop_gpu.SUB, a.dtype);\n    }\n    const program = new BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);\n    return this.compileAndRun<Tensor>(program, [a, b], dtype);\n  }\n\n  pow<T extends Tensor>(a: T, b: Tensor): T {\n    const usePackedOp = env().getBool('WEBGL_PACK_BINARY_OPERATIONS');\n    const program = usePackedOp ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.POW, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);\n    const dtype = upcastType(a.dtype, b.dtype);\n    return this.compileAndRun<T>(program, [a, b], dtype);\n  }\n\n  ceil<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.ceil(x);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.CEIL, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.CEIL);\n    return this.compileAndRun(program, [x]);\n  }\n\n  floor<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.floor(x);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.FLOOR, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.FLOOR);\n    return this.compileAndRun(program, [x]);\n  }\n\n  sign<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SIGN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  isNaN<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.IS_NAN);\n    return this.compileAndRun(program, [x], 'bool');\n  }\n  isInf<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.IS_INF);\n    return this.compileAndRun(program, [x], 'bool');\n  }\n  isFinite<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.IS_FINITE);\n    return this.compileAndRun(program, [x], 'bool');\n  }\n\n  round<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ROUND);\n    return this.compileAndRun(program, [x]);\n  }\n\n  exp<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.exp(x);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.EXP, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.EXP);\n    return this.compileAndRun(program, [x]);\n  }\n\n  expm1<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.expm1(x);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.EXPM1, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.EXPM1);\n    return this.compileAndRun(program, [x]);\n  }\n\n  softmax<T extends Tensor>(logits: T, dim: number): T {\n    const axes = util.parseAxisParam([dim], logits.shape);\n    // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n    // modularization.\n    const maxLogit = max(logits, axes);\n    const expandedShape =\n        backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n    const a = this.subtract(logits, maxLogit.reshape(expandedShape));\n    const b = this.exp(a);\n    const sumExp = this.sum(b, axes).reshape(expandedShape);\n\n    // TODO(annxingyuan): Call divImpl rather than op as part of softmax kernel\n    // modularization.\n    return div(b, sumExp);\n  }\n\n  log<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.log(x);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_packed_op.LOG, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.LOG);\n    return this.compileAndRun(program, [x]);\n  }\n\n  log1p<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.LOG1P);\n    return this.compileAndRun(program, [x]);\n  }\n\n  sqrt<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SQRT);\n    return this.compileAndRun(program, [x]);\n  }\n\n  rsqrt<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.rsqrt(x);\n    }\n    const program = new UnaryOpProgram(x.shape, unary_op.RSQRT);\n    return this.compileAndRun(program, [x]);\n  }\n\n  reciprocal<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.RECIPROCAL);\n    return this.compileAndRun(program, [x]);\n  }\n\n  relu<T extends Tensor>(x: T): T {\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (env().getBool('WEBGL_PACK')) {\n      program = new UnaryOpPackedProgram(x.shape, unary_packed_op.RELU);\n    } else {\n      program = new UnaryOpProgram(x.shape, unary_op.RELU);\n    }\n    return this.compileAndRun(program, [x]);\n  }\n\n  relu6<T extends Tensor>(x: T): T {\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (env().getBool('WEBGL_PACK')) {\n      program = new UnaryOpPackedProgram(x.shape, unary_packed_op.RELU6);\n    } else {\n      program = new UnaryOpProgram(x.shape, unary_op.RELU6);\n    }\n    return this.compileAndRun(program, [x]);\n  }\n\n  prelu<T extends Tensor>(x: T, alpha: T): T {\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(\n            binaryop_packed_gpu.PRELU, x.shape, alpha.shape) :\n        new BinaryOpProgram(binaryop_gpu.PRELU, x.shape, alpha.shape);\n    return this.compileAndRun(program, [x, alpha]);\n  }\n\n  elu<T extends Tensor>(x: T): T {\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_packed_op.ELU, x.dtype) as T;\n    }\n    const program = new UnaryOpProgram(x.shape, unary_op.ELU);\n    return this.compileAndRun(program, [x]);\n  }\n\n  eluDer<T extends Tensor>(dy: T, y: T): T {\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(\n            binaryop_packed_gpu.ELU_DER, dy.shape, y.shape) :\n        new BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);\n    return this.compileAndRun(program, [dy, y]);\n  }\n\n  selu<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SELU);\n    return this.compileAndRun(program, [x]);\n  }\n\n  int<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.TO_INT);\n    return this.compileAndRun(program, [x], 'int32');\n  }\n\n  clip<T extends Tensor>(x: T, min: number, max: number): T {\n    let program;\n    if (env().getBool('WEBGL_PACK_CLIP')) {\n      program = new ClipPackedProgram(x.shape);\n    } else {\n      program = new ClipProgram(x.shape);\n    }\n    const customSetup = program.getCustomSetupFunc(min, max);\n    return this.compileAndRun(program, [x], null, customSetup);\n  }\n\n  abs<T extends Tensor>(x: T): T {\n    if (this.shouldExecuteOnCPU([x])) {\n      return this.cpuBackend.abs(x);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.ABS, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n    return this.compileAndRun(program, [x]);\n  }\n\n  complexAbs<T extends Tensor>(x: T): T {\n    const xData = this.texData.get(x.dataId);\n\n    const program = new ComplexAbsProgram(x.shape);\n    const inputs = [\n      this.makeComplexComponentTensorInfo(x, xData.complexTensors.real),\n      this.makeComplexComponentTensorInfo(x, xData.complexTensors.imag),\n    ];\n\n    return this.compileAndRun<Tensor>(program, inputs) as T;\n  }\n\n  sigmoid<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SIGMOID);\n    return this.compileAndRun(program, [x]);\n  }\n\n  softplus<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SOFTPLUS);\n    return this.compileAndRun(program, [x]);\n  }\n\n  sin<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SIN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  cos<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.COS);\n    return this.compileAndRun(program, [x]);\n  }\n\n  tan<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.TAN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  asin<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ASIN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  acos<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ACOS);\n    return this.compileAndRun(program, [x]);\n  }\n\n  atan<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ATAN);\n    return this.compileAndRun(program, [x]);\n  }\n\n  atan2<T extends Tensor>(a: T, b: T): T {\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(binaryop_packed_gpu.ATAN2, a.shape, b.shape) :\n        new BinaryOpProgram(binaryop_gpu.ATAN2, a.shape, b.shape);\n    return this.compileAndRun(program, [a, b]);\n  }\n\n  sinh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.SINH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  cosh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.COSH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  tanh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.TANH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  asinh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ASINH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  acosh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ACOSH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  atanh<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ATANH);\n    return this.compileAndRun(program, [x]);\n  }\n\n  erf<T extends Tensor>(x: T): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.ERF);\n    return this.compileAndRun(program, [x]);\n  }\n\n  step<T extends Tensor>(x: T, alpha: number): T {\n    const program = new UnaryOpProgram(x.shape, unary_op.STEP(alpha));\n    return this.compileAndRun(program, [x]);\n  }\n\n  private conv2dByMatMul(\n      x: Tensor4D, filter: Tensor4D, convInfo: backend_util.Conv2DInfo,\n      bias?: Tensor, activation?: backend_util.Activation,\n      preluActivationWeights?: Tensor): Tensor4D {\n    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the\n    // result from 2D to 4D.\n    const xShape = x.shape;\n    const xTexData = this.texData.get(x.dataId);\n    const sharedMatMulDim = convInfo.inChannels;\n    const outerShapeX = xShape[0] * xShape[1] * xShape[2];\n    const outerShapeFilter = convInfo.outChannels;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    const transposeA = false;\n    const transposeB = false;\n\n    // TODO: Once reduction ops are packed, batchMatMul will always be packed\n    // and we can remove this condition.\n    const batchMatMulWillBeUnpacked =\n        (outerShapeX === 1 || outerShapeFilter === 1) &&\n        sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;\n    const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;\n\n    if (batchMatMulWillBeUnpacked || !env().getBool('WEBGL_LAZILY_UNPACK') ||\n        !env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ||\n        !reshapeWillBeExpensive) {\n      const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :\n                                           xShape[0] * xShape[2] * xShape[3];\n      const xReshaped = this.reshape(x, [1, targetShape, convInfo.inChannels]);\n      const filterReshaped =\n          this.reshape(filter, [1, convInfo.inChannels, convInfo.outChannels]);\n\n      return this.reshape<Rank.R4>(\n          this.fusedBatchMatMul({\n            a: xReshaped as Tensor3D,\n            b: filterReshaped as Tensor3D,\n            transposeA,\n            transposeB,\n            bias,\n            activation,\n            preluActivationWeights\n          }),\n          convInfo.outShape);\n    }\n\n    // Following optimization is specific to packed |x| with odd row count\n    // (For example, in channelLast mode, 'row count' refers to x.shape[2]):\n    // we avoid expensive packed 2x2 reshape by padding row count to next,\n    // even number. When x.shape[2] is odd, the result of packed batchMatMul is\n    // the same (has the same texture layout and and values in the texture) as\n    // it is for even x.shape[2] + 1. We make the odd-rows tensor to look like\n    // even-rows tensor before the operation and, after the batchMatMul,\n    // fix the even-rows result to have odd number of rows.\n    const targetShape = isChannelsLast ?\n        xShape[0] * xShape[1] * (xShape[2] + 1) :\n        xShape[0] * xShape[2] * (xShape[3] + 1);\n    const xReshaped: TensorInfo = {\n      dataId: x.dataId,\n      shape: [1, targetShape, convInfo.inChannels],\n      dtype: x.dtype\n    };\n    // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.\n    // Decrementing row count, after batchMatMul->...->compileProgram leads to\n    // invalid row count within the reference in GPGPUBinary.inShapeInfos.\n    // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos\n    // in compileProgram method, but that would affect compilation of all\n    // programs - instead, provide a copy here, with even row count, before\n    // calling batchMatMul->...->compileProgram and after that, the original\n    // xTexData.shape is restored.\n    const originalXTexDataShape = xTexData.shape;\n    xTexData.shape = xTexData.shape.slice();\n    xTexData.shape[xTexData.shape.length - 2]++;\n    util.assert(\n        webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape),\n        () => `packed reshape ${xTexData.shape} to ${\n            xReshaped.shape} isn't free`);\n    const filterReshaped =\n        this.reshape(filter, [1, convInfo.inChannels, convInfo.outChannels]);\n\n    const pointwiseConv = this.fusedBatchMatMul({\n      a: xReshaped as Tensor3D,\n      b: filterReshaped as Tensor3D,\n      transposeA,\n      transposeB,\n      bias,\n      activation,\n      preluActivationWeights\n    });\n    const pointwiseConvTexData = this.texData.get(pointwiseConv.dataId);\n    util.assert(\n        pointwiseConvTexData.isPacked,\n        () => 'batchMatMul result is expected to be packed');\n    // Restore the input shape to original.\n    xTexData.shape = originalXTexDataShape;\n    // Set the output shape - there is no need for expensive reshape as data\n    // layout is already correct.\n    pointwiseConvTexData.shape = convInfo.outShape;\n    return engine().makeTensorFromDataId(\n               pointwiseConv.dataId, convInfo.outShape, pointwiseConv.dtype) as\n        Tensor4D;\n  }\n\n  private conv2dWithIm2Row(\n      x: Tensor4D, filter: Tensor4D, convInfo: backend_util.Conv2DInfo,\n      bias?: Tensor, activation?: backend_util.Activation,\n      preluActivationWeights?: Tensor): Tensor4D {\n    // Rearranges conv2d input so each block to be convolved over forms the\n    // column of a new matrix with shape [filterWidth * filterHeight *\n    // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n    // output channel forms a row of a new matrix with shape [outChannels,\n    // filterWidth * filterHeight * inChannels]. The convolution is then\n    // computed by multiplying these matrices and reshaping the result.\n    const {\n      filterWidth,\n      filterHeight,\n      inChannels,\n      outWidth,\n      outHeight,\n      dataFormat\n    } = convInfo;\n\n    const isChannelsLast = dataFormat === 'channelsLast';\n\n    const sharedDim = filterWidth * filterHeight * inChannels;\n    const numCols = outHeight * outWidth;\n    const x2ColShape = [sharedDim, numCols];\n    const transposeA = true;\n    const transposeB = false;\n\n    const xSqueezed = x.squeeze([0]);\n    const w2Row = filter.reshape([1, sharedDim, -1]);\n\n    const im2ColProgram =\n        new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);\n    const im2Col: Tensor3D =\n        this.compileAndRun<Tensor2D>(im2ColProgram, [xSqueezed]).reshape([\n          1, x2ColShape[0], x2ColShape[1]\n        ]);\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, true) : null;\n    const matmulProgram = new MatMulPackedProgram(\n        im2Col.shape, [1, numCols, convInfo.outChannels], transposeA,\n        transposeB, hasBias, fusedActivation, hasPreluActivationWeights);\n    const inputs: TensorInfo[] = [im2Col, w2Row];\n    if (bias) {\n      inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    const product = this.compileAndRun<Tensor4D>(matmulProgram, inputs);\n\n    if (isChannelsLast) {\n      return product.reshape([1, outHeight, outWidth, convInfo.outChannels]);\n    } else {\n      return product.reshape([1, convInfo.outChannels, outHeight, outWidth]);\n    }\n  }\n\n  fusedConv2d(\n      {input, filter, convInfo, bias, activation, preluActivationWeights}:\n          backend_util.FusedConv2DConfig): Tensor4D {\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' ||\n         convInfo.padInfo.type === 'VALID')) {\n      return this.conv2dByMatMul(\n          input, filter, convInfo, bias, activation, preluActivationWeights);\n    }\n    if (env().getBool('WEBGL_CONV_IM2COL') && input.shape[0] === 1) {\n      return this.conv2dWithIm2Row(\n          input, filter, convInfo, bias, activation, preluActivationWeights);\n    }\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, false) : null;\n    const program = new Conv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n    const inputs: TensorInfo[] = [input, filter];\n    if (bias) {\n      inputs.push(bias);\n    }\n    if (preluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    return this.compileAndRun(program, inputs);\n  }\n\n  conv2d(x: Tensor4D, filter: Tensor4D, convInfo: backend_util.Conv2DInfo):\n      Tensor4D {\n    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n        convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n        convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n        (convInfo.padInfo.type === 'SAME' ||\n         convInfo.padInfo.type === 'VALID')) {\n      return this.conv2dByMatMul(x, filter, convInfo);\n    }\n    if (env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n      return this.conv2dWithIm2Row(x, filter, convInfo);\n    }\n    const program = new Conv2DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  }\n\n  conv2dDerInput(\n      dy: Tensor4D, filter: Tensor4D,\n      convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new Conv2DDerInputProgram(convInfo);\n    return this.compileAndRun(program, [dy, filter]);\n  }\n\n  conv2dDerFilter(x: Tensor4D, dy: Tensor4D, convInfo: backend_util.Conv2DInfo):\n      Tensor4D {\n    const program = new Conv2DDerFilterProgram(convInfo);\n    return this.compileAndRun(program, [x, dy]);\n  }\n\n  fusedDepthwiseConv2D(\n      {input, filter, convInfo, bias, activation, preluActivationWeights}:\n          backend_util.FusedConv2DConfig): Tensor4D {\n    const shouldPackDepthwiseConv = env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n        convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1;\n    const fusedActivation = activation ?\n        mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) :\n        null;\n    const inputs: Tensor[] = [input, filter];\n\n    const hasBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    if (hasBias) {\n      inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n\n    let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n    if (shouldPackDepthwiseConv) {\n      program = new DepthwiseConvPacked2DProgram(\n          convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n      return this.compileAndRun(program, inputs);\n    }\n\n    program = new DepthwiseConv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n    return this.compileAndRun(program, inputs);\n  }\n\n  depthwiseConv2D(\n      x: Tensor4D, filter: Tensor4D,\n      convInfo: backend_util.Conv2DInfo): Tensor4D {\n    let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n    if (env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n        convInfo.strideWidth <= 2 &&\n        convInfo.outChannels / convInfo.inChannels === 1) {\n      program = new DepthwiseConvPacked2DProgram(convInfo);\n      return this.compileAndRun(program, [x, filter]);\n    }\n\n    program = new DepthwiseConv2DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  }\n\n  depthwiseConv2DDerInput(\n      dy: Tensor4D, filter: Tensor4D,\n      convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new DepthwiseConv2DDerInputProgram(convInfo);\n    return this.compileAndRun(program, [dy, filter]);\n  }\n\n  depthwiseConv2DDerFilter(\n      x: Tensor4D, dy: Tensor4D, convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new DepthwiseConv2DDerFilterProgram(convInfo);\n    return this.compileAndRun(program, [x, dy]);\n  }\n\n  conv3d(x: Tensor5D, filter: Tensor5D, convInfo: backend_util.Conv3DInfo):\n      Tensor5D {\n    const program = new Conv3DProgram(convInfo);\n    return this.compileAndRun(program, [x, filter]);\n  }\n\n  conv3dDerInput(\n      dy: Tensor5D, filter: Tensor5D,\n      convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const program = new Conv3DDerInputProgram(convInfo);\n    return this.compileAndRun(program, [dy, filter]);\n  }\n\n  conv3dDerFilter(x: Tensor5D, dy: Tensor5D, convInfo: backend_util.Conv3DInfo):\n      Tensor5D {\n    const program = new Conv3DDerFilterProgram(convInfo);\n    return this.compileAndRun(program, [x, dy]);\n  }\n\n  maxPool(x: Tensor4D, convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new Pool2DProgram(convInfo, 'max', false);\n    return this.compileAndRun(program, [x]);\n  }\n\n  avgPool(x: Tensor4D, convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const program = new Pool2DProgram(convInfo, 'avg', false);\n    return this.compileAndRun(program, [x], 'float32');\n  }\n\n  maxPoolBackprop(\n      dy: Tensor4D, x: Tensor4D, y: Tensor4D,\n      convInfo: backend_util.Conv2DInfo): Tensor4D {\n    const getPositions = true;\n    const maxPoolPositionsProgram =\n        new Pool2DProgram(convInfo, 'max', getPositions);\n    const maxPoolPositions: Tensor4D =\n        this.compileAndRun(maxPoolPositionsProgram, [x]);\n\n    const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);\n    const result = this.compileAndRun(\n        maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);\n    maxPoolPositions.dispose();\n    return result as Tensor4D;\n  }\n\n  avgPoolBackprop(dy: Tensor4D, x: Tensor4D, convInfo: backend_util.Conv2DInfo):\n      Tensor4D {\n    const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);\n    return this.compileAndRun(avgPoolBackpropProgram, [dy], x.dtype);\n  }\n\n  cast<T extends Tensor>(x: T, dtype: DataType): T {\n    return backend_util.castTensor(x, dtype, this);\n  }\n\n  unstack(x: Tensor, axis: number): Tensor[] {\n    const num = x.shape[axis];\n    const outShape: number[] = new Array(x.rank - 1);\n    let outIndex = 0;\n    for (let i = 0; i < x.rank; i++) {\n      if (i !== axis) {\n        outShape[outIndex++] = x.shape[i];\n      }\n    }\n\n    const begin = new Array(x.rank).fill(0);\n    const size = x.shape.slice();\n    size[axis] = 1;\n    const res = new Array(num);\n    for (let i = 0; i < res.length; i++) {\n      begin[axis] = i;\n      res[i] = this.slice(x, begin, size).reshape(outShape);\n    }\n    return res;\n  }\n\n  avgPool3d(x: Tensor5D, convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const program = new Pool3DProgram(convInfo, 'avg', false);\n    return this.compileAndRun(program, [x], 'float32');\n  }\n\n  avgPool3dBackprop(\n      dy: Tensor5D, x: Tensor5D, convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const avgPool3dBackpropProgram = new AvgPool3DBackpropProgram(convInfo);\n    return this.compileAndRun(avgPool3dBackpropProgram, [dy], x.dtype);\n  }\n\n  maxPool3d(x: Tensor5D, convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const program = new Pool3DProgram(convInfo, 'max', false);\n    return this.compileAndRun(program, [x], 'float32');\n  }\n\n  maxPool3dBackprop(\n      dy: Tensor5D, x: Tensor5D, y: Tensor5D,\n      convInfo: backend_util.Conv3DInfo): Tensor5D {\n    const getPositions = true;\n    const maxPool3dPositionsProgram =\n        new Pool3DProgram(convInfo, 'max', getPositions);\n    const maxPool3dPositions: Tensor5D =\n        this.compileAndRun(maxPool3dPositionsProgram, [x]);\n    const maxPool3dBackPropProgram = new MaxPool3DBackpropProgram(convInfo);\n    const result = this.compileAndRun(\n        maxPool3dBackPropProgram, [dy, maxPool3dPositions], x.dtype);\n    maxPool3dPositions.dispose();\n    return result as Tensor5D;\n  }\n\n  reshape<R extends Rank>(x: Tensor, shape: ShapeMap[R]): Tensor<R> {\n    const texData = this.texData.get(x.dataId);\n    if (texData.isPacked && !webgl_util.isReshapeFree(x.shape, shape) &&\n        !(texData.texture !== null &&\n          webgl_util.isReshapeFree(texData.shape, shape))) {\n      const info = this.packedReshape(x, shape);\n      return engine().makeTensorFromDataId(\n                 info.dataId, info.shape, info.dtype) as Tensor<R>;\n    }\n    return backend_util.reshapeTensor(x, shape);\n  }\n\n  resizeBilinear(\n      x: Tensor4D, newHeight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D {\n    const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n        new ResizeBilinearPackedProgram(\n            x.shape, newHeight, newWidth, alignCorners) :\n        new ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);\n    return this.compileAndRun(program, [x], 'float32');\n  }\n\n  resizeBilinearBackprop(dy: Tensor4D, x: Tensor4D, alignCorners: boolean):\n      Tensor4D {\n    const program = new ResizeBilinearBackpropProgram(dy, x, alignCorners);\n\n    return this.compileAndRun(program, [dy]);\n  }\n\n  resizeNearestNeighbor(\n      x: Tensor4D, newHeight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D {\n    const program = new ResizeNearestNeighborProgram(\n        x.shape, newHeight, newWidth, alignCorners);\n    return this.compileAndRun(program, [x]);\n  }\n\n  resizeNearestNeighborBackprop(\n      dy: Tensor4D, x: Tensor4D, alignCorners: boolean): Tensor4D {\n    const program =\n        new ResizeNearestNeigborBackpropProgram(dy, x, alignCorners);\n    return this.compileAndRun(program, [dy]);\n  }\n\n  multinomial(\n      logits: Tensor2D, normalized: boolean, numSamples: number,\n      seed: number): Tensor2D {\n    const probs = normalized ? logits : softmax(logits);\n    const batchSize = probs.shape[0];\n    const numOutcomes = probs.shape[1];\n    const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);\n    const customSetup = program.getCustomSetupFunc(seed);\n    return this.compileAndRun(program, [probs], 'int32', customSetup);\n  }\n\n  oneHot(indices: Tensor1D, depth: number, onValue: number, offValue: number):\n      Tensor2D {\n    const program = new OneHotProgram(indices.size, depth, onValue, offValue);\n    return this.compileAndRun(program, [indices]);\n  }\n\n  diag(x: Tensor): Tensor {\n    const program = new DiagProgram(x.size);\n    return this.compileAndRun(program, [x]);\n  }\n\n  cropAndResize(\n      image: Tensor4D, boxes: Tensor2D, boxIndex: Tensor1D,\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number): Tensor4D {\n    const program = new CropAndResizeProgram(\n        image.shape, boxes.shape, cropSize, method, extrapolationValue);\n    return this.compileAndRun(program, [image, boxes, boxIndex], 'float32');\n  }\n\n  depthToSpace(x: Tensor4D, blockSize: number, dataFormat: 'NHWC'|'NCHW'):\n      Tensor4D {\n    util.assert(\n        blockSize > 1,\n        () =>\n            `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n\n    const batchSize = x.shape[0];\n    const inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];\n    const inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];\n    const inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];\n\n    const outputHeight = inputHeight * blockSize;\n    const outputWidth = inputWidth * blockSize;\n    const outputDepth = inputDepth / (blockSize * blockSize);\n\n    const outputShape = (dataFormat === 'NHWC') ?\n        [batchSize, outputHeight, outputWidth, outputDepth] :\n        [batchSize, outputDepth, outputHeight, outputWidth];\n\n    const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);\n    return this.compileAndRun(program, [x]);\n  }\n\n  split<T extends Tensor>(x: T, sizeSplits: number[], axis: number): T[] {\n    return split(x, sizeSplits, axis);\n  }\n\n  scatterND<R extends Rank>(\n      indices: Tensor, updates: Tensor, shape: ShapeMap[R]): Tensor<R> {\n    const {sliceRank, numUpdates, sliceSize, strides, outputSize} =\n        backend_util.calculateShapes(updates, indices, shape);\n\n    const flattenShape = [outputSize / sliceSize, sliceSize];\n    const flattenIndices = indices.reshape([numUpdates, sliceRank]);\n    const flattenX = updates.reshape([numUpdates, sliceSize]);\n\n    if (outputSize === 0) {\n      return backend_util.reshapeTensor(tensor([]), shape);\n    }\n    const defaultValue = scalar(0);\n    const program = new ScatterProgram(\n        numUpdates, sliceRank, flattenIndices.rank, flattenX.rank, strides,\n        flattenShape);\n    const res: Tensor =\n        this.compileAndRun(program, [flattenX, flattenIndices, defaultValue]);\n    return res.reshape(shape);\n  }\n\n  sparseToDense<R extends Rank>(\n      sparseIndices: Tensor, sparseValues: Tensor, outputShape: ShapeMap[R],\n      defaultValue: Scalar): Tensor<R> {\n    const {sliceRank, numUpdates, strides, outputSize} =\n        backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n\n    const sumDupeIndices = false;\n    const program = new ScatterProgram(\n        numUpdates, sliceRank, sparseIndices.rank, sparseValues.rank, strides,\n        [outputSize, 1], sumDupeIndices);\n    const res: Tensor = this.compileAndRun(\n        program, [sparseValues, sparseIndices, defaultValue]);\n    return res.reshape(outputShape);\n  }\n\n  fft(x: Tensor2D): Tensor2D {\n    const inverse = false;\n    return this.fftImpl(x, inverse);\n  }\n\n  ifft(x: Tensor2D): Tensor2D {\n    const inverse = true;\n    return this.fftImpl(x, inverse);\n  }\n\n  private fftImpl(x: Tensor2D, inverse: boolean): Tensor2D {\n    const xData = this.texData.get(x.dataId);\n\n    const realProgram =\n        new FFTProgram(fft_gpu.COMPLEX_FFT.REAL, x.shape, inverse);\n    const imagProgram =\n        new FFTProgram(fft_gpu.COMPLEX_FFT.IMAG, x.shape, inverse);\n    const inputs = [\n      this.makeComplexComponentTensorInfo(x, xData.complexTensors.real),\n      this.makeComplexComponentTensorInfo(x, xData.complexTensors.imag),\n    ];\n\n    const real = this.compileAndRun<Tensor>(realProgram, inputs);\n    const imag = this.compileAndRun<Tensor>(imagProgram, inputs);\n    const complex = this.complex(real, imag).as2D(x.shape[0], x.shape[1]);\n    real.dispose();\n    imag.dispose();\n    return complex;\n  }\n\n  gatherND(x: Tensor, indices: Tensor): Tensor {\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n\n    const [resultShape, numSlices, sliceSize, strides] =\n        backend_util.prepareAndValidate(x, indices);\n\n    const flattenIndices = indices.reshape([numSlices, sliceRank]);\n    const flattenX = x.reshape([x.size / sliceSize, sliceSize]);\n    const program =\n        new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);\n    const res: Tensor = this.compileAndRun(program, [flattenX, flattenIndices]);\n    return res.reshape(resultShape);\n  }\n\n  fill<R extends Rank>(\n      shape: ShapeMap[R], value: number|string, dtype?: DataType): Tensor<R> {\n    dtype = dtype || util.inferDtype(value);\n\n    if (dtype === 'string') {\n      // String type should be handled in CPU memory.\n      const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n      values.fill(value as string);\n      return engine().makeTensor(values, shape, dtype, this) as Tensor<R>;\n    } else {\n      const program = new FillProgram(shape, value as number);\n      const customSetup = program.getCustomSetupFunc(value as number);\n      return this.compileAndRun(program, [], dtype, customSetup);\n    }\n  }\n\n  onesLike<R extends Rank>(x: Tensor<R>): Tensor<R> {\n    if (x.dtype === 'string') {\n      throw new Error('onesLike is not supported under string dtype');\n    } else {\n      // TODO(cais, smilkov): Add WebGL shader for onesLike:\n      //   https://github.com/tensorflow/tfjs/issues/1293\n      return this.fill(x.shape, 1, x.dtype);\n    }\n  }\n\n  zerosLike<R extends Rank>(x: Tensor<R>): Tensor<R> {\n    return this.fill(x.shape, x.dtype === 'string' ? '' : 0, x.dtype);\n  }\n\n  linspace(start: number, stop: number, num: number): Tensor1D {\n    // TODO: Use CPU implementation due to the precision problem in Safari.\n    return backend_util.linspaceImpl(start, stop, num);\n  }\n\n  makeTensorInfo(shape: number[], dtype: DataType): TensorInfo {\n    const dataId = this.write(null /* values */, shape, dtype);\n    this.texData.get(dataId).usage = null;\n    return {dataId, shape, dtype};\n  }\n\n  private makeOutput<T extends Tensor>(shape: number[], dtype: DataType): T {\n    const {dataId} = this.makeTensorInfo(shape, dtype);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, this) as T;\n  }\n\n  private unpackTensor(input: TensorInfo): TensorInfo {\n    const program = new UnpackProgram(input.shape);\n    return this.runWebGLProgram(program, [input], input.dtype);\n  }\n\n  private packTensor(input: TensorInfo): TensorInfo {\n    const program = new PackProgram(input.shape);\n    const preventEagerUnpackingOutput = true;\n    return this.runWebGLProgram(\n        program, [input], input.dtype, null /* customSetup */,\n        preventEagerUnpackingOutput);\n  }\n\n  private packedReshape(input: TensorInfo, afterShape: number[]): TensorInfo {\n    const input3DShape = [\n      webgl_util.getBatchDim(input.shape),\n      ...webgl_util.getRowsCols(input.shape)\n    ] as [number, number, number];\n    const input3D: TensorInfo = {\n      dtype: input.dtype,\n      shape: input3DShape,\n      dataId: input.dataId\n    };\n    const afterShapeAs3D = [\n      webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n    ] as [number, number, number];\n\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const output = this.runWebGLProgram(\n        program, [input3D], input.dtype, null /* customSetup */,\n        preventEagerUnpackingOfOutput);\n    return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n  }\n\n  private decode(dataId: DataId): TensorInfo {\n    const texData = this.texData.get(dataId);\n    const {isPacked, shape, dtype} = texData;\n    const shapeAs3D =\n        webgl_util.getShapeAs3D(shape) as [number, number, number];\n    let program;\n    if (isPacked) {\n      program = new DecodeMatrixPackedProgram(shapeAs3D);\n    } else {\n      program = new DecodeMatrixProgram(shapeAs3D);\n    }\n    const preventEagerUnpackingOfOutput = true;\n    const out = this.runWebGLProgram(\n        program, [{shape: shapeAs3D, dtype, dataId}], dtype,\n        null /* customSetup */, preventEagerUnpackingOfOutput);\n    return {dtype, shape, dataId: out.dataId};\n  }\n\n  runWebGLProgram(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype: DataType,\n      customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => void,\n      preventEagerUnpackingOfOutput = false): TensorInfo {\n    const output = this.makeTensorInfo(program.outputShape, outputDtype);\n    const outData = this.texData.get(output.dataId);\n    if (program.packedOutput) {\n      outData.isPacked = true;\n    }\n    if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n      const texelShape = tex_util.getDenseTexShape(program.outputShape);\n      // For a densely packed output, we explicitly set texShape\n      // so it doesn't get assigned later according to our typical packing\n      // scheme wherein a single texel can only contain values from adjacent\n      // rows/cols.\n      outData.texShape = texelShape.map(d => d * 2) as [number, number];\n    }\n    if (program.outTexUsage != null) {\n      outData.usage = program.outTexUsage;\n    }\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      outData.values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n\n    const dataToDispose: TensorInfo[] = [];\n    const inputsData: TensorData[] = inputs.map(input => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n\n      let texData = this.texData.get(input.dataId);\n\n      if (texData.texture == null) {\n        if (!program.packedInputs &&\n            util.sizeFromShape(input.shape) <=\n                env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n          // Upload small tensors that live on the CPU as uniforms, not as\n          // textures. Do this only when the environment supports 32bit floats\n          // due to problems when comparing 16bit floats with 32bit floats.\n          // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n          // possible for packed shaders to sample from uniforms.\n          return {\n            shape: input.shape,\n            texData: null,\n            isUniform: true,\n            uniformValues: texData.values as TypedArray\n          };\n        }\n\n        // This ensures that if a packed program's inputs have not yet been\n        // uploaded to the GPU, they get uploaded as packed right off the bat.\n        if (program.packedInputs) {\n          texData.isPacked = true;\n          texData.shape = input.shape;\n        }\n      } else if (!!texData.isPacked !== !!program.packedInputs) {\n        input = texData.isPacked ? this.unpackTensor(input) :\n                                   this.packTensor(input);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n      } else if (\n          texData.isPacked &&\n          !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n        // This is a special case where a texture exists for a tensor\n        // but the shapes are incompatible (due to packing constraints) because\n        // the tensor did not have a chance to go through the packed reshape\n        // shader. This only happens when we reshape the *same* tensor to form\n        // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n        // case will disappear once packed uploading is the default.\n\n        const savedInput = input;\n        const targetShape = input.shape;\n\n        input.shape = texData.shape;\n        input = this.packedReshape(input as Tensor, targetShape);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n\n        savedInput.shape = targetShape;\n      }\n\n      this.uploadToGPU(input.dataId);\n      return {shape: input.shape, texData, isUniform: false};\n    });\n\n    this.uploadToGPU(output.dataId);\n    const outputData:\n        TensorData = {shape: output.shape, texData: outData, isUniform: false};\n    const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n    const binary = this.getAndSaveBinary(key, () => {\n      return gpgpu_math.compileProgram(\n          this.gpgpu, program, inputsData, outputData);\n    });\n    const shouldTimeProgram = this.activeTimers != null;\n    let query: WebGLQuery|CPUTimerQuery;\n    if (shouldTimeProgram) {\n      query = this.startTimer();\n    }\n\n    gpgpu_math.runProgram(\n        this.gpgpu, binary, inputsData, outputData, customSetup);\n\n    dataToDispose.forEach(info => this.disposeData(info.dataId));\n\n    if (shouldTimeProgram) {\n      query = this.endTimer(query);\n      this.activeTimers.push(\n          {name: program.constructor.name, query: this.getQueryTime(query)});\n    }\n\n    if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n        preventEagerUnpackingOfOutput === false) {\n      const unpacked = this.unpackTensor(output);\n      this.disposeData(output.dataId);\n      return unpacked;\n    }\n    return output;\n  }\n\n  compileAndRun<K extends TensorInfo>(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype?: DataType,\n      customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => void,\n      preventEagerUnpackingOfOutput = false): K {\n    outputDtype = outputDtype || inputs[0].dtype;\n    const outInfo = this.runWebGLProgram(\n        program, inputs, outputDtype, customSetup,\n        preventEagerUnpackingOfOutput);\n    return engine().makeTensorFromDataId(\n               outInfo.dataId, outInfo.shape, outInfo.dtype) as {} as K;\n  }\n\n  private getAndSaveBinary(key: string, getBinary: () => GPGPUBinary):\n      GPGPUBinary {\n    if (!(key in this.binaryCache)) {\n      this.binaryCache[key] = getBinary();\n    }\n    return this.binaryCache[key];\n  }\n\n  getTextureManager(): TextureManager {\n    return this.textureManager;\n  }\n\n  private disposed = false;\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n    // Avoid disposing the compiled webgl programs during unit testing because\n    // it slows down test execution.\n    if (!env().getBool('IS_TEST')) {\n      const allKeys = Object.keys(this.binaryCache);\n      allKeys.forEach(key => {\n        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n        delete this.binaryCache[key];\n      });\n    }\n    this.textureManager.dispose();\n    if (this.canvas != null &&\n        (typeof (HTMLCanvasElement) !== 'undefined' &&\n         this.canvas instanceof HTMLCanvasElement)) {\n      this.canvas.remove();\n    } else {\n      this.canvas = null;\n    }\n    if (this.gpgpuCreatedLocally) {\n      this.gpgpu.program = null;\n      this.gpgpu.dispose();\n    }\n    this.disposed = true;\n  }\n\n  floatPrecision(): 16|32 {\n    if (this.floatPrecisionValue == null) {\n      this.floatPrecisionValue = tidy(() => {\n        if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n          // Momentarily switching DEBUG flag to false so we don't throw an\n          // error trying to upload a small value.\n          const debugFlag = env().getBool('DEBUG');\n          env().set('DEBUG', false);\n          const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n          env().set('DEBUG', debugFlag);\n\n          if (underflowCheckValue > 0) {\n            return 32;\n          }\n        }\n        return 16;\n      });\n    }\n    return this.floatPrecisionValue;\n  }\n  /** Returns the smallest representable number.  */\n  epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n\n  private uploadToGPU(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    const {shape, dtype, values, texture, usage, isPacked} = texData;\n\n    if (texture != null) {\n      // Array is already on GPU. No-op.\n      return;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let texShape = texData.texShape;\n    if (texShape == null) {\n      texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n      texData.texShape = texShape;\n    }\n\n    if (values != null) {\n      const shapeAs3D = webgl_util.getShapeAs3D(shape);\n\n      let program;\n      let width = texShape[1], height = texShape[0];\n      const isByteArray = values instanceof Uint8Array;\n\n      if (isPacked) {\n        [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(\n            texShape[0], texShape[1]);\n        program = new EncodeMatrixPackedProgram(\n            shapeAs3D, [height, width], isByteArray);\n      } else {\n        program =\n            new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);\n      }\n\n      const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n      if (isByteArray) {\n        this.texData.get(tempDenseInputHandle.dataId).usage =\n            TextureUsage.PIXELS;\n      } else {\n        this.texData.get(tempDenseInputHandle.dataId).usage =\n            TextureUsage.UPLOAD;\n      }\n      this.gpgpu.uploadDenseMatrixToTexture(\n          this.getTexture(tempDenseInputHandle.dataId), width, height,\n          values as TypedArray);\n\n      // We want the output to remain packed regardless of the value of\n      // WEBGL_PACK.\n      const preventEagerUnpacking = true;\n      const encodedOutputTarget = this.runWebGLProgram(\n          program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);\n\n      // Have the original texture assume the identity of the encoded output.\n      const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n      texData.texture = outputTexData.texture;\n      texData.texShape = outputTexData.texShape;\n      texData.isPacked = outputTexData.isPacked;\n      texData.usage = outputTexData.usage;\n\n      this.disposeData(tempDenseInputHandle.dataId);\n      this.texData.delete(encodedOutputTarget.dataId);\n\n      // Once uploaded, don't store the values on cpu.\n      texData.values = null;\n      if (shouldTimeProgram) {\n        this.uploadWaitMs += util.now() - start;\n      }\n    } else {\n      const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n      texData.texture = newTexture;\n    }\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, float32Values?: Float32Array):\n      TypedArray {\n    const texData = this.texData.get(dataId);\n    const {dtype} = texData;\n\n    this.releaseGPUData(dataId);\n\n    if (float32Values != null) {\n      texData.values = float32ToTypedArray(float32Values, dtype as 'float32');\n    }\n    return texData.values as TypedArray;\n  }\n\n  private acquireTexture(\n      texShape: [number, number], texType: TextureUsage, dtype: DataType,\n      isPacked: boolean): WebGLTexture {\n    this.numBytesInGPU += this.computeBytes(texShape, dtype);\n    if (!this.warnedAboutMemory &&\n        this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n      const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n      this.warnedAboutMemory = true;\n      console.warn(\n          `High memory usage in GPU: ${mb} MB, ` +\n          `most likely due to a memory leak`);\n    }\n    return this.textureManager.acquireTexture(texShape, texType, isPacked);\n  }\n\n  private computeBytes(shape: [number, number], dtype: DataType) {\n    return shape[0] * shape[1] * util.bytesPerElement(dtype);\n  }\n}\n\nfunction float32ToTypedArray<D extends NumericDataType>(\n    a: Float32Array, dtype: D): tf.DataTypeMap[D] {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a as tf.DataTypeMap[D];\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    const result = (dtype === 'int32') ? new Int32Array(a.length) :\n                                         new Uint8Array(a.length);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result as tf.DataTypeMap[D];\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n","/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '2.0.1';\nexport {version};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\nimport {TensorInfo} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport * as binaryop_gpu from '../binaryop_gpu';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport * as binaryop_packed_gpu from '../binaryop_packed_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nexport function divImpl(\n    a: TensorInfo, b: TensorInfo, backend: MathBackendWebGL): TensorInfo {\n  let program = new BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);\n  if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n    program = new BinaryOpPackedProgram(\n        binaryop_packed_gpu.DIV, a.shape, b.shape, true);\n  }\n  const output = backend.runWebGLProgram(program, [a, b], 'float32');\n  return output;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Div, DivInputs} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {divImpl} from './Div_impl';\n\nexport const divConfig: KernelConfig = {\n  kernelName: Div,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend}) => {\n    const {a, b} = inputs as DivInputs;\n\n    const webglBackend = backend as MathBackendWebGL;\n\n    return divImpl(a, b, webglBackend);\n  }\n};\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);\n\n        vec4 values = ${glsl.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${width}.0, ${height}.0);\n            vec4 values = ${glsl.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {TextureUsage} from '../tex_util';\n\nimport {FromPixelsProgram} from './FromPixels_utils/from_pixels_gpu';\nimport {FromPixelsPackedProgram} from './FromPixels_utils/from_pixels_packed_gpu';\n\nexport const fromPixelsConfig: KernelConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgl',\n  kernelFunc: fromPixels as {} as KernelFunc,\n};\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\n\nfunction fromPixels(args: {\n  inputs: FromPixelsInputs,\n  backend: MathBackendWebGL,\n  attrs: FromPixelsAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  let {pixels} = inputs;\n  const {numChannels} = attrs;\n\n  const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement;\n  const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement;\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n\n  const texShape: [number, number] = [height, width];\n  const outShape = [height, width, numChannels];\n\n  if (isImage || isVideo) {\n    if (fromPixels2DContext == null) {\n      fromPixels2DContext = document.createElement('canvas').getContext('2d');\n    }\n\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(\n        pixels as HTMLVideoElement | HTMLImageElement, 0, 0, width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n\n  const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n  // This is a byte texture with pixels.\n  backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n  backend.gpgpu.uploadPixelDataToTexture(\n      backend.getTexture(tempPixelHandle.dataId), pixels as ImageData);\n  const program = env().getBool('WEBGL_PACK') ?\n      new FromPixelsPackedProgram(outShape) :\n      new FromPixelsProgram(outShape);\n  const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n  backend.disposeData(tempPixelHandle.dataId);\n  return res;\n}\n","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function maxImpl(aVals, reduceSize, outShape, dtype) {\n    const vals = util.getTypedArrayFromDType(dtype, util.sizeFromShape(outShape));\n    for (let i = 0; i < vals.length; ++i) {\n        const offset = i * reduceSize;\n        let max = aVals[offset];\n        for (let j = 0; j < reduceSize; ++j) {\n            const value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n            }\n        }\n        vals[i] = max;\n    }\n    return vals;\n}\n//# sourceMappingURL=Max_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function transposeImpl(xVals, xShape, dtype, perm, newShape) {\n    const xRank = xShape.length;\n    const xSize = util.sizeFromShape(xShape);\n    const xStrides = util.computeStrides(xShape);\n    const newStrides = util.computeStrides(newShape);\n    const result = util.getTypedArrayFromDType(dtype, util.sizeFromShape(newShape));\n    for (let i = 0; i < xSize; ++i) {\n        const loc = util.indexToLoc(i, xRank, xStrides);\n        // Permute location.\n        const newLoc = new Array(loc.length);\n        for (let i = 0; i < newLoc.length; i++) {\n            newLoc[i] = loc[perm[i]];\n        }\n        const newIndex = util.locToIndex(newLoc, xRank, newStrides);\n        result[newIndex] = xVals[i];\n    }\n    return result;\n}\n//# sourceMappingURL=Transpose_impl.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Shared kernel impls for use in other backends.\nexport { maxImpl } from './kernels/Max_impl';\nexport { transposeImpl } from './kernels/Transpose_impl';\n//# sourceMappingURL=shared.js.map","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { engine, env } from '@tensorflow/tfjs-core';\nimport { backend_util, buffer, slice_util, util } from '@tensorflow/tfjs-core';\nimport { DataStorage, KernelBackend, max, TensorBuffer, upcastType } from '@tensorflow/tfjs-core';\nimport { kernel_impls } from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV3 = kernel_impls.nonMaxSuppressionV3;\nconst split = kernel_impls.split;\nconst tile = kernel_impls.tile;\nconst topkImpl = kernel_impls.topkImpl;\nconst whereImpl = kernel_impls.whereImpl;\nimport * as seedrandom from 'seedrandom';\nimport { assertNotComplex } from './cpu_util';\nimport { maxPoolPositions, pool } from './utils/pool_utils';\nfunction mapActivation(backend, x, activation, preluActivationWeights) {\n    if (activation === 'linear') {\n        return backend.linear(x);\n    }\n    else if (activation === 'relu') {\n        return backend.relu(x);\n    }\n    else if (activation === 'elu') {\n        return backend.elu(x);\n    }\n    else if (activation === 'relu6') {\n        return backend.relu6(x);\n    }\n    else if (activation === 'prelu') {\n        return backend.prelu(x, preluActivationWeights);\n    }\n    throw new Error(`Activation ${activation} has not been implemented for the CPU backend.`);\n}\nexport class MathBackendCPU extends KernelBackend {\n    constructor() {\n        super();\n        this.blockSize = 48;\n        this.firstUse = true;\n        this.data = new DataStorage(this, engine());\n    }\n    write(values, shape, dtype) {\n        if (this.firstUse) {\n            this.firstUse = false;\n            if (env().get('IS_NODE')) {\n                backend_util.warn('\\n============================\\n' +\n                    'Hi there 👋. Looks like you are running TensorFlow.js in ' +\n                    'Node.js. To speed things up dramatically, install our node ' +\n                    'backend, which binds to TensorFlow C++, by running ' +\n                    'npm i @tensorflow/tfjs-node, ' +\n                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +\n                    'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' +\n                    'suffix for CUDA) at the start of your program. ' +\n                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +\n                    '\\n============================');\n            }\n        }\n        const dataId = {};\n        this.data.set(dataId, { values, dtype });\n        return dataId;\n    }\n    move(dataId, values, shape, dtype) {\n        this.data.set(dataId, { values, dtype });\n    }\n    numDataIds() {\n        return this.data.numDataIds();\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { dtype, complexTensors } = this.data.get(dataId);\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensors.real.dataId);\n            const imagValues = this.readSync(complexTensors.imag.dataId);\n            return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        return this.data.get(dataId).values;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return tf.buffer(t.shape, t.dtype, decodedData);\n    }\n    makeOutput(values, shape, dtype) {\n        const dataId = this.write(values, shape, dtype);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    disposeData(dataId) {\n        if (this.data.has(dataId)) {\n            const { complexTensors } = this.data.get(dataId);\n            if (complexTensors != null) {\n                complexTensors.real.dispose();\n                complexTensors.imag.dispose();\n            }\n            this.data.delete(dataId);\n        }\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    memory() {\n        return {\n            // Unreliable due to automatic gc. The numbers above are cumulative.\n            unreliable: true,\n            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +\n                    'collection, the true allocated memory may be less.']\n        };\n    }\n    complex(real, imag) {\n        const result = this.makeOutput(null, real.shape, 'complex64');\n        const resultData = this.data.get(result.dataId);\n        // The backend owns the reference to the underlying real and imaginary\n        // clones. These will explicitly get disposed when the complex tensor is\n        // disposed.\n        resultData.complexTensors = {\n            real: engine().keep(real.clone()),\n            imag: engine().keep(imag.clone())\n        };\n        return result;\n    }\n    real(input) {\n        const resultData = this.data.get(input.dataId);\n        return resultData.complexTensors.real.clone();\n    }\n    imag(input) {\n        const resultData = this.data.get(input.dataId);\n        return resultData.complexTensors.imag.clone();\n    }\n    slice(x, begin, size) {\n        assertNotComplex(x, 'slice');\n        const isContinous = slice_util.isSliceContinous(x.shape, begin, size);\n        if (isContinous) {\n            const flatOffset = slice_util.computeFlatOffset(begin, x.strides);\n            const length = util.sizeFromShape(size);\n            const vals = this.readSync(x.dataId);\n            return tf.tensor(vals.subarray(flatOffset, flatOffset + length), size, x.dtype);\n        }\n        const buffer = tf.buffer(size, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; ++i) {\n            const loc = buffer.indexToLoc(i);\n            const xLoc = loc.map((idx, j) => idx + begin[j]);\n            buffer.values[i] = xBuf.get(...xLoc);\n        }\n        return buffer.toTensor();\n    }\n    stridedSlice(x, begin, end, strides) {\n        assertNotComplex(x, 'stridedSlice');\n        const outShape = slice_util.computeOutShape(begin, end, strides);\n        if (outShape.some(axis => axis === 0)) {\n            return tf.tensor([], outShape);\n        }\n        const buffer = tf.buffer(outShape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; i++) {\n            const loc = buffer.indexToLoc(i);\n            const newLoc = new Array(loc.length);\n            for (let j = 0; j < newLoc.length; j++) {\n                newLoc[j] = loc[j] * strides[j] + begin[j];\n            }\n            buffer.set(xBuf.get(...newLoc), ...loc);\n        }\n        return buffer.toTensor();\n    }\n    diag(x) {\n        const xVals = this.readSync(x.dataId);\n        const buffer = tf.buffer([x.size, x.size], x.dtype);\n        const vals = buffer.values;\n        for (let i = 0; i < xVals.length; i++) {\n            vals[i * x.size + i] = xVals[i];\n        }\n        return buffer.toTensor();\n    }\n    unstack(x, axis) {\n        const num = x.shape[axis];\n        const outShape = new Array(x.rank - 1);\n        let outIndex = 0;\n        for (let i = 0; i < x.rank; i++) {\n            if (i !== axis) {\n                outShape[outIndex++] = x.shape[i];\n            }\n        }\n        const begin = new Array(x.rank).fill(0);\n        const size = x.shape.slice();\n        size[axis] = 1;\n        const res = new Array(num);\n        for (let i = 0; i < res.length; i++) {\n            begin[axis] = i;\n            res[i] = this.slice(x, begin, size).reshape(outShape);\n        }\n        return res;\n    }\n    reverse(x, axis) {\n        assertNotComplex(x, 'reverse');\n        const buffer = tf.buffer(x.shape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; i++) {\n            const outLoc = buffer.indexToLoc(i);\n            const inLoc = outLoc.slice();\n            axis.forEach(ax => inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]);\n            buffer.set(xBuf.get(...inLoc), ...outLoc);\n        }\n        return buffer.toTensor();\n    }\n    concat(tensors, axis) {\n        if (tensors[0].dtype === 'complex64') {\n            const reals = tensors.map((t) => tf.real(t));\n            const imags = tensors.map((t) => tf.imag(t));\n            return tf.complex(this.concat(reals, axis), this.concat(imags, axis));\n        }\n        const tensors2D = tensors.map(t => {\n            const innerSize = util.sizeFromShape(t.shape.slice(axis));\n            return t.as2D(-1, innerSize);\n        });\n        const outShape = backend_util.computeOutShape(tensors2D.map(t => t.shape), 1 /* axis\n          */);\n        const values = tf.buffer(outShape, tensors[0].dtype)\n            .values;\n        if (tensors2D[0].shape[0] === 1) {\n            // Use built-in TypedArray.set() method for speed.\n            let offset = 0;\n            tensors2D.forEach(t => {\n                values.set(this.readSync(t.dataId), offset);\n                offset += t.size;\n            });\n        }\n        else {\n            let colOffset = 0;\n            tensors2D.forEach(t => {\n                const tVals = this.readSync(t.dataId);\n                let tIdx = 0;\n                for (let row = 0; row < t.shape[0]; ++row) {\n                    const resIdx = row * outShape[1] + colOffset;\n                    for (let col = 0; col < t.shape[1]; ++col) {\n                        values[resIdx + col] = tVals[tIdx++];\n                    }\n                }\n                colOffset += t.shape[1];\n            });\n        }\n        const finalOutShape = backend_util.computeOutShape(tensors.map(t => t.shape), axis);\n        return tf.tensor(values, finalOutShape, tensors[0].dtype);\n    }\n    neg(x) {\n        assertNotComplex(x, 'neg');\n        return this.multiply(tf.scalar(-1), x);\n    }\n    add(a, b) {\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), (aReal, aImag, bReal, bImag) => {\n                return { real: aReal + bReal, imag: aImag + bImag };\n            });\n        }\n        return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), (aValue, bValue) => aValue + bValue);\n    }\n    addN(tensors) {\n        assertNotComplex(tensors, 'addN');\n        const vals = tensors.map(t => this.readSync(t.dataId));\n        const result = tf.buffer(tensors[0].shape, tensors[0].dtype);\n        const resultVals = result.values;\n        for (let i = 0; i < tensors.length; i++) {\n            const currVals = vals[i];\n            for (let j = 0; j < resultVals.length; j++) {\n                resultVals[j] += currVals[j];\n            }\n        }\n        return result.toTensor();\n    }\n    softmax(logits, dim) {\n        const axes = util.parseAxisParam([dim], logits.shape);\n        // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n        // modularization.\n        const maxLogit = max(logits, axes);\n        const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n        const a = this.subtract(logits, maxLogit.reshape(expandedShape));\n        const b = this.exp(a);\n        const sumExp = this.sum(b, axes).reshape(expandedShape);\n        // TODO(annxingyuan): Call divImpl rather than op as part of softmax\n        // kernel modularization.\n        return tf.div(b, sumExp);\n    }\n    subtract(a, b) {\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), (aReal, aImag, bReal, bImag) => {\n                return { real: aReal - bReal, imag: aImag - bImag };\n            });\n        }\n        return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), (aValue, bValue) => aValue - bValue);\n    }\n    pow(a, b) {\n        assertNotComplex([a, b], 'pow');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.pow(aValue, bValue));\n    }\n    batchMatMul(a, b, transposeA, transposeB) {\n        assertNotComplex([a, b], 'matMul');\n        const sharedDim = transposeA ? a.shape[1] : a.shape[2];\n        const leftDim = transposeA ? a.shape[2] : a.shape[1];\n        const rightDim = transposeB ? b.shape[1] : b.shape[2];\n        const batchDim = a.shape[0];\n        const aValues = this.readSync(a.dataId);\n        const bValues = this.readSync(b.dataId);\n        const [aBatch, aOuterStep, aInnerStep] = transposeA ?\n            [a.strides[0], 1, a.strides[1]] :\n            [a.strides[0], a.strides[1], 1];\n        const [bInnerStep, bOuterStep, bBatch] = transposeB ?\n            [1, b.strides[1], b.strides[0]] :\n            [b.strides[1], 1, b.strides[0]];\n        const size = leftDim * rightDim;\n        const result = tf.buffer([batchDim, leftDim, rightDim], a.dtype);\n        const resVals = result.values;\n        const blockSize = this.blockSize;\n        for (let b = 0; b < batchDim; b++) {\n            for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n                for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n                    for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n                        // for when blockSize doesn't evenly divide the input\n                        const iBlock = Math.min(i0 + blockSize, leftDim);\n                        const jBlock = Math.min(j0 + blockSize, rightDim);\n                        const kBlock = Math.min(k0 + blockSize, sharedDim);\n                        for (let i = i0; i < iBlock; i++) {\n                            for (let j = j0; j < jBlock; j++) {\n                                let sum = 0.0;\n                                for (let k = k0; k < kBlock; k++) {\n                                    sum += aValues[b * aBatch + i * aOuterStep + k * aInnerStep] *\n                                        bValues[k * bInnerStep + j * bOuterStep + b * bBatch];\n                                }\n                                resVals[b * size + (i * rightDim + j)] += sum;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result.toTensor();\n    }\n    fusedBatchMatMul({ a, b, transposeA, transposeB, bias, activation, preluActivationWeights }) {\n        let result = this.batchMatMul(a, b, transposeA, transposeB);\n        if (bias) {\n            result = this.add(result, bias);\n        }\n        if (activation) {\n            result =\n                mapActivation(this, result, activation, preluActivationWeights);\n        }\n        return result;\n    }\n    multiply(a, b) {\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), (aReal, aImag, bReal, bImag) => {\n                return {\n                    real: aReal * bReal - aImag * bImag,\n                    imag: aReal * bImag + aImag * bReal\n                };\n            });\n        }\n        return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), (aValue, bValue) => aValue * bValue);\n    }\n    floorDiv(a, b) {\n        assertNotComplex([a, b], 'floorDiv');\n        const op = (a, b) => Math.floor(a / b);\n        const outputDtype = 'int32';\n        return this.broadcastedBinaryOp(a, b, outputDtype, op);\n    }\n    sum(x, axes) {\n        assertNotComplex(x, 'sum');\n        backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(outShape, resultDtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let sum = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                sum += aVals[offset + j];\n            }\n            vals[i] = sum;\n        }\n        return result;\n    }\n    prod(x, axes) {\n        assertNotComplex(x, 'sum');\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(outShape, resultDtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let prod = 1;\n            for (let j = 0; j < reduceSize; ++j) {\n                prod *= aVals[offset + j];\n            }\n            vals[i] = prod;\n        }\n        return result;\n    }\n    unsortedSegmentSum(x, segmentIds, numSegments) {\n        assertNotComplex(x, 'unsortedSegmentSum');\n        const res = [];\n        // Reshape the segment id's so that they can be broadcast with\n        // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n        const numIters = x.rank - segmentIds.rank;\n        for (let i = 0; i < numIters; ++i) {\n            segmentIds = segmentIds.expandDims(i + 1);\n        }\n        for (let i = 0; i < numSegments; ++i) {\n            const segmentId = tf.scalar(i, 'int32');\n            const mask = tf.equal(segmentId, segmentIds).asType('float32');\n            const sum = mask.mul(x).sum(0);\n            res.push(sum);\n        }\n        return tf.stack(res);\n    }\n    argMin(x, axis) {\n        assertNotComplex(x, 'argMin');\n        const axes = [axis];\n        backend_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, 'int32');\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let min = aVals[offset];\n            let minIndex = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value < min) {\n                    min = value;\n                    minIndex = j;\n                }\n            }\n            vals[i] = minIndex;\n        }\n        return result;\n    }\n    argMax(x, axis) {\n        assertNotComplex(x, 'argMax');\n        const axes = [axis];\n        backend_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, 'int32');\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let max = aVals[offset];\n            let maxIndex = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value > max) {\n                    max = value;\n                    maxIndex = j;\n                }\n            }\n            vals[i] = maxIndex;\n        }\n        return result;\n    }\n    cumsum(x, axis, exclusive, reverse) {\n        assertNotComplex(x, 'cumsum');\n        if (axis !== x.rank - 1) {\n            throw new Error(`backend.cumsum in CPU expects an inner-most axis=${x.rank - 1} ` +\n                `but got axis=${axis}`);\n        }\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(x.shape, resultDtype);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        const finalDim = x.shape[x.rank - 1];\n        const indexAdjuster = reverse ?\n            (i, j) => i + finalDim - j - 1 :\n            (i, j) => i + j;\n        for (let i = 0; i < aVals.length; i += finalDim) {\n            for (let j = 0; j < finalDim; j++) {\n                const idx = indexAdjuster(i, j);\n                if (j === 0) {\n                    vals[idx] = exclusive ? 0 : aVals[idx];\n                }\n                else {\n                    const prevIdx = indexAdjuster(i, j - 1);\n                    vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :\n                        aVals[idx] + vals[prevIdx];\n                }\n            }\n        }\n        return result;\n    }\n    equal(a, b) {\n        assertNotComplex([a, b], 'equal');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal === bVal) ? 1 : 0;\n        });\n    }\n    notEqual(a, b) {\n        assertNotComplex([a, b], 'notEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal !== bVal) ? 1 : 0;\n        });\n    }\n    less(a, b) {\n        assertNotComplex([a, b], 'less');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal < bVal) ? 1 : 0;\n        });\n    }\n    lessEqual(a, b) {\n        assertNotComplex([a, b], 'lessEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal <= bVal) ? 1 : 0;\n        });\n    }\n    greater(a, b) {\n        assertNotComplex([a, b], 'greater');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal > bVal) ? 1 : 0;\n        });\n    }\n    greaterEqual(a, b) {\n        assertNotComplex([a, b], 'greaterEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal >= bVal) ? 1 : 0;\n        });\n    }\n    logicalNot(x) {\n        assertNotComplex(x, 'logicalNot');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = values[i] ? 0 : 1;\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    logicalAnd(a, b) {\n        assertNotComplex([a, b], 'logicalAnd');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return aVal && bVal;\n        });\n    }\n    logicalOr(a, b) {\n        assertNotComplex([a, b], 'logicalOr');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return aVal || bVal;\n        });\n    }\n    select(condition, a, b) {\n        assertNotComplex([condition, a, b], 'select');\n        const values = this.readSync(condition.dataId);\n        const aValues = this.readSync(a.dataId);\n        const bValues = this.readSync(b.dataId);\n        const result = tf.zeros(a.shape, upcastType(a.dtype, b.dtype));\n        const newValues = this.readSync(result.dataId);\n        let index = 0;\n        const offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ?\n            1 :\n            util.sizeFromShape(a.shape.slice(1));\n        for (let i = 0; i < values.length; i++) {\n            for (let j = 0; j < offset; j++) {\n                if (values[i] === 1) {\n                    newValues[index++] = aValues[i];\n                }\n                else {\n                    newValues[index++] = bValues[i];\n                }\n            }\n        }\n        return result;\n    }\n    where(condition) {\n        assertNotComplex([condition], 'where');\n        const condVals = this.readSync(condition.dataId);\n        return whereImpl(condition.shape, condVals);\n    }\n    topk(x, k, sorted) {\n        assertNotComplex(x, 'topk');\n        const xVals = this.readSync(x.dataId);\n        return topkImpl(xVals, x.shape, x.dtype, k, sorted);\n    }\n    min(x, axes) {\n        assertNotComplex(x, 'min');\n        backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let min = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value < min) {\n                    min = value;\n                }\n            }\n            vals[i] = min;\n        }\n        return result;\n    }\n    minimum(a, b) {\n        assertNotComplex([a, b], 'minimum');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.min(aVal, bVal));\n    }\n    mod(a, b) {\n        assertNotComplex([a, b], 'mod');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n            const rem = aVal % bVal;\n            if ((aVal < 0 && bVal < 0) || (aVal >= 0 && bVal >= 0)) {\n                return rem;\n            }\n            else {\n                return (rem + bVal) % bVal;\n            }\n        });\n    }\n    maximum(a, b) {\n        assertNotComplex([a, b], 'maximum');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.max(aVal, bVal));\n    }\n    all(x, axes) {\n        assertNotComplex(x, 'all');\n        backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let all = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                all = all && value;\n            }\n            vals[i] = all;\n        }\n        return result;\n    }\n    any(x, axes) {\n        assertNotComplex(x, 'any');\n        backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let anyVal = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                anyVal = anyVal || value;\n            }\n            vals[i] = anyVal;\n        }\n        return result;\n    }\n    squaredDifference(a, b) {\n        assertNotComplex([a, b], 'squaredDifference');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n            const diff = aVal - bVal;\n            return diff * diff;\n        });\n    }\n    ceil(x) {\n        assertNotComplex(x, 'ceil');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.ceil(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    floor(x) {\n        assertNotComplex(x, 'floor');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.floor(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    sign(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (values[i] < 0) {\n                newValues[i] = -1;\n            }\n            else if (values[i] > 0) {\n                newValues[i] = 1;\n            }\n            else {\n                newValues[i] = 0;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    isNaN(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (Number.isNaN(values[i])) {\n                newValues[i] = 1;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    isInf(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (Math.abs(values[i]) === Infinity) {\n                newValues[i] = 1;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    isFinite(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (Number.isFinite(values[i])) {\n                newValues[i] = 1;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    round(x) {\n        assertNotComplex(x, 'round');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            // The algorithm is based on banker's rounding.\n            const base = Math.floor(values[i]);\n            if (values[i] - base < 0.5) {\n                newValues[i] = Math.floor(values[i]);\n            }\n            else if (values[i] - base > 0.5) {\n                newValues[i] = Math.ceil(values[i]);\n            }\n            else {\n                if (base % 2.0 === 0.0) {\n                    newValues[i] = base;\n                }\n                else {\n                    newValues[i] = base + 1.0;\n                }\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    exp(x) {\n        assertNotComplex(x, 'exp');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.exp(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    expm1(x) {\n        assertNotComplex(x, 'expm1');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.expm1(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    log(x) {\n        assertNotComplex(x, 'log');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = Math.log(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    log1p(x) {\n        assertNotComplex(x, 'log1p');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = Math.log1p(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    sqrt(x) {\n        assertNotComplex(x, 'sqrt');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = Math.sqrt(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    rsqrt(x) {\n        assertNotComplex(x, 'rsqrt');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = 1 / Math.sqrt(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    reciprocal(x) {\n        assertNotComplex(x, 'reciprocal');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = 1 / values[i];\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    linear(x) {\n        return x;\n    }\n    relu(x) {\n        assertNotComplex(x, 'relu');\n        const res = tf.zeros(x.shape, x.dtype);\n        const resVals = this.readSync(res.dataId);\n        const inVals = this.readSync(x.dataId);\n        for (let i = 0; i < inVals.length; ++i) {\n            resVals[i] = Math.max(0, inVals[i]);\n        }\n        return res;\n    }\n    relu6(x) {\n        assertNotComplex(x, 'relu');\n        const res = tf.zeros(x.shape, x.dtype);\n        const resVals = this.readSync(res.dataId);\n        const inVals = this.readSync(x.dataId);\n        for (let i = 0; i < inVals.length; ++i) {\n            resVals[i] = Math.min(Math.max(0, inVals[i]), 6);\n        }\n        return res;\n    }\n    prelu(x, a) {\n        assertNotComplex([x, a], 'prelu');\n        return this.broadcastedBinaryOp(x, a, x.dtype, (xValue, aValue) => xValue < 0 ? aValue * xValue : xValue);\n    }\n    elu(x) {\n        assertNotComplex(x, 'elu');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            if (v >= 0) {\n                resultValues[i] = v;\n            }\n            else {\n                resultValues[i] = (Math.exp(v) - 1);\n            }\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    eluDer(dy, y) {\n        assertNotComplex([dy, y], 'eluDer');\n        const resultValues = new Float32Array(y.size);\n        const values = this.readSync(y.dataId);\n        const dyValues = this.readSync(dy.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            if (v >= 1) {\n                resultValues[i] = dyValues[i];\n            }\n            else {\n                resultValues[i] = dyValues[i] * (v + 1);\n            }\n        }\n        return this.makeOutput(resultValues, y.shape, 'float32');\n    }\n    selu(x) {\n        assertNotComplex(x, 'selu');\n        // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n        // see: https://arxiv.org/abs/1706.02515\n        const scaleAlpha = backend_util.SELU_SCALEALPHA;\n        const scale = backend_util.SELU_SCALE;\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            if (v >= 0) {\n                resultValues[i] = scale * v;\n            }\n            else {\n                resultValues[i] = scaleAlpha * (Math.exp(v) - 1);\n            }\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    clip(x, min, max) {\n        assertNotComplex(x, 'clip');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            resultValues[i] = v > max ? max : (v < min ? min : v);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    abs(x) {\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.abs(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    complexAbs(x) {\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < x.size; ++i) {\n            const real = values[i * 2];\n            const imag = values[i * 2 + 1];\n            resultValues[i] = Math.hypot(real, imag);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    int(x) {\n        assertNotComplex(x, 'int');\n        const resultValues = new Int32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = values[i];\n        }\n        return this.makeOutput(resultValues, x.shape, 'int32');\n    }\n    sigmoid(x) {\n        assertNotComplex(x, 'sigmoid');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = 1 / (1 + Math.exp(-values[i]));\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    softplus(x) {\n        assertNotComplex(x, 'softplus');\n        // mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n        // epsilon is the difference between 1.0 and the next representable float.\n        // For a single precision 32 bit float this should be 2^-23, see:\n        // https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\n        const epsilon = 1.1920928955078125e-7;\n        const threshold = Math.log(epsilon) + 2.0;\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            // Value above which exp(x) may overflow, but softplus(x) == x\n            // is within machine epsilon.\n            const tooLarge = values[i] > -threshold;\n            // Value below which exp(x) may underflow, but softplus(x) == exp(x)\n            // is within machine epsilon.\n            const tooSmall = values[i] < threshold;\n            const expX = Math.exp(values[i]);\n            let result;\n            if (tooSmall) {\n                result = expX;\n            }\n            else if (tooLarge) {\n                result = values[i];\n            }\n            else {\n                result = Math.log(1.0 + expX);\n            }\n            resultValues[i] = result;\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    sin(x) {\n        assertNotComplex(x, 'sin');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.sin(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    cos(x) {\n        assertNotComplex(x, 'cos');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.cos(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    tan(x) {\n        assertNotComplex(x, 'tan');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.tan(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    asin(x) {\n        assertNotComplex(x, 'asin');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.asin(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    acos(x) {\n        assertNotComplex(x, 'acos');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.acos(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    atan(x) {\n        assertNotComplex(x, 'atan');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.atan(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    atan2(a, b) {\n        assertNotComplex([a, b], 'atan2');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.atan2(aValue, bValue));\n    }\n    sinh(x) {\n        assertNotComplex(x, 'sinh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.sinh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    cosh(x) {\n        assertNotComplex(x, 'cosh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.cosh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    tanh(x) {\n        assertNotComplex(x, 'tanh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = util.tanh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    asinh(x) {\n        assertNotComplex(x, 'asinh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.asinh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    acosh(x) {\n        assertNotComplex(x, 'acosh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.acosh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    atanh(x) {\n        assertNotComplex(x, 'atanh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.atanh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    erf(x) {\n        assertNotComplex(x, 'erf');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        const p = backend_util.ERF_P;\n        const a1 = backend_util.ERF_A1;\n        const a2 = backend_util.ERF_A2;\n        const a3 = backend_util.ERF_A3;\n        const a4 = backend_util.ERF_A4;\n        const a5 = backend_util.ERF_A5;\n        for (let i = 0; i < values.length; ++i) {\n            const sign = Math.sign(values[i]);\n            const v = Math.abs(values[i]);\n            const t = 1.0 / (1.0 + p * v);\n            resultValues[i] = sign *\n                (1.0 -\n                    (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t *\n                        Math.exp(-v * v));\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    step(x, alpha = 0) {\n        assertNotComplex(x, 'step');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            if (isNaN(value)) {\n                resultValues[i] = NaN;\n            }\n            else {\n                resultValues[i] = value > 0 ? 1 : alpha;\n            }\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    fusedConv2d({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        let result = this.conv2d(input, filter, convInfo);\n        if (bias) {\n            result = this.add(result, bias);\n        }\n        if (activation) {\n            result =\n                mapActivation(this, result, activation, preluActivationWeights);\n        }\n        return result;\n    }\n    conv2d(x, filter, convInfo) {\n        assertNotComplex([x, filter], 'conv2d');\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const padLeft = convInfo.padInfo.left;\n        const padTop = convInfo.padInfo.top;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const y = tf.buffer(convInfo.outShape, x.dtype);\n        const xBatchStride = x.strides[0];\n        const xRowStride = isChannelsLast ? x.strides[1] : x.strides[2];\n        const xColStride = isChannelsLast ? x.strides[2] : 1;\n        const xChannelStride = isChannelsLast ? 1 : x.strides[1];\n        const yBatchStride = y.strides[0];\n        const yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];\n        const yColStride = isChannelsLast ? y.strides[2] : 1;\n        const yChannelStride = isChannelsLast ? 1 : y.strides[1];\n        const xVals = this.readSync(x.dataId);\n        const wVals = this.readSync(filter.dataId);\n        const yVals = y.values;\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            const xOffset1 = b * xBatchStride;\n            const yOffset1 = b * yBatchStride;\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const yOffset2 = yOffset1 + yR * yRowStride;\n                const xRCorner = yR * convInfo.strideHeight - padTop;\n                for (let wR = 0; wR < filterHeight; wR++) {\n                    const xR = xRCorner + wR * dilationHeight;\n                    if (xR < 0 || xR >= convInfo.inHeight) {\n                        continue;\n                    }\n                    const wOffset1 = wR * filter.strides[0];\n                    const xOffset2 = xOffset1 + xR * xRowStride;\n                    for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                        const yOffset3 = yOffset2 + yC * yColStride;\n                        const xCCorner = yC * convInfo.strideWidth - padLeft;\n                        for (let wC = 0; wC < filterWidth; wC++) {\n                            const xC = xCCorner + wC * dilationWidth;\n                            if (xC < 0 || xC >= convInfo.inWidth) {\n                                continue;\n                            }\n                            const wOffset2 = wOffset1 + wC * filter.strides[1];\n                            const xOffset3 = xOffset2 + xC * xColStride;\n                            let wOffset3 = wOffset2;\n                            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                                const xVal = xVals[xOffset3 + d1 * xChannelStride];\n                                for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                                    yVals[yOffset3 + d2 * yChannelStride] +=\n                                        xVal * wVals[wOffset3 + d2];\n                                }\n                                wOffset3 += convInfo.outChannels;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return y.toTensor();\n    }\n    conv3d(x, filter, convInfo) {\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const padFront = convInfo.padInfo.front;\n        const padLeft = convInfo.padInfo.left;\n        const padTop = convInfo.padInfo.top;\n        const y = tf.buffer(convInfo.outShape, x.dtype);\n        const xVals = this.readSync(x.dataId);\n        const wVals = this.readSync(filter.dataId);\n        const yVals = y.values;\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            const xOffset1 = b * x.strides[0];\n            const yOffset1 = b * y.strides[0];\n            for (let yF = 0; yF < convInfo.outDepth; ++yF) {\n                const yOffset2 = yOffset1 + yF * y.strides[1];\n                const xFCorner = yF * convInfo.strideDepth - padFront;\n                for (let wF = 0; wF < filterDepth; wF++) {\n                    const xF = xFCorner + wF * dilationDepth;\n                    if (xF < 0 || xF >= convInfo.inDepth) {\n                        continue;\n                    }\n                    const wOffset1 = wF * filter.strides[0];\n                    const xOffset2 = xOffset1 + xF * x.strides[1];\n                    for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                        const yOffset3 = yOffset2 + yR * y.strides[2];\n                        const xRCorner = yR * convInfo.strideHeight - padTop;\n                        for (let wR = 0; wR < filterHeight; wR++) {\n                            const xR = xRCorner + wR * dilationHeight;\n                            if (xR < 0 || xR >= convInfo.inHeight) {\n                                continue;\n                            }\n                            const wOffset2 = wOffset1 + wR * filter.strides[1];\n                            const xOffset3 = xOffset2 + xR * x.strides[2];\n                            for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                                const yOffset4 = yOffset3 + yC * convInfo.outChannels;\n                                const xCCorner = yC * convInfo.strideWidth - padLeft;\n                                for (let wC = 0; wC < filterWidth; wC++) {\n                                    const xC = xCCorner + wC * dilationWidth;\n                                    if (xC < 0 || xC >= convInfo.inWidth) {\n                                        continue;\n                                    }\n                                    const wOffset3 = wOffset2 + wC * filter.strides[2];\n                                    const xOffset4 = xOffset3 + xC * convInfo.inChannels;\n                                    let wOffset4 = wOffset3;\n                                    for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                                        const xVal = xVals[xOffset4 + d1];\n                                        for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                                            yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];\n                                        }\n                                        wOffset4 += convInfo.outChannels;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return y.toTensor();\n    }\n    conv2dDerInput(dy, filter, convInfo) {\n        assertNotComplex([dy, filter], 'conv2dDerInput');\n        const dx = tf.buffer(convInfo.inShape, 'float32');\n        const dxValues = dx.values;\n        const dyValues = this.readSync(dy.dataId);\n        const fltValues = this.readSync(filter.dataId);\n        const [fltS0, fltS1, fltS2] = filter.strides;\n        const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth, dataFormat } = convInfo;\n        const topPad = filterHeight - 1 - convInfo.padInfo.top;\n        const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n        const isChannelsLast = dataFormat === 'channelsLast';\n        const xBatchStride = dx.strides[0];\n        const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];\n        const xColStride = isChannelsLast ? dx.strides[2] : 1;\n        const xChannelStride = isChannelsLast ? 1 : dx.strides[1];\n        const yBatchStride = dy.strides[0];\n        const yRowStride = isChannelsLast ? dy.strides[1] : dy.strides[2];\n        const yColStride = isChannelsLast ? dy.strides[2] : 1;\n        const yChannelStride = isChannelsLast ? 1 : dy.strides[1];\n        for (let b = 0; b < batchSize; ++b) {\n            for (let d1 = 0; d1 < inChannels; ++d1) {\n                for (let xR = 0; xR < inHeight; ++xR) {\n                    const xRCorner = xR - topPad;\n                    const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                    const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                    for (let xC = 0; xC < inWidth; ++xC) {\n                        const xCCorner = xC - leftPad;\n                        const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                        const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                        let dotProd = 0;\n                        for (let yR = xRMin; yR < yRMax; ++yR) {\n                            const wR = yR * strideHeight - xRCorner;\n                            for (let yC = xCMin; yC < yCMax; ++yC) {\n                                const wC = yC * strideWidth - xCCorner;\n                                const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;\n                                const fltOffset = fltS0 * (filterHeight - 1 - wR) +\n                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n                                for (let d2 = 0; d2 < outChannels; ++d2) {\n                                    const pixel = dyValues[dyOffset + yChannelStride * d2];\n                                    const weight = fltValues[fltOffset + d2];\n                                    dotProd += pixel * weight;\n                                }\n                            }\n                        }\n                        const dxOffset = xBatchStride * b + xRowStride * xR +\n                            xColStride * xC + xChannelStride * d1;\n                        dxValues[dxOffset] = dotProd;\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    conv3dDerInput(dy, filter, convInfo) {\n        const dx = tf.buffer(convInfo.inShape, 'float32');\n        const dxValues = dx.values;\n        const [dxS0, dxS1, dxS2, dxS3] = dx.strides;\n        const dyValues = this.readSync(dy.dataId);\n        const [dyS0, dyS1, dyS2, dyS3] = dy.strides;\n        const fltValues = this.readSync(filter.dataId);\n        const [fltS0, fltS1, fltS2, fltS3] = filter.strides;\n        const { batchSize, filterDepth, filterHeight, filterWidth, inChannels, inDepth, inHeight, inWidth, outChannels, outDepth, outHeight, outWidth, strideDepth, strideHeight, strideWidth } = convInfo;\n        const frontPad = filterDepth - 1 - convInfo.padInfo.front;\n        const topPad = filterHeight - 1 - convInfo.padInfo.top;\n        const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n        for (let b = 0; b < batchSize; ++b) {\n            for (let d1 = 0; d1 < inChannels; ++d1) {\n                // Frames of depth\n                for (let xF = 0; xF < inDepth; ++xF) {\n                    const xFCorner = xF - frontPad;\n                    const xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));\n                    const yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);\n                    // Rows as per standard 2d matrix notation\n                    for (let xR = 0; xR < inHeight; ++xR) {\n                        const xRCorner = xR - topPad;\n                        const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                        const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                        // Columns as per standard 2d matrix notation\n                        for (let xC = 0; xC < inWidth; ++xC) {\n                            const xCCorner = xC - leftPad;\n                            const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                            const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                            let dotProd = 0;\n                            for (let yF = xFMin; yF < yFMax; ++yF) {\n                                const wF = yF * strideDepth - xFCorner;\n                                for (let yR = xRMin; yR < yRMax; ++yR) {\n                                    const wR = yR * strideHeight - xRCorner;\n                                    for (let yC = xCMin; yC < yCMax; ++yC) {\n                                        const wC = yC * strideWidth - xCCorner;\n                                        const dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;\n                                        const fltOffset = fltS0 * (filterDepth - 1 - wF) +\n                                            fltS1 * (filterHeight - 1 - wR) +\n                                            fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;\n                                        for (let d2 = 0; d2 < outChannels; ++d2) {\n                                            const pixel = dyValues[dyOffset + d2];\n                                            const weight = fltValues[fltOffset + d2];\n                                            dotProd += pixel * weight;\n                                        }\n                                    }\n                                }\n                            }\n                            dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] =\n                                dotProd;\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    conv2dDerFilter(x, dy, convInfo) {\n        assertNotComplex([x, dy], 'conv2dDerFilter');\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const dW = tf.buffer(convInfo.filterShape, 'float32');\n        const leftPad = convInfo.padInfo.left;\n        const topPad = convInfo.padInfo.top;\n        const xBuf = this.bufferSync(x);\n        const dyBuf = this.bufferSync(dy);\n        for (let wR = 0; wR < filterHeight; ++wR) {\n            const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n            const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n            for (let wC = 0; wC < filterWidth; ++wC) {\n                const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n                for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                    for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                        // Need to convolve.\n                        let dotProd = 0;\n                        for (let b = 0; b < convInfo.batchSize; ++b) {\n                            for (let yR = yRMin; yR < yRMax; ++yR) {\n                                const xR = wR + yR * strideHeight - topPad;\n                                for (let yC = yCMin; yC < yCMax; ++yC) {\n                                    const xC = wC + yC * strideWidth - leftPad;\n                                    if (isChannelsLast) {\n                                        dotProd +=\n                                            xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);\n                                    }\n                                    else {\n                                        dotProd +=\n                                            xBuf.get(b, d1, xR, xC) * dyBuf.get(b, d2, yR, yC);\n                                    }\n                                }\n                            }\n                        }\n                        dW.set(dotProd, wR, wC, d1, d2);\n                    }\n                }\n            }\n        }\n        return dW.toTensor();\n    }\n    conv3dDerFilter(x, dy, convInfo) {\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dw = tf.buffer(convInfo.filterShape, 'float32');\n        const dwValues = dw.values;\n        const [dwS0, dwS1, dwS2, dwS3] = dw.strides;\n        const dyValues = this.readSync(dy.dataId);\n        const [dyS0, dyS1, dyS2, dyS3] = dy.strides;\n        const xValues = this.readSync(x.dataId);\n        const [xS0, xS1, xS2, xS3] = x.strides;\n        const frontPad = convInfo.padInfo.front;\n        const leftPad = convInfo.padInfo.left;\n        const topPad = convInfo.padInfo.top;\n        for (let wF = 0; wF < filterDepth; ++wF) {\n            const yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));\n            const yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);\n            const wOffset1 = wF * dwS0;\n            for (let wR = 0; wR < filterHeight; ++wR) {\n                const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n                const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n                const wOffset2 = wR * dwS1 + wOffset1;\n                for (let wC = 0; wC < filterWidth; ++wC) {\n                    const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                    const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n                    const wOffset3 = wC * dwS2 + wOffset2;\n                    for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                        const wOffset4 = d1 * dwS3 + wOffset3;\n                        for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                            let dotProd = 0;\n                            for (let b = 0; b < convInfo.batchSize; ++b) {\n                                const xOffset1 = b * xS0;\n                                const yOffset1 = b * dyS0;\n                                for (let yF = yFMin; yF < yFMax; ++yF) {\n                                    const xF = wF + yF * strideDepth - frontPad;\n                                    const xOffset2 = xF * xS1 + xOffset1;\n                                    const yOffset2 = yF * dyS1 + yOffset1;\n                                    for (let yR = yRMin; yR < yRMax; ++yR) {\n                                        const xR = wR + yR * strideHeight - topPad;\n                                        const xOffset3 = xR * xS2 + xOffset2;\n                                        const yOffset3 = yR * dyS2 + yOffset2;\n                                        for (let yC = yCMin; yC < yCMax; ++yC) {\n                                            const xC = wC + yC * strideWidth - leftPad;\n                                            const xOffset4 = xC * xS3 + xOffset3;\n                                            const yOffset4 = yC * dyS3 + yOffset3;\n                                            dotProd +=\n                                                xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];\n                                        }\n                                    }\n                                }\n                            }\n                            dwValues[wOffset4 + d2] = dotProd;\n                        }\n                    }\n                }\n            }\n        }\n        return dw.toTensor();\n    }\n    fusedDepthwiseConv2D({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        let result = this.depthwiseConv2D(input, filter, convInfo);\n        if (bias) {\n            result = this.add(result, bias);\n        }\n        if (activation) {\n            result =\n                mapActivation(this, result, activation, preluActivationWeights);\n        }\n        return result;\n    }\n    depthwiseConv2D(x, filter, convInfo) {\n        assertNotComplex([x, filter], 'depthwiseConv2D');\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const padLeft = convInfo.padInfo.left;\n        const padTop = convInfo.padInfo.top;\n        const chMul = convInfo.outChannels / convInfo.inChannels;\n        const y = tf.buffer(convInfo.outShape, x.dtype);\n        const xVals = this.readSync(x.dataId);\n        const wVals = this.readSync(filter.dataId);\n        const yVals = y.values;\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            const xOffset1 = b * x.strides[0];\n            const yOffset1 = b * y.strides[0];\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const yOffset2 = yOffset1 + yR * y.strides[1];\n                const xRCorner = yR * convInfo.strideHeight - padLeft;\n                for (let wR = 0; wR < filterHeight; ++wR) {\n                    const xR = xRCorner + wR * dilationHeight;\n                    if (xR < 0 || xR >= convInfo.inHeight) {\n                        continue;\n                    }\n                    const wOffset1 = wR * filter.strides[0];\n                    const xOffset2 = xOffset1 + xR * x.strides[1];\n                    for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                        const yOffset3 = yOffset2 + yC * y.strides[2];\n                        const xCCorner = yC * convInfo.strideWidth - padTop;\n                        for (let wC = 0; wC < filterWidth; ++wC) {\n                            const xC = xCCorner + wC * dilationWidth;\n                            if (xC < 0 || xC >= convInfo.inWidth) {\n                                continue;\n                            }\n                            const wOffset2 = wOffset1 + wC * filter.strides[1];\n                            const xOffset3 = xOffset2 + xC * convInfo.inChannels;\n                            let yOffset4 = yOffset3;\n                            let wOffset3 = wOffset2;\n                            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                                const xVal = xVals[xOffset3 + d1];\n                                for (let q = 0; q < chMul; ++q) {\n                                    yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];\n                                }\n                                yOffset4 += chMul;\n                                wOffset3 += chMul;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return y.toTensor();\n    }\n    depthwiseConv2DDerInput(dy, filter, convInfo) {\n        assertNotComplex([dy, filter], 'depthwiseConv2DDerInput');\n        const dx = tf.buffer(convInfo.inShape, 'float32');\n        const dxValues = dx.values;\n        const [dxS0, dxS1, dxS2] = dx.strides;\n        const dyValues = this.readSync(dy.dataId);\n        const [dyS0, dyS1, dyS2] = dy.strides;\n        const fltValues = this.readSync(filter.dataId);\n        const [fltS0, fltS1, fltS2] = filter.strides;\n        const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;\n        const topPad = filterHeight - 1 - convInfo.padInfo.top;\n        const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n        const chMul = outChannels / inChannels;\n        for (let b = 0; b < batchSize; ++b) {\n            for (let d1 = 0; d1 < inChannels; ++d1) {\n                for (let xR = 0; xR < inHeight; ++xR) {\n                    const xRCorner = xR - topPad;\n                    const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                    const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                    for (let xC = 0; xC < inWidth; ++xC) {\n                        const xCCorner = xC - leftPad;\n                        const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                        const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                        let dotProd = 0;\n                        for (let yR = xRMin; yR < yRMax; ++yR) {\n                            const wR = yR * strideHeight - xRCorner;\n                            for (let yC = xCMin; yC < yCMax; ++yC) {\n                                const wC = yC * strideWidth - xCCorner;\n                                const dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;\n                                const fltOffset = fltS0 * (filterHeight - 1 - wR) +\n                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n                                for (let dm = 0; dm < chMul; ++dm) {\n                                    const d2 = d1 * chMul + dm;\n                                    const pixel = dyValues[dyOffset + d2];\n                                    const weight = fltValues[fltOffset + dm];\n                                    dotProd += pixel * weight;\n                                }\n                            }\n                        }\n                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    depthwiseConv2DDerFilter(x, dy, convInfo) {\n        assertNotComplex([x, dy], 'depthwiseConv2DDerFilter');\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dW = tf.buffer(convInfo.filterShape, 'float32');\n        const leftPad = convInfo.padInfo.left;\n        const topPad = convInfo.padInfo.top;\n        const chMul = convInfo.outChannels / convInfo.inChannels;\n        const xBuf = this.bufferSync(x);\n        const dyBuf = this.bufferSync(dy);\n        for (let wR = 0; wR < filterHeight; ++wR) {\n            const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n            const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n            for (let wC = 0; wC < filterWidth; ++wC) {\n                const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n                for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                    const d1 = Math.trunc(d2 / chMul);\n                    const dm = d2 % chMul;\n                    let dotProd = 0;\n                    for (let b = 0; b < convInfo.batchSize; ++b) {\n                        for (let yR = yRMin; yR < yRMax; ++yR) {\n                            const xR = wR + yR * strideHeight - topPad;\n                            for (let yC = yCMin; yC < yCMax; ++yC) {\n                                const xC = wC + yC * strideWidth - leftPad;\n                                dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);\n                            }\n                        }\n                    }\n                    dW.set(dotProd, wR, wC, d1, dm);\n                }\n            }\n        }\n        return dW.toTensor();\n    }\n    tile(x, reps) {\n        assertNotComplex(x, 'tile');\n        return tile(this.bufferSync(x), reps);\n    }\n    pad(x, paddings, constantValue) {\n        assertNotComplex(x, 'pad');\n        const outShape = paddings.map((p, i) => p[0] /* beforePad */ + x.shape[i] + p[1] /* afterPad */);\n        const start = paddings.map(p => p[0]);\n        const xBuffer = this.bufferSync(x);\n        const buffer = tf.buffer(outShape, x.dtype);\n        if (constantValue !== 0) {\n            buffer.values.fill(constantValue);\n        }\n        for (let i = 0; i < x.size; i++) {\n            const coords = xBuffer.indexToLoc(i);\n            const outCoords = coords.map((c, i) => c + start[i]);\n            buffer.set(xBuffer.get(...coords), ...outCoords);\n        }\n        return buffer.toTensor();\n    }\n    gather(x, indices, axis) {\n        assertNotComplex([x, indices], 'gather');\n        const newShape = x.shape.slice();\n        const indicesValues = this.readSync(indices.dataId);\n        newShape[axis] = indicesValues.length;\n        const result = tf.buffer(newShape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < result.size; ++i) {\n            const newLoc = result.indexToLoc(i);\n            const originalLoc = newLoc.slice();\n            originalLoc[axis] = indicesValues[newLoc[axis]];\n            const originalIndex = xBuf.locToIndex(originalLoc);\n            result.values[i] = xBuf.values[originalIndex];\n        }\n        return result.toTensor();\n    }\n    batchToSpaceND(x, blockShape, crops) {\n        assertNotComplex([x], 'batchToSpaceND');\n        const prod = blockShape.reduce((a, b) => a * b);\n        const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n        const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n        const reshapedPermuted = backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n        const sliceBeginCoords = backend_util.getSliceBeginCoords(crops, blockShape.length);\n        const sliceSize = backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n        return tf.transpose(x.reshape(reshaped), permuted)\n            .reshape(reshapedPermuted)\n            .slice(sliceBeginCoords, sliceSize);\n    }\n    spaceToBatchND(x, blockShape, paddings) {\n        assertNotComplex([x], 'spaceToBatchND');\n        const prod = blockShape.reduce((a, b) => a * b);\n        const completePaddings = [[0, 0]];\n        completePaddings.push(...paddings);\n        for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n            completePaddings.push([0, 0]);\n        }\n        const paddedX = x.pad(completePaddings);\n        const reshapedPaddedShape = backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n        const permutedReshapedPaddedPermutation = backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);\n        const flattenShape = backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n        return tf.transpose(paddedX.reshape(reshapedPaddedShape), permutedReshapedPaddedPermutation)\n            .reshape(flattenShape);\n    }\n    maxPool(x, convInfo) {\n        assertNotComplex(x, 'maxPool');\n        const xValues = this.readSync(x.dataId);\n        return pool(xValues, x.shape, x.dtype, x.strides, convInfo, 'max')\n            .toTensor();\n    }\n    maxPoolBackprop(dy, x, y, convInfo) {\n        assertNotComplex([x, y], 'maxPoolBackprop');\n        const xValues = this.readSync(x.dataId);\n        const maxPosBuf = buffer(convInfo.outShape, x.dtype, maxPoolPositions(xValues, x.shape, x.dtype, convInfo).values);\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const dyBuf = this.bufferSync(dy);\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            for (let d = 0; d < convInfo.inChannels; ++d) {\n                for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n                    for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n                        // Shader code begins.\n                        const dyRCorner = dxR - padTop;\n                        const dyCCorner = dxC - padLeft;\n                        let dotProd = 0;\n                        for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                            const dyR = (dyRCorner + wR) / strideHeight;\n                            if (dyR < 0 || dyR >= convInfo.outHeight ||\n                                Math.floor(dyR) !== dyR) {\n                                continue;\n                            }\n                            for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                                const dyC = (dyCCorner + wC) / strideWidth;\n                                if (dyC < 0 || dyC >= convInfo.outWidth ||\n                                    Math.floor(dyC) !== dyC) {\n                                    continue;\n                                }\n                                const maxPos = effectiveFilterHeight * effectiveFilterWidth -\n                                    1 - maxPosBuf.get(b, dyR, dyC, d);\n                                const curPos = wR * effectiveFilterWidth + wC;\n                                const mask = maxPos === curPos ? 1 : 0;\n                                if (mask === 0) {\n                                    continue;\n                                }\n                                const pixel = dyBuf.get(b, dyR, dyC, d);\n                                dotProd += pixel * mask;\n                            }\n                        }\n                        dx.set(dotProd, b, dxR, dxC, d);\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    avgPoolBackprop(dy, x, convInfo) {\n        assertNotComplex([dy, x], 'avgPoolBackprop');\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const avgMultiplier = 1 / (filterHeight * filterWidth);\n        const dyBuf = this.bufferSync(dy);\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            for (let d = 0; d < convInfo.inChannels; ++d) {\n                for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n                    for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n                        // Shader code begins.\n                        const dyRCorner = dxR - padTop;\n                        const dyCCorner = dxC - padLeft;\n                        let dotProd = 0;\n                        for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                            const dyR = (dyRCorner + wR) / strideHeight;\n                            if (dyR < 0 || dyR >= convInfo.outHeight ||\n                                Math.floor(dyR) !== dyR) {\n                                continue;\n                            }\n                            for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                                const dyC = (dyCCorner + wC) / strideWidth;\n                                if (dyC < 0 || dyC >= convInfo.outWidth ||\n                                    Math.floor(dyC) !== dyC) {\n                                    continue;\n                                }\n                                const pixel = dyBuf.get(b, dyR, dyC, d);\n                                dotProd += pixel;\n                            }\n                        }\n                        dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    pool3d(x, convInfo, poolType) {\n        assertNotComplex(x, 'pool3d');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n            Number.POSITIVE_INFINITY);\n        const xValues = this.readSync(x.dataId);\n        const output = tf.buffer(convInfo.outShape, x.dtype);\n        const outputVals = output.values;\n        const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n            convInfo.outShape[3] * convInfo.outShape[4];\n        const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n        const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n        const outputColStrides = convInfo.outShape[4];\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            const outputBatchOffset = batch * outputBatchStrides;\n            const inputBatchOffset = batch * x.strides[0];\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                    const xDepthCorner = yDepth * strideDepth - padFront;\n                    let xDepthMin = xDepthCorner;\n                    while (xDepthMin < 0) {\n                        xDepthMin += dilationDepth;\n                    }\n                    const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                    const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n                    for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                        const xRowCorner = yRow * strideHeight - padTop;\n                        let xRowMin = xRowCorner;\n                        while (xRowMin < 0) {\n                            xRowMin += dilationHeight;\n                        }\n                        const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                        const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n                        for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                            const xColCorner = yCol * strideWidth - padLeft;\n                            let xColMin = xColCorner;\n                            while (xColMin < 0) {\n                                xColMin += dilationWidth;\n                            }\n                            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                            // Shader code begins\n                            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n                            let minMaxValue = initialValue;\n                            let avgValue = 0;\n                            let count = 0;\n                            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                                const xDepthOffset = inputBatchOffset + xDepth * x.strides[1];\n                                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                    const xRowOffset = xDepthOffset + xRow * x.strides[2];\n                                    for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                        const xColOffset = xRowOffset + xCol * x.strides[3];\n                                        const pixel = xValues[xColOffset + channel];\n                                        if ((poolType === 'max' && pixel > minMaxValue)) {\n                                            minMaxValue = pixel;\n                                        }\n                                        else if (poolType === 'avg') {\n                                            avgValue += pixel;\n                                            count++;\n                                        }\n                                        if (isNaN(minMaxValue)) {\n                                            break;\n                                        }\n                                    }\n                                    if (isNaN(minMaxValue)) {\n                                        break;\n                                    }\n                                }\n                                if (isNaN(minMaxValue)) {\n                                    break;\n                                }\n                            }\n                            const outputOffset = outputColOffset + channel;\n                            outputVals[outputOffset] =\n                                poolType === 'avg' ? avgValue / count : minMaxValue;\n                        }\n                    }\n                }\n            }\n        }\n        return output.toTensor();\n    }\n    avgPool3d(x, convInfo) {\n        assertNotComplex(x, 'avgPool3d');\n        return this.pool3d(x, convInfo, 'avg').toFloat();\n    }\n    avgPool3dBackprop(dy, x, convInfo) {\n        assertNotComplex([dy, x], 'avgPool3dBackprop');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n        const dyBuf = this.bufferSync(dy);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                    for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                        for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                            // Shader code begins.\n                            const dyDepthCorner = dxDepth - padFront;\n                            const dyRowCorner = dxRow - padTop;\n                            const dyColCorner = dxCol - padLeft;\n                            let dotProd = 0;\n                            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                                if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                    Math.floor(dyDepth) !== dyDepth) {\n                                    continue;\n                                }\n                                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                    const dyRow = (dyRowCorner + wRow) / strideHeight;\n                                    if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                        Math.floor(dyRow) !== dyRow) {\n                                        continue;\n                                    }\n                                    for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                        const dyCol = (dyColCorner + wCol) / strideWidth;\n                                        if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                            Math.floor(dyCol) !== dyCol) {\n                                            continue;\n                                        }\n                                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        dotProd += pixel;\n                                    }\n                                }\n                            }\n                            dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    maxPool3d(x, convInfo) {\n        assertNotComplex(x, 'maxPool3d');\n        return this.pool3d(x, convInfo, 'max').toFloat();\n    }\n    maxPool3dPositions(x, convInfo) {\n        const maxPositions = tf.buffer(convInfo.outShape, 'int32');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const xBuf = this.bufferSync(x);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                    const xDepthCorner = yDepth * strideDepth - padFront;\n                    let xDepthMin = xDepthCorner;\n                    while (xDepthMin < 0) {\n                        xDepthMin += dilationDepth;\n                    }\n                    const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                    for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                        const xRowCorner = yRow * strideHeight - padTop;\n                        let xRowMin = xRowCorner;\n                        while (xRowMin < 0) {\n                            xRowMin += dilationHeight;\n                        }\n                        const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                        for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                            const xColCorner = yCol * strideWidth - padLeft;\n                            let xColMin = xColCorner;\n                            while (xColMin < 0) {\n                                xColMin += dilationWidth;\n                            }\n                            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                            // Shader code begins\n                            let maxValue = Number.NEGATIVE_INFINITY;\n                            let maxPosition = -1;\n                            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                                const wDepth = xDepth - xDepthCorner;\n                                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                    const wRow = xRow - xRowCorner;\n                                    for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                        const wCol = xCol - xColCorner;\n                                        const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                                        if (pixel >= maxValue) {\n                                            maxValue = pixel;\n                                            maxPosition = wDepth * effectiveFilterHeight *\n                                                effectiveFilterWidth +\n                                                wRow * effectiveFilterHeight + wCol;\n                                        }\n                                    }\n                                }\n                            }\n                            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return maxPositions.toTensor();\n    }\n    maxPool3dBackprop(dy, x, y, convInfo) {\n        assertNotComplex([x, y], 'maxPool3dBackprop');\n        const maxPositions = this.maxPool3dPositions(x, convInfo);\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const maxPosBuf = this.bufferSync(maxPositions);\n        const dyBuf = this.bufferSync(dy);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                    for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                        for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                            // Shader code begins\n                            const dyDepthCorner = dxDepth - padFront;\n                            const dyRowCorner = dxRow - padTop;\n                            const dyColCorner = dxCol - padLeft;\n                            let dotProd = 0;\n                            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                                if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                    Math.floor(dyDepth) !== dyDepth) {\n                                    continue;\n                                }\n                                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                    const dyRow = (dyRowCorner + wRow) / strideHeight;\n                                    if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                        Math.floor(dyRow) !== dyRow) {\n                                        continue;\n                                    }\n                                    for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                        const dyCol = (dyColCorner + wCol) / strideWidth;\n                                        if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                            Math.floor(dyCol) !== dyCol) {\n                                            continue;\n                                        }\n                                        const maxPos = effectiveFilterDepth *\n                                            effectiveFilterHeight * effectiveFilterWidth -\n                                            1 -\n                                            maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                            wRow * effectiveFilterWidth + wCol;\n                                        const mask = maxPos === curPos ? 1 : 0;\n                                        if (mask === 0) {\n                                            continue;\n                                        }\n                                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        dotProd += pixel * mask;\n                                    }\n                                }\n                            }\n                            dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    cast(x, dtype) {\n        return backend_util.castTensor(x, dtype, this);\n    }\n    reshape(x, shape) {\n        return backend_util.reshapeTensor(x, shape);\n    }\n    avgPool(x, convInfo) {\n        assertNotComplex(x, 'avgPool');\n        assertNotComplex(x, 'maxPool');\n        const xValues = this.readSync(x.dataId);\n        return pool(xValues, x.shape, x.dtype, x.strides, convInfo, 'avg')\n            .toTensor()\n            .toFloat();\n    }\n    resizeBilinear(x, newHeight, newWidth, alignCorners) {\n        assertNotComplex(x, 'resizeBilinear');\n        const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n        const xValues = this.readSync(x.dataId);\n        const result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n        const effectiveInputSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutputSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        let outputIdx = 0;\n        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n        for (let b = 0; b < batch; b++) {\n            for (let r = 0; r < newHeight; r++) {\n                const sourceFracRow = effectiveRowSizeRatio * r;\n                const sourceRowFloor = Math.floor(sourceFracRow);\n                const rowFrac = sourceFracRow - sourceRowFloor;\n                const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n                const topRowOffset = b * x.strides[0] + sourceRowFloor * x.strides[1];\n                const botRowOffset = b * x.strides[0] + sourceRowCeil * x.strides[1];\n                for (let c = 0; c < newWidth; c++) {\n                    const sourceFracCol = effectiveColSizeRatio * c;\n                    const sourceColFloor = Math.floor(sourceFracCol);\n                    const colFrac = sourceFracCol - sourceColFloor;\n                    const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n                    const topLeftOffest = topRowOffset + sourceColFloor * x.strides[2];\n                    const botLeftOffset = botRowOffset + sourceColFloor * x.strides[2];\n                    const topRightOffset = topRowOffset + sourceColCeil * x.strides[2];\n                    const botRightOffest = botRowOffset + sourceColCeil * x.strides[2];\n                    for (let d = 0; d < numChannels; d++) {\n                        // Begin shader.\n                        // Compute the fractional index of the source.\n                        const topLeft = xValues[topLeftOffest + d];\n                        const bottomLeft = xValues[botLeftOffset + d];\n                        const topRight = xValues[topRightOffset + d];\n                        const bottomRight = xValues[botRightOffest + d];\n                        const top = topLeft + (topRight - topLeft) * colFrac;\n                        const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n                        const newValue = top + (bottom - top) * rowFrac;\n                        result[outputIdx++] = newValue;\n                    }\n                }\n            }\n        }\n        return tf.tensor(result, [batch, newHeight, newWidth, numChannels]);\n    }\n    resizeBilinearBackprop(dy, x, alignCorners) {\n        assertNotComplex([dy, x], 'resizeBilinearBackprop');\n        const [batch, xHeight, xWidth, depth] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        const output = new Float32Array(batch * xHeight * xWidth * depth);\n        // In the backwards pass, we want to find the pixels that were generated\n        // for each pixel in the input image the forward pass and add the\n        // corresponding coefficient from dy to the gradient (with some\n        // interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n        const dyValues = this.readSync(dy.dataId);\n        let offset = 0;\n        for (let b = 0; b < batch; b++) {\n            const bOffset = b * x.strides[0];\n            for (let r = 0; r < yHeight; r++) {\n                const dxR = r * heightScale;\n                const topDxRIndex = Math.floor(dxR);\n                const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n                const topDxROffset = bOffset + topDxRIndex * x.strides[1];\n                const bottomDxROffset = bOffset + bottomDxRIndex * x.strides[1];\n                const dxRLerp = dxR - topDxRIndex;\n                const inverseDxRLerp = 1.0 - dxRLerp;\n                for (let c = 0; c < yWidth; c++) {\n                    const dxC = c * widthScale;\n                    const leftDxCIndex = Math.floor(dxC);\n                    const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n                    const dxCLerp = dxC - leftDxCIndex;\n                    const inverseDxCLerp = 1.0 - dxCLerp;\n                    const topLeftRCOffset = topDxROffset + leftDxCIndex * x.strides[2];\n                    const topRightRCOffset = topDxROffset + rightDxCIndex * x.strides[2];\n                    const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * x.strides[2];\n                    const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * x.strides[2];\n                    const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n                    const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n                    const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n                    const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n                    for (let d = 0; d < depth; d++) {\n                        const dyVal = dyValues[offset++];\n                        output[topLeftRCOffset + d] +=\n                            dyVal * inverseDxRLerpTimesInverseDxCLerp;\n                        output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n                        output[bottomLeftRCOffset + d] +=\n                            dyVal * dxRLerpTimesInverseDxCLerp;\n                        output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(output, [batch, xWidth, xHeight, depth], x.dtype);\n    }\n    resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {\n        assertNotComplex(x, 'resizeNearestNeighbor');\n        const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n        const xValues = this.readSync(x.dataId);\n        const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n        const effectiveInputSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutputSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n        let outputOffset = 0;\n        for (let b = 0; b < batch; b++) {\n            const batchOffset = b * x.strides[0];\n            for (let r = 0; r < newHeight; r++) {\n                const sourceFracRow = effectiveRowSizeRatio * r;\n                const sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                    Math.floor(sourceFracRow));\n                const rowOffset = batchOffset + sourceNearestRow * x.strides[1];\n                for (let c = 0; c < newWidth; c++) {\n                    const sourceFracCol = effectiveColSizeRatio * c;\n                    const sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                        Math.floor(sourceFracCol));\n                    const colOffset = rowOffset + sourceNearestCol * x.strides[2];\n                    for (let d = 0; d < numChannels; d++) {\n                        // Begin shader.\n                        // Compute the fractional index of the source.\n                        const newVal = xValues[colOffset + d];\n                        output[outputOffset++] = newVal;\n                    }\n                }\n            }\n        }\n        return tf.tensor(output, [batch, newHeight, newWidth, numChannels], x.dtype);\n    }\n    resizeNearestNeighborBackprop(dy, x, alignCorners) {\n        assertNotComplex([dy, x], 'resizeNearestNeighborBackprop');\n        const [batch, xHeight, xWidth, depth] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        const output = new Float32Array(batch * xHeight * xWidth * depth);\n        const dyValues = this.readSync(dy.dataId);\n        // In the backwards pass, we want to find the pixels that were generated\n        // for each pixel in the input image the forward pass\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        // Loop over the output space.\n        for (let b = 0; b < batch; b++) {\n            const batchOffset = b * x.strides[0];\n            for (let r = 0; r < xHeight; r++) {\n                const rowOffset = batchOffset + r * x.strides[1];\n                // Compute bounds for where in dy we will look\n                const startRLerp = Math.floor(r * invHeightScale);\n                const startDyR = Math.floor(startRLerp - (winHeight / 2));\n                for (let c = 0; c < xWidth; c++) {\n                    const colOffset = rowOffset + c * x.strides[2];\n                    // Compute bounds for where in dy we will look\n                    const startCLerp = Math.floor(c * invWidthScale);\n                    const startDyC = Math.floor(startCLerp - (winWidth / 2));\n                    for (let d = 0; d < depth; d++) {\n                        let accum = 0;\n                        // loop over dy\n                        for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n                            const dyR = dyRIndex + startDyR;\n                            // Guard against the window exceeding the bounds of dy\n                            if (dyR < 0 || dyR >= yHeight) {\n                                continue;\n                            }\n                            const dyROffset = batchOffset + dyR * dy.strides[1];\n                            const sourceFracRow = dyR * heightScale;\n                            const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                                Math.floor(sourceFracRow));\n                            if (r !== sourceNearestRow) {\n                                continue;\n                            }\n                            for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n                                const dyC = dyCIndex + startDyC;\n                                // Guard against the window exceeding the bounds of dy\n                                if (dyC < 0 || dyC >= yWidth) {\n                                    continue;\n                                }\n                                const dyCOffset = dyROffset + dyC * dy.strides[2];\n                                const sourceFracCol = dyC * widthScale;\n                                const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                                    Math.floor(sourceFracCol));\n                                if (c === sourceNearestCol) {\n                                    accum += dyValues[dyCOffset + d];\n                                }\n                            }\n                        }\n                        output[colOffset + d] = accum;\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(output, x.shape, x.dtype);\n    }\n    batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {\n        assertNotComplex([x, mean, variance, scale, offset], 'batchNorm');\n        const xVals = this.readSync(x.dataId);\n        const mVals = this.readSync(mean.dataId);\n        const varVals = this.readSync(variance.dataId);\n        const sVals = scale ? this.readSync(scale.dataId) :\n            new Float32Array([1]);\n        const offVals = offset ? this.readSync(offset.dataId) :\n            new Float32Array([0]);\n        const outVals = new Float32Array(xVals.length);\n        const offValsLength = offVals.length;\n        const sValsLength = sVals.length;\n        const varValsLength = varVals.length;\n        const mValsLength = mVals.length;\n        let offi = 0;\n        let mi = 0;\n        let si = 0;\n        let vi = 0;\n        for (let i = 0; i < xVals.length; ++i) {\n            outVals[i] = offVals[offi++] +\n                (xVals[i] - mVals[mi++]) * sVals[si++] /\n                    Math.sqrt(varVals[vi++] + varianceEpsilon);\n            if (offi >= offValsLength) {\n                offi = 0;\n            }\n            if (mi >= mValsLength) {\n                mi = 0;\n            }\n            if (si >= sValsLength) {\n                si = 0;\n            }\n            if (vi >= varValsLength) {\n                vi = 0;\n            }\n        }\n        return tf.tensor4d(outVals, x.shape);\n    }\n    localResponseNormalization4D(x, depthRadius, bias, alpha, beta) {\n        assertNotComplex(x, 'localResponseNormalization4D');\n        const channels = x.shape[3];\n        const maxD = channels - 1;\n        const xValues = this.readSync(x.dataId);\n        const size = x.size;\n        const result = new Float32Array(size);\n        function sumAcrossChannels(offset) {\n            const currentChannel = offset % channels;\n            let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n            const endSumOffset = offset - currentChannel +\n                Math.min(currentChannel + depthRadius, maxD);\n            let sum = 0.0;\n            for (; beginSumOffset <= endSumOffset; beginSumOffset++) {\n                const z = xValues[beginSumOffset];\n                sum += z * z;\n            }\n            return sum;\n        }\n        for (let offset = 0; offset < size; offset++) {\n            const sum = sumAcrossChannels(offset);\n            const val = xValues[offset] * Math.pow(bias + alpha * sum, -beta);\n            result[offset] = val;\n        }\n        return tf.tensor4d(result, x.shape);\n    }\n    LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {\n        assertNotComplex(dy, 'LRNGrad');\n        const channels = dy.shape[3];\n        const dyValues = this.readSync(dy.dataId);\n        const inputImageValues = this.readSync(inputImage.dataId);\n        const outputImageValues = this.readSync(outputImage.dataId);\n        const result = new Float32Array(dy.size);\n        const size = dy.size;\n        for (let offset = 0; offset < size; offset++) {\n            const currentChannel = offset % channels;\n            const depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n            const depthEnd = (offset - currentChannel) +\n                Math.min(channels, currentChannel + depthRadius + 1);\n            let norm = 0;\n            for (let k = depthBegin; k < depthEnd; k++) {\n                norm += Math.pow(inputImageValues[k], 2);\n            }\n            norm = alpha * norm + bias;\n            for (let k = depthBegin; k < depthEnd; k++) {\n                let dyi = -2 * alpha * beta * inputImageValues[k] *\n                    outputImageValues[offset] / norm;\n                if (offset === k) {\n                    dyi += Math.pow(norm, -beta);\n                }\n                dyi *= dyValues[offset];\n                result[k] += dyi;\n            }\n        }\n        return tf.tensor4d(result, dy.shape);\n    }\n    multinomial(logits, normalized, numSamples, seed) {\n        assertNotComplex(logits, 'multinomial');\n        const probabilities = normalized ? logits : tf.softmax(logits);\n        const batchSize = probabilities.shape[0];\n        const numEvents = probabilities.shape[1];\n        const res = tf.zeros([batchSize, numSamples], 'int32');\n        const resVals = this.readSync(res.dataId);\n        const probVals = this.readSync(probabilities.dataId);\n        for (let b = 0; b < batchSize; ++b) {\n            const offset = b * numEvents;\n            // The cdf won't include the last event. It will be implicit if no other\n            // event happened.\n            const cdf = new Float32Array(numEvents - 1);\n            cdf[0] = probVals[offset];\n            for (let event = 1; event < cdf.length; ++event) {\n                cdf[event] = cdf[event - 1] + probVals[offset + event];\n            }\n            const random = seedrandom.alea(seed.toString());\n            const outOffset = b * numSamples;\n            for (let sampleId = 0; sampleId < numSamples; ++sampleId) {\n                const r = random();\n                // Assume last event happened by default.\n                resVals[outOffset + sampleId] = cdf.length;\n                for (let event = 0; event < cdf.length; event++) {\n                    if (r < cdf[event]) {\n                        resVals[outOffset + sampleId] = event;\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    oneHot(indices, depth, onValue, offValue) {\n        assertNotComplex(indices, 'oneHot');\n        const res = new Float32Array(indices.size * depth);\n        res.fill(offValue);\n        const indicesVal = this.readSync(indices.dataId);\n        for (let event = 0; event < indices.size; ++event) {\n            if (indicesVal[event] >= 0 && indicesVal[event] < depth) {\n                res[event * depth + indicesVal[event]] = onValue;\n            }\n        }\n        return tf.tensor2d(res, [indices.size, depth], 'int32');\n    }\n    nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n        assertNotComplex(boxes, 'nonMaxSuppression');\n        const boxesVals = this.readSync(boxes.dataId);\n        const scoresVals = this.readSync(scores.dataId);\n        return nonMaxSuppressionV3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n    }\n    fft(x) {\n        return this.fftBatch(x, false);\n    }\n    ifft(x) {\n        return this.fftBatch(x, true);\n    }\n    /**\n     * Calculate FFT of inner most elements of batch tensor.\n     */\n    fftBatch(x, inverse) {\n        const batch = x.shape[0];\n        const innerDim = x.shape[1];\n        // Collects real and imaginary values separately.\n        const realResult = tf.buffer(x.shape, 'float32');\n        const imagResult = tf.buffer(x.shape, 'float32');\n        const real = tf.real(x).as2D(batch, innerDim);\n        const imag = tf.imag(x).as2D(batch, innerDim);\n        for (let b = 0; b < batch; b++) {\n            // TODO: Support slice ops for complex type.\n            const r = real.slice([b, 0], [1, innerDim]);\n            const i = imag.slice([b, 0], [1, innerDim]);\n            const input = tf.complex(r, i);\n            // Run FFT by batch element.\n            const res = this.readSync(this.fftImpl(input, inverse).dataId);\n            for (let d = 0; d < innerDim; d++) {\n                const c = backend_util.getComplexWithIndex(res, d);\n                realResult.values[b * innerDim + d] = c.real;\n                imagResult.values[b * innerDim + d] = c.imag;\n            }\n        }\n        const t = tf.complex(realResult.toTensor(), imagResult.toTensor());\n        return t.as2D(batch, innerDim);\n    }\n    fftImpl(x, inverse) {\n        const x1D = x.as1D();\n        const n = x1D.size;\n        if (this.isExponentOf2(n)) {\n            let result = this.fftRadix2(x1D, n, inverse).as2D(x.shape[0], x.shape[1]);\n            if (inverse) {\n                result = tf.complex(tf.real(result).div(tf.scalar(n)), tf.imag(result).div(tf.scalar(n)));\n            }\n            return result;\n        }\n        else {\n            const data = this.readSync(x.dataId);\n            const rawOutput = this.fourierTransformByMatmul(data, n, inverse);\n            const output = backend_util.splitRealAndImagArrays(rawOutput);\n            return tf.complex(output.real, output.imag).as2D(x.shape[0], x.shape[1]);\n        }\n    }\n    isExponentOf2(size) {\n        return (size & size - 1) === 0;\n    }\n    // FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\n    fftRadix2(input, size, inverse) {\n        if (size === 1) {\n            return input;\n        }\n        const data = this.readSync(input.dataId);\n        const half = size / 2;\n        const evenComplex = backend_util.complexWithEvenIndex(data);\n        let evenTensor = tf.complex(evenComplex.real, evenComplex.imag).as1D();\n        const oddComplex = backend_util.complexWithOddIndex(data);\n        let oddTensor = tf.complex(oddComplex.real, oddComplex.imag).as1D();\n        // Recursive call for half part of original input.\n        evenTensor = this.fftRadix2(evenTensor, half, inverse);\n        oddTensor = this.fftRadix2(oddTensor, half, inverse);\n        const e = backend_util.exponents(size, inverse);\n        const exponent = tf.complex(e.real, e.imag).mul(oddTensor);\n        const addPart = evenTensor.add(exponent);\n        const subPart = evenTensor.sub(exponent);\n        const realTensor = tf.real(addPart).concat(tf.real(subPart));\n        const imagTensor = tf.imag(addPart).concat(tf.imag(subPart));\n        return tf.complex(realTensor, imagTensor).as1D();\n    }\n    // Calculate fourier transform by multplying sinusoid matrix.\n    fourierTransformByMatmul(data, size, inverse) {\n        const ret = new Float32Array(size * 2);\n        // TODO: Use matmul instead once it supports complex64 type.\n        for (let r = 0; r < size; r++) {\n            let real = 0.0;\n            let imag = 0.0;\n            for (let c = 0; c < size; c++) {\n                const e = backend_util.exponent(r * c, size, inverse);\n                const term = backend_util.getComplexWithIndex(data, c);\n                real += term.real * e.real - term.imag * e.imag;\n                imag += term.real * e.imag + term.imag * e.real;\n            }\n            if (inverse) {\n                real /= size;\n                imag /= size;\n            }\n            backend_util.assignToTypedArray(ret, real, imag, r);\n        }\n        return ret;\n    }\n    depthToSpace(x, blockSize, dataFormat) {\n        util.assert(dataFormat === 'NHWC', () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);\n        util.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n        const batchSize = x.shape[0];\n        const inputHeight = x.shape[1];\n        const inputWidth = x.shape[2];\n        const inputDepth = x.shape[3];\n        const outputHeight = inputHeight * blockSize;\n        const outputWidth = inputWidth * blockSize;\n        const outputDepth = inputDepth / (blockSize * blockSize);\n        const xValues = this.readSync(x.dataId);\n        const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);\n        let outputIdx = 0;\n        for (let b = 0; b < batchSize; ++b) {\n            for (let h = 0; h < outputHeight; ++h) {\n                const inH = Math.floor(h / blockSize);\n                const offsetH = (h % blockSize);\n                for (let w = 0; w < outputWidth; ++w) {\n                    const inW = Math.floor(w / blockSize);\n                    const offsetW = (w % blockSize);\n                    const offsetD = (offsetH * blockSize + offsetW) * outputDepth;\n                    for (let d = 0; d < outputDepth; ++d) {\n                        const inD = d + offsetD;\n                        const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));\n                        result[outputIdx++] = xValues[inputIdx];\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(result, [batchSize, outputHeight, outputWidth, outputDepth]);\n    }\n    broadcastedBinaryOp(a, b, dtype, op) {\n        const newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        const result = tf.buffer(newShape, dtype);\n        const aVals = this.readSync(a.dataId);\n        const bVals = this.readSync(b.dataId);\n        const aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n        const resVals = result.values;\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < resVals.length; ++i) {\n                resVals[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            const aBuf = this.bufferSync(a);\n            const bBuf = this.bufferSync(b);\n            for (let i = 0; i < resVals.length; ++i) {\n                const loc = result.indexToLoc(i);\n                const aLoc = loc.slice(-a.rank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = aBuf.locToIndex(aLoc);\n                const bLoc = loc.slice(-b.rank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = bBuf.locToIndex(bLoc);\n                resVals[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return result.toTensor();\n    }\n    broadcastedBinaryComplexOp(a, b, op) {\n        const newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        const realResult = tf.buffer(newShape, 'float32');\n        const imagResult = tf.buffer(newShape, 'float32');\n        const aVals = this.readSync(a.dataId);\n        const bVals = this.readSync(b.dataId);\n        const aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n        const realVals = realResult.values;\n        const imagVals = imagResult.values;\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < realVals.length; i++) {\n                const aIdx = i % aVals.length;\n                const bIdx = i % bVals.length;\n                const result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);\n                realVals[i] = result.real;\n                imagVals[i] = result.imag;\n            }\n        }\n        else {\n            const aRealBuf = this.bufferSync(this.data.get(a.dataId).complexTensors.real);\n            const bRealBuf = this.bufferSync(this.data.get(b.dataId).complexTensors.real);\n            for (let i = 0; i < realVals.length; i++) {\n                const loc = realResult.indexToLoc(i);\n                const aLoc = loc.slice(-a.rank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = aRealBuf.locToIndex(aLoc);\n                const bLoc = loc.slice(-b.rank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = bRealBuf.locToIndex(bLoc);\n                const opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);\n                realVals[i] = opResult.real;\n                imagVals[i] = opResult.imag;\n            }\n        }\n        return this.complex(realResult.toTensor(), imagResult.toTensor());\n    }\n    split(x, sizeSplits, axis) {\n        return split(x, sizeSplits, axis);\n    }\n    dispose() { }\n    floatPrecision() {\n        return 32;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return super.epsilon();\n    }\n    cropAndResize(images, boxes, boxIndex, cropSize, method, extrapolationValue) {\n        const [batch, imageHeight, imageWidth, numChannels] = images.shape;\n        const numBoxes = boxes.shape[0];\n        const [cropHeight, cropWidth] = cropSize;\n        const output = tf.buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n        const boxVals = this.readSync(boxes.dataId);\n        const boxIndVals = this.readSync(boxIndex.dataId);\n        const imageVals = this.readSync(images.dataId);\n        const inStride = images.strides; // to calculate flat indexes into image\n        const outStride = output.strides; // to calculate flat indexes into output\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n        for (let b = 0; b < numBoxes; b++) {\n            const startInd = b * 4;\n            const y1 = boxVals[startInd];\n            const x1 = boxVals[startInd + 1];\n            const y2 = boxVals[startInd + 2];\n            const x2 = boxVals[startInd + 3];\n            const bInd = boxIndVals[b];\n            if (bInd >= batch) {\n                continue;\n            }\n            const heightScale = (cropHeight > 1) ?\n                (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) :\n                0;\n            const widthScale = (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n            for (let y = 0; y < cropHeight; y++) {\n                const yInd = (cropHeight > 1) ?\n                    y1 * (imageHeight - 1) + y * (heightScale) :\n                    0.5 * (y1 + y2) * (imageHeight - 1);\n                if (yInd < 0 || yInd > imageHeight - 1) {\n                    for (let x = 0; x < cropWidth; x++) {\n                        for (let c = 0; c < numChannels; c++) {\n                            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = extrapolationValue;\n                        }\n                    }\n                    continue;\n                }\n                if (method === 'bilinear') {\n                    const topInd = Math.floor(yInd);\n                    const bottomInd = Math.ceil(yInd);\n                    const yLerp = yInd - topInd;\n                    for (let x = 0; x < cropWidth; x++) {\n                        const xInd = (cropWidth > 1) ?\n                            x1 * (imageWidth - 1) + x * widthScale :\n                            0.5 * (x1 + x2) * (imageWidth - 1);\n                        if (xInd < 0 || xInd > imageWidth - 1) {\n                            for (let c = 0; c < numChannels; c++) {\n                                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                                output.values[ind] = extrapolationValue;\n                            }\n                            continue;\n                        }\n                        const leftInd = Math.floor(xInd);\n                        const rightInd = Math.ceil(xInd);\n                        const xLerp = xInd - leftInd;\n                        for (let c = 0; c < numChannels; c++) {\n                            let ind = c + leftInd * inStride[2] + topInd * inStride[1] +\n                                bInd * inStride[0];\n                            const topLeft = imageVals[ind];\n                            ind = c + rightInd * inStride[2] + topInd * inStride[1] +\n                                bInd * inStride[0];\n                            const topRight = imageVals[ind];\n                            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +\n                                bInd * inStride[0];\n                            const bottomLeft = imageVals[ind];\n                            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +\n                                bInd * inStride[0];\n                            const bottomRight = imageVals[ind];\n                            const top = topLeft + (topRight - topLeft) * xLerp;\n                            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n                            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = top + ((bottom - top) * yLerp);\n                        }\n                    }\n                }\n                else { // method == \"nearest\"\n                    for (let x = 0; x < cropWidth; ++x) {\n                        const xInd = (cropWidth > 1) ?\n                            x1 * (imageWidth - 1) + x * widthScale :\n                            0.5 * (x1 + x2) * (imageWidth - 1);\n                        if (xInd < 0 || xInd > imageWidth - 1) {\n                            for (let c = 0; c < numChannels; c++) {\n                                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                                output.values[ind] = extrapolationValue;\n                            }\n                            continue;\n                        }\n                        const closestX = Math.round(xInd);\n                        const closestY = Math.round(yInd);\n                        for (let c = 0; c < numChannels; c++) {\n                            const inInd = c + closestX * inStride[2] +\n                                closestY * inStride[1] + bInd * inStride[0];\n                            const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[outInd] = imageVals[inInd];\n                        }\n                    }\n                }\n            }\n        }\n        return output.toTensor();\n    }\n    sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n        const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n        const sumDupeIndices = false;\n        return this.scatter(sparseIndices, sparseValues, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n    gatherND(x, indices) {\n        const indicesShape = indices.shape;\n        const sliceRank = indicesShape[indicesShape.length - 1];\n        const [resultShape, numSlices, sliceSize, strides] = backend_util.prepareAndValidate(x, indices);\n        if (numSlices === 0) {\n            return tf.tensor([], resultShape, x.dtype);\n        }\n        const buffer = new TensorBuffer([numSlices, sliceSize], x.dtype);\n        const indicesData = this.readSync(indices.dataId);\n        const xData = this.readSync(x.dataId);\n        for (let i = 0; i < numSlices; i++) {\n            const index = [];\n            let flattenIndex = 0;\n            for (let j = 0; j < sliceRank; j++) {\n                const dim = indicesData[i * sliceRank + j];\n                flattenIndex += dim * strides[j];\n                index.push(dim);\n            }\n            if (flattenIndex < 0 || flattenIndex >= x.size / sliceSize) {\n                throw new Error(`Invalid indices: ${index} does not index into ${x.shape}`);\n            }\n            for (let k = 0; k < sliceSize; k++) {\n                buffer.values[i * sliceSize + k] = xData[flattenIndex * sliceSize + k];\n            }\n        }\n        return buffer.toTensor().reshape(resultShape);\n    }\n    scatterND(indices, updates, shape) {\n        const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(updates, indices, shape);\n        const defaultValue = tf.scalar(0);\n        const sumDupeIndices = true;\n        return this.scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n    fill(shape, value, dtype) {\n        dtype = dtype || util.inferDtype(value);\n        const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n        values.fill(value);\n        return engine().makeTensor(values, shape, dtype, this);\n    }\n    onesLike(x) {\n        if (x.dtype === 'string') {\n            throw new Error('onesLike is not supported for string tensors');\n        }\n        else {\n            return this.fill(x.shape, 1, x.dtype);\n        }\n    }\n    zerosLike(x) {\n        const values = util.getArrayFromDType(x.dtype, util.sizeFromShape(x.shape));\n        return this.makeOutput(values, x.shape, x.dtype);\n    }\n    linspace(start, stop, num) {\n        return backend_util.linspaceImpl(start, stop, num);\n    }\n    scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {\n        const flattenShape = [outputSize / sliceSize, sliceSize];\n        const indicesData = this.readSync(indices.dataId);\n        const updatesData = this.readSync(updates.dataId);\n        if (outputSize === 0) {\n            return tf.tensor([], shape, updates.dtype);\n        }\n        const buffer = new TensorBuffer(flattenShape, updates.dtype);\n        buffer.values.fill(this.readSync(defaultValue.dataId)[0]);\n        for (let i = 0; i < numUpdates; i++) {\n            const index = [];\n            let flattenIndex = 0;\n            for (let j = 0; j < sliceRank; j++) {\n                const dim = indicesData[i * sliceRank + j];\n                index.push(dim);\n                flattenIndex += dim * strides[j];\n            }\n            if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n                throw new Error(`Invalid indices: ${index} does not index into ${shape}`);\n            }\n            for (let k = 0; k < sliceSize; k++) {\n                if (sumDupeIndices) {\n                    buffer.values[flattenIndex * sliceSize + k] +=\n                        updatesData[i * sliceSize + k];\n                }\n                else {\n                    buffer.values[flattenIndex * sliceSize + k] = updates.rank === 0 ?\n                        updatesData[0] :\n                        updatesData[i * sliceSize + k];\n                }\n            }\n        }\n        return buffer.toTensor().reshape(shape);\n    }\n}\n//# sourceMappingURL=backend_cpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import shared functionality from tfjs-backend-cpu without triggering\n// side effects.\n// tslint:disable-next-line: no-imports-from-dist\nimport {shared} from '@tensorflow/tfjs-backend-cpu/dist/base';\n\nconst {maxImpl: maxImplCPU, transposeImpl: transposeImplCPU} = shared;\n\nexport {maxImplCPU, transposeImplCPU};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ReduceProgram} from '../reduce_gpu';\n\ntype ReduceTypes = 'all'|'any'|'max'|'min'|'sum'|'prod';\n\nexport function reduce(\n    x: TensorInfo, dtype: DataType, reductionType: ReduceTypes,\n    backend: MathBackendWebGL): TensorInfo {\n  const [batchSize, inSize] = x.shape;\n  const windowSize = backend_util.computeOptimalWindowSize(inSize);\n  const reduceInfo = {windowSize, inSize, batchSize};\n  const program = new ReduceProgram(reduceInfo, reductionType);\n  const output = backend.runWebGLProgram(program, [x], dtype);\n\n  if (output.shape[1] === 1) {\n    return output;\n  }\n\n  return reduce(output, dtype, reductionType, backend);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ReshapePackedProgram} from '../reshape_packed_gpu';\nimport {getBatchDim, getRowsCols, isReshapeFree} from '../webgl_util';\n\nfunction packedReshape(\n    input: TensorInfo, afterShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const input3DShape =\n      [getBatchDim(input.shape),\n       ...getRowsCols(input.shape)] as [number, number, number];\n  const input3D: TensorInfo = {\n    dtype: input.dtype,\n    shape: input3DShape,\n    dataId: input.dataId\n  };\n  const afterShapeAs3D =\n      [getBatchDim(afterShape),\n       ...getRowsCols(afterShape)] as [number, number, number];\n\n  const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n  const preventEagerUnpackingOfOutput = true;\n  const output = backend.runWebGLProgram(\n      program, [input3D], input.dtype, null /* customSetup */,\n      preventEagerUnpackingOfOutput);\n  return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n}\n\nexport function reshape(\n    x: TensorInfo, afterShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const xTexData = backend.texData.get(x.dataId);\n  if (xTexData.isPacked && !isReshapeFree(x.shape, afterShape) &&\n      !(xTexData.texture !== null &&\n        isReshapeFree(xTexData.shape, afterShape))) {\n    return packedReshape(x, afterShape, backend);\n  }\n\n  return {dataId: x.dataId, shape: afterShape, dtype: x.dtype};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from '../kernel_utils/reshape';\n\nexport function maxImpl(\n    x: TensorInfo, reduceShape: number[], outShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput = reshape(x, [batchSize, inSize], backend);\n  const reduced = reduce(reshapedInput, x.dtype, 'max', backend);\n\n  if (reshapedInput.dataId !== x.dataId) {\n    // dispose the output of the packed reshape.\n    backend.disposeData(reshapedInput.dataId);\n  }\n\n  return reshape(reduced, outShape, backend);\n}\n","/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposeProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const switched = getSwitchedCoords(newDim);\n\n    this.userCode = `\n    void main() {\n      ${dtype} resRC = getOutputCoords();\n      setOutput(getA(${switched}));\n    }\n    `;\n  }\n}\n\nfunction getSwitchedCoords(newDim: number[]): string {\n  const rank = newDim.length;\n  if (rank > 6) {\n    throw Error(`Transpose for rank ${rank} is not yet supported`);\n  }\n  const originalOrder =\n      ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n  const switchedCoords = new Array(rank);\n  for (let i = 0; i < newDim.length; i++) {\n    switchedCoords[newDim[i]] = originalOrder[i];\n  }\n  return switchedCoords.join();\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getVecChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    if (this.rank > 6) {\n      throw Error(\n          `Packed transpose for rank ${this.rank} is not yet supported.`);\n    }\n    const dtype = getCoordsDataType(this.rank);\n\n    const outputOrder = getVecChannels('rc', this.rank);\n    const switchedOrder = new Array(this.rank);\n    for (let i = 0; i < newDim.length; i++) {\n      switchedOrder[newDim[i]] = outputOrder[i];\n    }\n    const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;\n    const nextColumn =\n        `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;\n    const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;\n\n    this.userCode = `\n    void main() {\n      ${dtype} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${getc};\n      if(${nextColumn}) {\n        result[1] = ${getc};\n      }\n      --${outputOrder[this.rank - 1]};\n      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {\n        result[2] = ${getc};\n        if(${nextColumn}) {\n          result[3] = ${getc};\n        }\n      }\n      setOutput(result);\n    }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {transposeImplCPU} from '../kernel_utils/shared';\nimport {TransposeProgram} from '../transpose_gpu';\nimport {TransposePackedProgram} from '../transpose_packed_gpu';\n\nexport function transposeImpl(\n    x: TensorInfo, perm: number[], backend: MathBackendWebGL): TensorInfo {\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new TransposePackedProgram(x.shape, perm) :\n      new TransposeProgram(x.shape, perm);\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport {transposeImplCPU};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Max, MaxAttrs, MaxInputs} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {maxImplCPU} from '../kernel_utils/shared';\n\nimport {maxImpl} from './Max_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport const maxConfig: KernelConfig = {\n  kernelName: Max,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MaxInputs;\n    const {reductionIndices} = attrs as {} as MaxAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n\n    const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const maxInputIsTransposed = permutedAxes != null;\n    const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n\n    let maxInput = x;\n    if (maxInputIsTransposed) {\n      if (shouldExecuteOnCPU) {\n        const xTexData = webglBackend.texData.get(maxInput.dataId);\n        const values = xTexData.values as TypedArray;\n\n        const newShape: number[] = new Array(xRank);\n        for (let i = 0; i < newShape.length; i++) {\n          newShape[i] = x.shape[permutedAxes[i]];\n        }\n        const maxInputValues =\n            transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n        maxInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n        const maxInputData = webglBackend.texData.get(maxInput.dataId);\n        maxInputData.values = maxInputValues;\n      } else {\n        maxInput = transposeImpl(x, permutedAxes, webglBackend);\n      }\n\n      axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n\n    backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n    const [maxOutShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(maxInput.shape, axes);\n\n    let out;\n    if (shouldExecuteOnCPU) {\n      const xTexData = webglBackend.texData.get(maxInput.dataId);\n      const values = xTexData.values as TypedArray;\n\n      const outValues = maxImplCPU(\n          values, util.sizeFromShape(reduceShape), maxOutShape, x.dtype);\n\n      out = webglBackend.makeTensorInfo(maxOutShape, x.dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n    } else {\n      out = maxImpl(maxInput, reduceShape, maxOutShape, webglBackend);\n    }\n\n    if (maxInputIsTransposed) {\n      webglBackend.disposeData(maxInput.dataId);\n    }\n\n    return out;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\n\nexport function maxPoolWithArgmaxImpl(\n    x: TensorInfo, includeBatchInIndex: boolean,\n    convInfo: backend_util.Conv2DInfo,\n    backend: MathBackendWebGL): TensorInfo[] {\n  let program = new Pool2DProgram(convInfo, 'max', false);\n  const poolOutput = backend.runWebGLProgram(program, [x], 'float32');\n\n  program = new Pool2DProgram(convInfo, 'max', true, true, includeBatchInIndex);\n  const indexOutput = backend.runWebGLProgram(program, [x], 'float32');\n  return [poolOutput, indexOutput];\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {MaxPoolWithArgmax, MaxPoolWithArgmaxAttrs, MaxPoolWithArgmaxInputs} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {maxPoolWithArgmaxImpl} from './MaxPoolWithArgmax_impl';\n\nexport const maxPoolWithArgmaxConfig: KernelConfig = {\n  kernelName: MaxPoolWithArgmax,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MaxPoolWithArgmaxInputs;\n    const {filterSize, strides, pad, includeBatchInIndex} =\n        attrs as {} as MaxPoolWithArgmaxAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    util.assert(\n        x.shape.length === 4,\n        () => `Error in maxPool: input must be rank 4 but got rank ${\n            x.shape.length}.`);\n    const dilations: [number, number] = [1, 1];\n    util.assert(\n        backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n        () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n            `Got strides ${strides} and dilations '${dilations}'`);\n\n    const convInfo = backend_util.computePool2DInfo(\n        x.shape as [number, number, number, number], filterSize, strides,\n        dilations, pad);\n\n    const [result, indexes] =\n        maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend);\n    return [result, indexes];\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, NonMaxSuppressionV3, NonMaxSuppressionV3Attrs, NonMaxSuppressionV3Inputs, TypedArray} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport const nonMaxSuppressionV3Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV3,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend, attrs}) => {\n    backend_util.warn(\n        'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n\n    const {boxes, scores} = inputs as NonMaxSuppressionV3Inputs;\n    const {maxOutputSize, iouThreshold, scoreThreshold} =\n        attrs as unknown as NonMaxSuppressionV3Attrs;\n\n    const gpuBackend = backend as MathBackendWebGL;\n\n    const boxesVals = gpuBackend.readSync(boxes.dataId) as TypedArray;\n    const scoresVals = gpuBackend.readSync(scores.dataId) as TypedArray;\n\n    const maxOutputSizeVal = maxOutputSize;\n    const iouThresholdVal = iouThreshold;\n    const scoreThresholdVal = scoreThreshold;\n\n    return kernel_impls.nonMaxSuppressionV3(\n        boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal,\n        scoreThresholdVal);\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, TypedArray} from '@tensorflow/tfjs-core';\nimport {NonMaxSuppressionV5, NonMaxSuppressionV5Attrs, NonMaxSuppressionV5Inputs} from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV5 = kernel_impls.nonMaxSuppressionV5;\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport const nonMaxSuppressionV5Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV5,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend, attrs}) => {\n    backend_util.warn(\n        'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n        'Call tf.nonMaxSuppressionAsync() instead');\n\n    const {boxes, scores} = inputs as NonMaxSuppressionV5Inputs;\n    const {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} =\n        attrs as unknown as NonMaxSuppressionV5Attrs;\n\n    const gpuBackend = backend as MathBackendWebGL;\n\n    const boxesVals = gpuBackend.readSync(boxes.dataId) as TypedArray;\n    const scoresVals = gpuBackend.readSync(scores.dataId) as TypedArray;\n\n    const maxOutputSizeVal = maxOutputSize;\n    const iouThresholdVal = iouThreshold;\n    const scoreThresholdVal = scoreThreshold;\n    const softNmsSigmaVal = softNmsSigma;\n\n    const {selectedIndices, selectedScores} = nonMaxSuppressionV5(\n        boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal,\n        scoreThresholdVal, softNmsSigmaVal);\n\n    return [selectedIndices, selectedScores];\n  }\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Square, SquareInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SQUARE, UnaryOpProgram} from '../unaryop_gpu';\n\nexport const squareConfig: KernelConfig = {\n  kernelName: Square,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend}) => {\n    const {x} = inputs as SquareInputs;\n    const webglBackend = backend as MathBackendWebGL;\n    const program = new UnaryOpProgram(x.shape, SQUARE);\n    return webglBackend.runWebGLProgram(program, [x], x.dtype);\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, SquaredDifference, SquaredDifferenceInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nexport const squaredDifferenceConfig: KernelConfig = {\n  kernelName: SquaredDifference,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend}) => {\n    const {a, b} = inputs as SquaredDifferenceInputs;\n    const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\n    const webGLBackend = backend as MathBackendWebGL;\n\n    const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n        new BinaryOpPackedProgram(SQUARED_DIFFERENCE, a.shape, b.shape) :\n        new BinaryOpProgram(SQUARED_DIFFERENCE, a.shape, b.shape);\n    return webGLBackend.compileAndRun(program, [a, b]);\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, TensorInfo, Transpose, TransposeAttrs, TransposeInputs, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {transposeImpl} from './Transpose_impl';\nimport {transposeImplCPU as cpuTranspose} from './Transpose_impl';\n\nexport const transposeConfig: KernelConfig = {\n  kernelName: Transpose,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as TransposeInputs;\n    const {perm} = attrs as {} as TransposeAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n\n    const newShape: number[] = new Array(xRank);\n    for (let i = 0; i < newShape.length; i++) {\n      newShape[i] = x.shape[perm[i]];\n    }\n\n    let out: TensorInfo;\n    if (webglBackend.shouldExecuteOnCPU([x])) {\n      const xTexData = webglBackend.texData.get(x.dataId);\n      const values = xTexData.values as TypedArray;\n      const outValues = cpuTranspose(values, x.shape, x.dtype, perm, newShape);\n\n      out = webglBackend.makeTensorInfo(newShape, x.dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n    } else {\n      out = transposeImpl(x, perm, webglBackend);\n    }\n    return out;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {KernelConfig, registerKernel} from '@tensorflow/tfjs-core';\n\nimport {divConfig} from './kernels/Div';\nimport {fromPixelsConfig} from './kernels/FromPixels';\nimport {maxConfig} from './kernels/Max';\nimport {maxPoolWithArgmaxConfig} from './kernels/MaxPoolWithArgmax';\nimport {nonMaxSuppressionV3Config} from './kernels/NonMaxSuppressionV3';\nimport {nonMaxSuppressionV5Config} from './kernels/NonMaxSuppressionV5';\nimport {squareConfig} from './kernels/Square';\nimport {squaredDifferenceConfig} from './kernels/SquaredDifference';\nimport {transposeConfig} from './kernels/Transpose';\n\n// List all kernel configs here\nconst kernelConfigs: KernelConfig[] = [\n  maxConfig, fromPixelsConfig, divConfig, nonMaxSuppressionV3Config,\n  nonMaxSuppressionV5Config, squareConfig, squaredDifferenceConfig,\n  transposeConfig, maxPoolWithArgmaxConfig\n];\n\nfor (const kernelConfig of kernelConfigs) {\n  registerKernel(kernelConfig);\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport * as gpgpu_util from './gpgpu_util';\nimport * as webgl_util from './webgl_util';\n\nexport {MathBackendWebGL, WebGLMemoryInfo, WebGLTimingInfo} from './backend_webgl';\nexport {setWebGLContext} from './canvas_util';\nexport {GPGPUContext} from './gpgpu_context';\nexport {GPGPUProgram} from './gpgpu_math';\n// WebGL specific utils.\nexport {gpgpu_util, webgl_util};\n\n/**\n * Enforce use of half precision textures if available on the platform.\n */\n/** @doc {heading: 'Environment', namespace: 'webgl'} */\nexport function forceHalfFloat(): void {\n  env().set('WEBGL_FORCE_F16_TEXTURES', true);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {device_util, registerBackend} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from './backend_webgl';\nexport {version as version_webgl} from './version';\n\nif (device_util.isBrowser()) {\n  registerBackend('webgl', () => new MathBackendWebGL(), 2 /* priority */);\n}\nimport './register_all_kernels';\n\n// Export webgl utilities\nexport * from './webgl';\n\n// Export forceHalfFlost under webgl namespace for the union bundle.\nimport {forceHalfFloat} from './webgl';\nexport const webgl = {forceHalfFloat};\n"],"names":["util","env","device_util","backend_util","shader_util.getLogicalCoordinatesFromFlatIndex","CHECK_NAN_SNIPPET","DIV","INT_DIV","POW","PRELU","ELU_DER","ATAN2","EQUAL","NOT_EQUAL","LESS","LESS_EQUAL","GREATER","GREATER_EQUAL","LOGICAL_AND","LOGICAL_OR","MAX","MIN","MOD","shader_util.getFlatIndexFrom3D","getSourceCoords","createVertexShader","webgl_util.createVertexShader","webgl_util.createStaticVertexBuffer","webgl_util.createStaticIndexBuffer","webgl_util.validateTextureSize","webgl_util.createTexture","webgl_util.callAndCheck","tex_util.getUnpackedMatrixTextureShapeWidthHeight","tex_util.getPackedMatrixTextureShapeWidthHeight","webgl_util.bindVertexBufferToProgramAttribute","tex_util.getUnpackedArraySizeFromMatrixSize","tex_util.getPackedRGBAArraySizeFromMatrixShape","webgl_util.getExtensionOrThrow","webgl_util.hasExtension","gpgpu_util.createVertexBuffer","gpgpu_util.createIndexBuffer","webgl_util.createFramebuffer","tex_util.getTextureConfig","gpgpu_util.createFloat32MatrixTexture","gpgpu_util.createFloat16MatrixTexture","gpgpu_util.createUnsignedBytesMatrixTexture","gpgpu_util.uploadPixelDataToTexture","gpgpu_util.uploadDenseMatrixToTexture","gpgpu_util.createFloat16PackedMatrixTexture","gpgpu_util.createPackedMatrixTexture","webgl_util.unbindColorTextureFromFramebuffer","gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture","gpgpu_util.downloadPackedMatrixFromBuffer","gpgpu_util.downloadFloat32MatrixFromBuffer","gpgpu_util.createBufferFromOutputTexture","gpgpu_util.downloadMatrixFromPackedOutputTexture","webgl_util.createFragmentShader","gpgpu_util.createVertexShader","webgl_util.createProgram","webgl_util.linkProgram","webgl_util.validateProgram","gpgpu_util.bindVertexProgramAttributeStreams","webgl_util.getProgramUniformLocationOrThrow","webgl_util.getProgramUniformLocation","webgl_util.bindTextureToProgramUniformSampler","webgl_util.validateFramebuffer","webgl_util.bindColorTextureToFramebuffer","shader_compiler.makeShader","getCoords","LINEAR","LOG","RELU","RELU6","ELU","kernel_impls","unary_packed_op.LINEAR","unary_op.LINEAR","unary_packed_op.RELU","unary_op.RELU","unary_packed_op.ELU","unary_op.ELU","unary_packed_op.RELU6","unary_op.RELU6","binaryop_packed_gpu.PRELU","binaryop_gpu.PRELU","KernelBackend","DataStorage","engine","unary_op.CLONE","tex_util.getDenseTexShape","webgl_util.canBeRepresented","webgl_util.getShapeAs3D","tensor","slice_util","real","imag","complex","unary_op.NEG","transpose","upcastType","binaryop_complex_gpu.COMPLEX_MULTIPLY","binaryop_gpu.MUL","buffer","tf.sumOutType","range","binaryop_packed_gpu.EQUAL","binaryop_gpu.EQUAL","binaryop_packed_gpu.NOT_EQUAL","binaryop_gpu.NOT_EQUAL","binaryop_packed_gpu.LESS","binaryop_gpu.LESS","binaryop_packed_gpu.LESS_EQUAL","binaryop_gpu.LESS_EQUAL","binaryop_packed_gpu.GREATER","binaryop_gpu.GREATER","binaryop_packed_gpu.GREATER_EQUAL","binaryop_gpu.GREATER_EQUAL","unary_op.LOGICAL_NOT","binaryop_packed_gpu.LOGICAL_AND","binaryop_gpu.LOGICAL_AND","binaryop_packed_gpu.LOGICAL_OR","binaryop_gpu.LOGICAL_OR","binaryop_packed_gpu.MIN","binaryop_gpu.MIN","binaryop_packed_gpu.MOD","binaryop_gpu.MOD","binaryop_packed_gpu.MAX","binaryop_gpu.MAX","binaryop_gpu.INT_DIV","binaryop_packed_gpu.INT_DIV","binaryop_gpu.ADD","binaryop_gpu.SUB","binaryop_packed_gpu.POW","binaryop_gpu.POW","unary_op.CEIL","unary_op.FLOOR","unary_op.SIGN","unary_op.IS_NAN","unary_op.IS_INF","unary_op.IS_FINITE","unary_op.ROUND","unary_op.EXP","unary_op.EXPM1","max","div","unary_packed_op.LOG","unary_op.LOG","unary_op.LOG1P","unary_op.SQRT","unary_op.RSQRT","unary_op.RECIPROCAL","binaryop_packed_gpu.ELU_DER","binaryop_gpu.ELU_DER","unary_op.SELU","unary_op.TO_INT","unary_op.ABS","unary_op.SIGMOID","unary_op.SOFTPLUS","unary_op.SIN","unary_op.COS","unary_op.TAN","unary_op.ASIN","unary_op.ACOS","unary_op.ATAN","binaryop_packed_gpu.ATAN2","binaryop_gpu.ATAN2","unary_op.SINH","unary_op.COSH","unary_op.TANH","unary_op.ASINH","unary_op.ACOSH","unary_op.ATANH","unary_op.ERF","unary_op.STEP","webgl_util.isReshapeFree","softmax","scalar","fft_gpu.COMPLEX_FFT","webgl_util.getBatchDim","webgl_util.getRowsCols","tex_util.PackingScheme","gpgpu_math.makeShaderKey","gpgpu_math.compileProgram","gpgpu_math.runProgram","tidy","webgl_util.getTextureShapeFromLogicalShape","binaryop_gpu.DIV","binaryop_packed_gpu.DIV","Div","FromPixels","split","tile","topkImpl","whereImpl","maxImpl","transposeImpl","Max","MaxPoolWithArgmax","NonMaxSuppressionV3","NonMaxSuppressionV5","Square","SquaredDifference","Transpose","cpuTranspose","registerKernel","registerBackend"],"mappings":"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"}