/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],t):t((e=e||self).tf=e.tf||{},e.tf,e.seedrandom)}(this,(function(e,t,n){"use strict";const r={},i={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function o(e,t){r[e]=t}function a(e){e in r||(r[e]=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);if(t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete r[e]},!1),1===e)return t.getContext("webgl",i)||t.getContext("experimental-webgl",i);return t.getContext("webgl2",i)}(e));const t=r[e];return t.isContextLost()?(delete r[e],a(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),r[e])}var s,u,l;function c(e,t){return[t,e]}function d(e){const n=t.util.sizeFromShape(e),r=Math.ceil(n/4);return t.util.sizeToSquarishShape(r)}function h(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function p(e,n){const r=e;let i,o,a,s,u,l,c,d,h,p;return 2===t.env().getNumber("WEBGL_VERSION")?(i=r.R32F,o=r.R16F,a=r.RGBA16F,s=r.RGBA32F,u=r.RED,c=4,d=1,h=r.HALF_FLOAT,p=r.FLOAT):(i=e.RGBA,o=e.RGBA,a=e.RGBA,s=r.RGBA,u=e.RGBA,c=4,d=4,h=null!=n?n.HALF_FLOAT_OES:null,p=e.FLOAT),l=e.RGBA,{internalFormatFloat:i,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:p}}function f(e,t,n){const r=n();return t&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+g(e,t))}(e),r}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(s||(s={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(u||(u={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(l||(l={}));function x(e){return!!(t.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function g(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function m(e,t,n){return k(e,t,()=>e.getExtension(n),'Extension "'+n+'" not supported on this browser.')}function C(e,t,n){const r=k(e,t,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(f(e,t,()=>e.shaderSource(r,n)),f(e,t,()=>e.compileShader(r)),!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function v(e,n,r){const i=k(e,n,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(f(e,n,()=>e.shaderSource(i,r)),f(e,n,()=>e.compileShader(i)),!1===e.getShaderParameter(i,e.COMPILE_STATUS))throw function(e,n){const r=$.exec(n);if(null==r)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(e);const i=+r[1],o=e.split("\n"),a=o.length.toString().length+2,s=o.map((e,n)=>t.util.rightPad((n+1).toString(),a)+e);let u=0;for(let e=0;e<s.length;e++)u=Math.max(s[e].length,u);const l=s.slice(0,i-1),c=s.slice(i-1,i),d=s.slice(i);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${t.util.rightPad(c[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}(r,e.getShaderInfoLog(i)),new Error("Failed to compile fragment shader.");return i}const $=/ERROR: [0-9]+:([0-9]+):/g;function R(e,t){return k(e,t,()=>e.createProgram(),"Unable to create WebGLProgram.")}function b(e,t,n){if(f(e,t,()=>e.linkProgram(n)),!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function w(e,t,n){if(f(e,t,()=>e.validateProgram(n)),!1===e.getProgramParameter(n,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function y(e,t,n){const r=k(e,t,()=>e.createBuffer(),"Unable to create WebGLBuffer");return f(e,t,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),f(e,t,()=>e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW)),r}function E(e,t,n){const r=k(e,t,()=>e.createBuffer(),"Unable to create WebGLBuffer");return f(e,t,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r)),f(e,t,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW)),r}function A(e,t){return k(e,t,()=>e.createTexture(),"Unable to create WebGLTexture.")}function I(e,n){const r=t.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0){throw new Error("Requested texture size "+`[${e}x${n}]`+" is invalid.")}if(e>r||n>r){throw new Error("Requested texture size "+`[${e}x${n}]`+" greater than WebGL maximum on this browser / GPU "+`[${r}x${r}]`+".")}}function T(e,t){return k(e,t,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function _(e,t,n,r,i,o,a,s){const u=e.getAttribLocation(n,r);return-1!==u&&(f(e,t,()=>e.bindBuffer(e.ARRAY_BUFFER,i)),f(e,t,()=>e.vertexAttribPointer(u,o,e.FLOAT,!1,a,s)),f(e,t,()=>e.enableVertexAttribArray(u)),!0)}function O(e,t,n,r){V(e,r),f(e,t,()=>e.activeTexture(e.TEXTURE0+r)),f(e,t,()=>e.bindTexture(e.TEXTURE_2D,n))}function N(e,t,n,r){return k(e,t,()=>e.getUniformLocation(n,r),'uniform "'+r+'" not present in program.')}function S(e,t,n){return e.getUniformLocation(t,n)}function F(e,t,n,r,i,o){f(e,t,()=>O(e,t,r,o)),f(e,t,()=>e.uniform1i(i,o))}function D(e,t,n,r){f(e,t,()=>e.bindFramebuffer(e.FRAMEBUFFER,r)),f(e,t,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0))}function B(e,t,n){f(e,t,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),f(e,t,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function P(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+L(e,t))}function L(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function k(e,t,n,r){const i=f(e,t,()=>n());if(null==i)throw new Error(r);return i}function V(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function W(e,n=2){return t.util.sizeFromShape(e.slice(0,e.length-n))}function U(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function M(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[W(e),...U(e)]),t}function G(e,n=!1){let r=t.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n&&(r*=2,1===(e=e.map((n,r)=>r>=e.length-2?t.util.nearestLargerEven(e[r]):e[r])).length&&(e=[2,e[0]])),2!==e.length){const n=t.util.squeezeShape(e);e=n.newShape}let i=t.util.sizeFromShape(e);if(e.length<=1&&i<=r)return[1,i];if(2===e.length&&e[0]<=r&&e[1]<=r)return e;if(3===e.length&&e[0]*e[1]<=r&&e[2]<=r)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=r&&e[1]*e[2]<=r)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=r&&e[3]<=r)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=r&&e[1]*e[2]*e[3]<=r)return[e[0],e[1]*e[2]*e[3]];if(n){const n=W(e);let r=2,o=2;return e.length&&([r,o]=U(e)),i=n*(r/2)*(o/2),t.util.sizeToSquarishShape(i).map(e=>2*e)}return t.util.sizeToSquarishShape(i)}function z(e){return e%2==0}function X(e,n){if(e=e.slice(-2),n=n.slice(-2),t.util.arraysEqual(e,n))return!0;if(!e.length||!n.length)return!0;if(0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){const t=e.slice(-1)[0],r=n.slice(-1)[0];if(t===r)return!0;if(z(t)&&z(r)&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&z(e[0])&&z(n[0])}let H,j;function K(e){if(null==H){const t=a(e);H=t.getParameter(t.MAX_TEXTURE_SIZE)}return H}function Y(e){if(null==j){const t=a(e);j=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,j)}function q(e){if(0===e)return 0;let t;const n=a(e);return t=Q(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Q(n,"EXT_disjoint_timer_query")?1:0,t}function Q(e,t){return null!=e.getExtension(t)}function Z(e){try{if(null!=a(e))return!0}catch(e){return!1}return!1}function J(e){if(0===e)return!1;const t=a(e);if(1===e){if(!Q(t,"OES_texture_float"))return!1}else if(!Q(t,"EXT_color_buffer_float"))return!1;return te(t)}function ee(e){if(0===e)return!1;const t=a(e);if(1!==e){if(Q(t,"EXT_color_buffer_float"))return te(t);const e="EXT_color_buffer_half_float";if(Q(t,e)){const n=t.getExtension(e);return function(e,t){const n=p(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}return!!Q(t,"OES_texture_float")&&(!!Q(t,"WEBGL_color_buffer_float")&&te(t))}function te(e){const t=p(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),i}function ne(e){if(2!==e)return!1;return null!=a(e).fenceSync}var re=Object.freeze({__proto__:null,callAndCheck:f,canBeRepresented:x,getWebGLErrorMessage:g,getExtensionOrThrow:m,createVertexShader:C,createFragmentShader:v,createProgram:R,linkProgram:b,validateProgram:w,createStaticVertexBuffer:y,createStaticIndexBuffer:E,getNumChannels:function(){return 2===t.env().getNumber("WEBGL_VERSION")?1:4},createTexture:A,validateTextureSize:I,createFramebuffer:T,bindVertexBufferToProgramAttribute:_,bindTextureUnit:O,unbindTextureUnit:function(e,t,n){V(e,n),f(e,t,()=>e.activeTexture(e.TEXTURE0+n)),f(e,t,()=>e.bindTexture(e.TEXTURE_2D,null))},getProgramUniformLocationOrThrow:N,getProgramUniformLocation:S,bindTextureToProgramUniformSampler:F,bindCanvasToFramebuffer:function(e,t){f(e,t,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),f(e,t,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),f(e,t,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))},bindColorTextureToFramebuffer:D,unbindColorTextureFromFramebuffer:B,validateFramebuffer:P,getFramebufferErrorMessage:L,getBatchDim:W,getRowsCols:U,getShapeAs3D:M,getTextureShapeFromLogicalShape:G,isReshapeFree:X,getWebGLMaxTextureSize:K,resetMaxTextureSize:function(){H=null},resetMaxTexturesInShader:function(){j=null},getMaxTexturesInShader:Y,getWebGLDisjointQueryTimerVersion:q,hasExtension:Q,isWebGLVersionEnabled:Z,isCapableOfRenderingToFloatTexture:J,isDownloadFloatTextureEnabled:ee,isWebGLFenceEnabled:ne});const ie=t.env();ie.registerFlag("HAS_WEBGL",()=>ie.getNumber("WEBGL_VERSION")>0),ie.registerFlag("WEBGL_VERSION",()=>Z(2)?2:Z(1)?1:0),ie.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===ie.get("WEBGL_VERSION")),ie.registerFlag("WEBGL_CPU_FORWARD",()=>!0),ie.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),ie.registerFlag("WEBGL_PACK",()=>ie.getBool("HAS_WEBGL")),ie.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_PACK_CLIP",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),ie.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_PACK_REDUCE",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_LAZILY_UNPACK",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_CONV_IM2COL",()=>ie.getBool("WEBGL_PACK")),ie.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>K(ie.getNumber("WEBGL_VERSION"))),ie.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Y(ie.getNumber("WEBGL_VERSION"))),ie.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=ie.getNumber("WEBGL_VERSION");return 0===e?0:q(e)}),ie.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ie.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!t.device_util.isMobile()),ie.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>J(ie.getNumber("WEBGL_VERSION"))),ie.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!ie.getBool("WEBGL_FORCE_F16_TEXTURES")&&ie.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),ie.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ee(ie.getNumber("WEBGL_VERSION"))),ie.registerFlag("WEBGL_FENCE_API_ENABLED",()=>ne(ie.getNumber("WEBGL_VERSION"))),ie.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ie.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);class oe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class ae{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class se{constructor(e,t,n){this.variableNames=["A"];const r=e.windowSize,i=e.batchSize,o=e.inSize,a=Math.ceil(o/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const s="max"===t?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${u};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${s} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function ue(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function le(e,t){return 1===t?[e]:ue(e,t)}function ce(){let e,n,r,i,o,a,s,u,l,c;return 2===t.env().getNumber("WEBGL_VERSION")?(e="#version 300 es",n="in",r="out",i="in",o="texture",a="outputColor",s="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",n="attribute",r="varying",i="varying",o="texture2D",a="gl_FragColor",s="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:n,varyingVs:r,varyingFs:i,texture2D:o,output:a,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function de(e,n,r="index"){const i=t.util.computeStrides(n);return i.map((t,n)=>`${`int ${e[n]} = ${r} / ${t}`}; ${n===i.length-1?`int ${e[n+1]} = ${r} - ${e[n]} * ${t}`:`index -= ${e[n]} * ${t}`};`).join("")}function he(e){const n=t.util.computeStrides(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}const pe="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:fe}=t.backend_util;function xe(e,n,r,i){const o=[];e.forEach(e=>{const n=t.util.sizeFromShape(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?o.push(`uniform float ${e.name}${n>1?`[${n}]`:""};`):(o.push(`uniform sampler2D ${e.name};`),o.push(`uniform int offset${e.name};`))});const a=o.join("\n"),s=e.map(e=>function(e,n,r=!1){let i="";i+=r?me(e):ge(e);const o=e.shapeInfo.logicalShape,a=n.logicalShape;o.length<=a.length&&(i+=r?function(e,n){const r=e.name,i=r.charAt(0).toUpperCase()+r.slice(1),o="get"+i+"AtOutCoords",a=e.shapeInfo.logicalShape.length,s=n.logicalShape.length,u=fe(e.shapeInfo.logicalShape,n.logicalShape),l=Ee(s),c=s-a;let d;const h=["x","y","z","w","u","v"];d=0===a?"":s<2&&u.length>=1?"coords = 0;":u.map(e=>`coords.${h[e+c]} = 0;`).join("\n");let p="";p=s<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+c]}`).join(", ");let f="return outputValue;";const x=1===t.util.sizeFromShape(e.shapeInfo.logicalShape),g=1===t.util.sizeFromShape(n.logicalShape);if(1!==a||x||g){if(x&&!g)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){const e=a-2,t=a-1;u.indexOf(e)>-1&&u.indexOf(t)>-1?f="return vec4(outputValue.x);":u.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${i}(${p});\n      ${f}\n    }\n  `}(e,n):function(e,n){const r=e.name,i=r.charAt(0).toUpperCase()+r.slice(1),o="get"+i+"AtOutCoords",a=n.texShape,s=e.shapeInfo.texShape,u=e.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!e.shapeInfo.isUniform&&u===l&&null==e.shapeInfo.flatOffset&&t.util.arraysEqual(s,a))return`\n      float ${o}() {\n        return sampleTexture(${r}, resultUV);\n      }\n    `;const c=Ee(l),d=fe(e.shapeInfo.logicalShape,n.logicalShape),h=l-u;let p;const f=["x","y","z","w","u","v"];p=0===u?"":l<2&&d.length>=1?"coords = 0;":d.map(e=>`coords.${f[e+h]} = 0;`).join("\n");let x="";x=l<2&&u>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${f[t+h]}`).join(", ");return`\n    float ${o}() {\n      ${c} coords = getOutputCoords();\n      ${p}\n      return get${i}(${x});\n    }\n  `}(e,n));return i}(e,n,i)).join("\n"),u=n.texShape,l=ce(),c=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let d,h,p=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Ce}\n    ${ve}\n    ${$e}\n  `}(l);return n.isPacked?(d=function(e,n){switch(e.length){case 0:return be();case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===n[0])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,n);case 2:return function(e,n){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(t.util.arraysEqual(e,n))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,n);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),i=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,n);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),i=r*Math.ceil(e[e.length-2]/2);let o=i,a="",s="b, r, c";for(let t=2;t<e.length-1;t++)o*=e[e.length-t-1],a=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+a,s=`b${t}, `+s;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${s});\n    }\n  `}(e,n)}}(n.logicalShape,u),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(l)):(d=function(e,n){switch(e.length){case 0:return be();case 1:return function(e,t){if(1===t[0])return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,n);case 2:return function(e,n){if(t.util.arraysEqual(e,n))return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;if(1===e[1])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,n);case 3:return function(e,t){const n=de(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,n);case 4:return function(e,t){const n=de(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,n);case 5:return function(e,t){const n=de(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,n);case 6:return function(e,t){const n=de(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(n.logicalShape,u),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),i&&(p+=Re),[p,c,h,a,d,s,r].join("\n")}function ge(e){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,i]=e.shapeInfo.texShape;if(1===r&&1===i)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[o,a]=e.shapeInfo.texShape,s=we(t);return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${o}, ${a}, ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${ye(e)}\n      }\n    `;const r=e.shapeInfo.texShape,i=r[0],o=r[1];if(1===o&&1===i)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=we(t);if(1===o)return`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===i)return`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape;if(null!=o&&t.util.arraysEqual(n,o)){const e=o[0],t=o[1];return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:a,keptDims:s}=t.util.squeezeShape(n),u=a;if(u.length<n.length){const t=Ae(e,u),n=["row","col"];return`\n      ${ge(t)}\n      float ${i}(int row, int col) {\n        return ${i}(${Ie(n,s)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${ye(e)}\n      }\n    `;const l=o[0],c=o[1],d=we(r);if(1===c)return`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===l)return`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e);case 3:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],a=n[2],{newShape:s,keptDims:u}=t.util.squeezeShape(n),l=s;if(l.length<n.length){const t=Ae(e,l),n=["row","col","depth"];return`\n        ${ge(t)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${Ie(n,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${a}, 1)));\n        ${ye(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===o&&null==p)return`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===a&&null==p)return`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=we(r);return`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${a} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e);case 4:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],a=n[2]*o,s=n[1]*a,{newShape:u,keptDims:l}=t.util.squeezeShape(n);if(u.length<n.length){const t=Ae(e,u),n=["row","col","depth","depth2"];return`\n      ${ge(t)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${Ie(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${s}, ${a}, ${o}, 1)));\n        ${ye(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===s&&null==c)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===o&&null==c)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const f=we(r);return`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${s} + col * ${a} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${f});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e);case 5:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[4],a=n[3]*o,s=n[2]*a,u=n[1]*s,{newShape:l,keptDims:c}=t.util.squeezeShape(n);if(l.length<n.length){const t=Ae(e,l),n=["row","col","depth","depth2","depth3"];return`\n      ${ge(t)}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${Ie(n,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${s}, ${a}, ${o})) +\n          depth3;\n        ${ye(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const x=we(r);return`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${s} + depth * ${a} +\n          depth2 * ${o} + depth3 + ${x};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${r}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),{newShape:o,keptDims:a}=t.util.squeezeShape(n);if(o.length<n.length){const t=Ae(e,o),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${ge(t)}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${Ie(n,a)});\n      }\n    `}const s=n[5],u=n[4]*s,l=n[3]*u,c=n[2]*l,d=n[1]*c;if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${l}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${ye(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],x=p[1];if(x===d&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${u}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${f}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(x===s&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${f}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const g=we(r);return`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${l} +\n          depth2 * ${u} + depth3 * ${s} + depth4 + ${g};\n      vec2 uv = uvFromFlat(${f}, ${x}, index);\n      return sampleTexture(${r}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling`+" is not yet supported")}}function me(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=ce();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],o=ce();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=o[0],s=o[1],u=ce();if(null!=o&&t.util.arraysEqual(n,o))return`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}.0, ${a}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===t[0]){const n=t.slice(1),i=[1,2],o=Ae(e,n),a=["b","row","col"];return`\n        ${me(o)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Ie(a,i)});\n        }\n      `}const a=o[0],s=o[1],u=Math.ceil(t[2]/2),l=u*Math.ceil(t[1]/2),c=ce();return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${s}, ${l}, ${u}, b, row, col);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],s=a[0],u=a[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),d="int b, int row, int col",h=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let e=2;e<n-1;e++)d=`int b${e}, `+d,c*=t[n-e-1],h=`b${e} * ${c} + `+h;const p=ce();return`\n    vec4 ${i}(${d}) {\n      int index = ${h};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${s});\n      return ${p.texture2D}(${r}, uv);\n    }\n  `}(e)}}const Ce="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ve="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$e="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Re="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function be(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function we(e){return`offset${e}`}function ye(e){const n=e.name,r=t.util.sizeFromShape(e.shapeInfo.logicalShape);return r<2?`return ${n};`:`\n    for (int i = 0; i < ${r}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function Ee(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Ae(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Ie(e,t){return t.map(t=>e[t]).join(", ")}class Te{constructor(e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,t.util.assert(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/n);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),i||this.variableNames.push("bestIndicesA");const s=this.outputShape,u=s.length,l=Ee(u),c=le("coords",u);let d,h;if(1===a){h=u+1;const e=Ee(h);d=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else h=u,d=`\n        ${l} sourceLocR = coords;\n        ++${c[u-1]};\n        ${l} sourceLocG = coords;\n        ++${c[u-2]};\n        ${l} sourceLocA = coords;\n        --${c[u-1]};\n        ${l} sourceLocB = coords;\n        --${c[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],x=p.map(e=>"int "+e),g=le("sourceLocR",h-1).concat("inIdx.r"),m=le("sourceLocG",h-1).concat("inIdx.g"),C=le("sourceLocB",h-1).concat("inIdx.b"),v=le("sourceLocA",h-1).concat("inIdx.a"),$="max"===r?"greaterThan":"lessThan",R=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${C.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,b=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${C.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,w=i?"":`\n      float getBestIndicesAChannel(${x.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${x.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${s[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${s[u-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${n};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${b};\n\n        for (int i = 0; i < ${n}; i++) {\n          inIdx = srcIdx;\n          ${R}\n          vec4 candidate = ${b};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class _e{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=s-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n            wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Oe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,x=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${x});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${i}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ne{constructor(e,n,r,i,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,r);let s="0.0";null!=i&&(t.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let u="1.0";null!=o&&(t.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${s};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Se{constructor(e,n,r,i,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,r);let s="vec4(0.0)";null!=i&&(t.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=o&&(t.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${s};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Fe="return areal * breal - aimag * bimag;",De="return areal * bimag + aimag * breal;";class Be{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Pe="return a + b;",Le="return a - b;",ke="return a * b;",Ve="return (a < 0.) ? b * a : a;";class We{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Ue="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class Me{constructor(e,n,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r);const o=this.outputShape.length;let a="";if(i)if(0===o||1===t.util.sizeFromShape(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${Ee(o)} coords = getOutputCoords();\n        `,1===o)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=le("coords",o);a+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}class Ge{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class ze{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class Xe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class He{constructor(e){this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let t=1;t<n.length;t++)n[t]=n[t-1]+e[t][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<n.length;e++){const t=n[e-1];r.push(`else if (yC < ${n[e]}) `+`setOutput(getT${e}(yR, yC-${t}));`)}const i=n.length,o=n[n.length-1];r.push(`else setOutput(getT${i}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class je{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(e,n);const r=this.outputShape,i=r.length,o=Ee(i),a=le("coords",i),s=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((e,t)=>`T${t}`);const u=new Array(e.length-1);u[0]=e[0][n];for(let t=1;t<u.length;t++)u[t]=u[t-1]+e[t][n];const l=s[n],c=s.slice(-2),d=s.join();let h=`if (${l} < ${u[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let e=1;e<u.length;e++){const t=u[e-1];h+=`\n        if (${l} < ${u[e]}  && ${l} >= ${u[e-1]}) {\n          return getChannel(\n            getT${e}(${Ke(s,l,t)}),\n            vec2(${Ke(c,l,t)}));\n        }`}const p=u.length,f=u[u.length-1];h+=`\n        return getChannel(\n          getT${p}(${Ke(s,l,f)}),\n          vec2(${Ke(c,l,f)}));`,this.userCode=`\n      float getValue(${s.map(e=>"int "+e)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[i-1]} = ${a[i-1]} + 1;\n        if (${a[i-1]} < ${r[i-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[i-2]} = ${a[i-2]} + 1;\n        if (${a[i-2]} < ${r[i-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[i-1]} = ${a[i-1]} - 1;\n        if (${a[i-2]} < ${r[i-2]} &&\n            ${a[i-1]} < ${r[i-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function Ke(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}class Ye{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${o}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o="channelsLast"===e.dataFormat,a=t-1-e.padInfo.top,s=n-1-e.padInfo.left,u=o?1:2,l=o?2:3,c=o?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Qe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${i};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${o};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${a};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ze{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${s}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${i}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Je{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${o} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class et{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class tt{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,o=e.padInfo.left,a=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),p=e.inChannels%4,f="channelsLast"===e.dataFormat,x=f?1:2,g=f?2:3,m=f?3:1;let C="",v="";n&&(C=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const $=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${C}\n\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${m}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${x}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${l};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===p}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===p}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===p}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${$}\n        ${v}\n        setOutput(result);\n      }\n    `}}class nt{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${o}, ${a});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${s};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rt{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.inHeight,o=e.inWidth,a=e.padInfo.top,s=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,f=e.outChannels/e.inChannels;let x="",g="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${u}, ${l});\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${o}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${m}\n        ${g}\n        setOutput(result);\n      }\n    `}}class it{constructor(e,n=!1,r=null,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const o=e.inHeight,a=e.inWidth,s=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,h=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,x=f;let g="int xR; int xC; int xCOffset;";for(let e=0;e<p;e++)for(let t=0;t<f;t++)g+=`\n          vec4 xTexelR${e}C${2*t} = vec4(0.);\n          vec4 wR${e}C${t} = vec4(0.);\n          vec4 xR${e}C${t} = vec4(0.);`;for(let e=0;e<p;e++)for(let n=0;n<x;n++){const r=2*n;if(g+=`\n          xR = xRCorner + ${e*d};\n          xC = xCCorner + ${r*h};\n        `,1===c){if(r<f&&(g+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${o} && xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${r} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    xTexelR${e}C${r}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${e}C${r} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${o} && xCOffset >= 0 && xCOffset < ${a}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${e}C${r} = vec4(previous.zw, xTexelR${e}C${r}.xy);\n                } else {\n                  xR${e}C${r} = vec4(0, 0, xTexelR${e}C${r}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${o} && xC >= 0 && xC < ${a}) {\n                  xTexelR${e}C${r} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${r} = vec4(0.);\n                }\n\n                xR${e}C${r} = xTexelR${e}C${r};\n              `,r+1<f)){const n=u%2==0?t.util.nearestLargerEven(h):h;h%2==0&&u%2==1||h%2!=0&&u%2!=1?(g+=`\n                  xCOffset = xC + ${u%2} + ${n};\n\n                  if(xR >= 0 && xR < ${o} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${e}C${r+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,h>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${o} &&\n                      xCOffset >= 0 && xCOffset < ${a}) {\n                      xTexelR${e}C${r} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${e}C${r} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${e}C${r+1} = vec4(\n                    xTexelR${e}C${r}.zw, xTexelR${e}C${r+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${n};\n\n                  if(xR >= 0 && xR < ${o} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${e}C${r+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${e}C${r+1} = xTexelR${e}C${r+2};\n                `}}else r<f&&(g+=`\n              if(xR >= 0 && xR < ${o}) {\n            `,u%2==1?(g+=`\n                xCOffset = xC + 1 - ${c};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${r} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${r} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a}) {\n                  xTexelR${e}C${r+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${e}C${r+2} = vec4(0.);\n                }\n\n                xR${e}C${r} = vec4(\n                  xTexelR${e}C${r}.zw, xTexelR${e}C${r+2}.zw);\n              `,r+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${c};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${e}C${r+1} = vec4(xTexelR${e}C${r+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${a}) {\n                  xTexelR${e}C${r} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${r} = vec4(0.);\n                }\n\n                xCOffset = xC + ${c};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${r+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${r+2} = vec4(0.);\n                }\n\n                xR${e}C${r} = vec4(\n                  xTexelR${e}C${r}.xy, xTexelR${e}C${r+2}.xy);\n              `,r+1<f&&(g+=`\n                  xR${e}C${r+1} = vec4(\n                    xTexelR${e}C${r}.zw, xTexelR${e}C${r+2}.zw);\n                `)),g+="}");r<f&&(g+=`\n            vec4 wTexelR${e}C${r} = getW(${e}, ${r}, d1, q);\n            wR${e}C${r} = vec4(wTexelR${e}C${r}.xz, wTexelR${e}C${r}.xz);\n          `,r+1<f&&(g+=`\n              vec4 wTexelR${e}C${r+1} = getW(${e}, ${r+1}, d1, q);\n              wR${e}C${r+1} =\n                vec4(wTexelR${e}C${r+1}.xz, wTexelR${e}C${r+1}.xz);`))}for(let e=0;e<p;e++)for(let t=0;t<f;t++)g+=`dotProd += xR${e}C${t} * wR${e}C${t};`;let m="",C="";r&&(m=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,C="result = activation(result);");const v=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${s}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${v}\n        ${C}\n        setOutput(result);\n      }\n    `}}class ot{constructor(e,t,n,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,s,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const h="bilinear"===r?1:0,[p,f]=[`${a-1}.0`,`${s-1}.0`],[x,g,m]=c>1?[`${(a-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[C,v,$]=d>1?[`${(s-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${x});\n      const float width_ratio = float(${C});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${m};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${$};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class at{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,i=e[e.length-1],o=n?"<":">";this.userCode=`\n      int getIndex(int i) {\n        ${n?`return ${i} -i - 1;`:"return i;"}\n      }\n\n      void main() {\n        ${Ee(r)} coords = getOutputCoords();\n        int end = ${st(r,"coords")};\n        float val = 0.0;\n        for (int i = ${i} - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx ${o} end) {\n            continue;\n          }\n          if (idx == end && ${t}) {\n            continue;\n          }\n          ${st(r,"coords")} = idx;\n          val += getX(${function(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function st(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}class ut{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=s.DENSE;const t=d(e),n=ce();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${de(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class lt{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=s.DENSE;const t=d(e),n=ce();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${de(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class ct{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class dt{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class ht{constructor(e){this.variableNames=["A"],this.outTexUsage=u.DOWNLOAD;const t=ce();this.outputShape=e,this.userCode=`\n      ${pe}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class pt{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=u.DOWNLOAD;const t=ce();this.outputShape=e,this.userCode=`\n      ${pe}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class ft{constructor(e,t,n=!1){this.variableNames=["A"];const r=ce(),[i,o]=t;this.outputShape=e;let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${he(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / ${o};\n        int c = imod(flatIndex, ${o});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${i}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class xt{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=ce(),[i,o]=t;this.outputShape=e;let a="",s="result";n&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){const s=2*t+n;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${e[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${t} < ${e[1]}) {\n              localCoords[1] += ${t};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${o};\n              c = imod(flatIndex, ${o});\n              uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${i}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${s}] = values[0];\n              } else if(offset == 1) {\n                result[${s}] = values[1];\n              } else if(offset == 2) {\n                result[${s}] = values[2];\n              } else {\n                result[${s}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${he(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${r.output} = ${s};\n      }\n    `}}const gt="return real * expR - imag * expI;",mt="return real * expI + imag * expR;";class Ct{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0";this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${e}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class vt{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class $t{constructor(e,t,n){this.variableNames=["A","indices"];const r=e.slice();r[n]=t,this.outputShape=r,this.rank=r.length;const i=Ee(this.rank),o=function(e,t){const n=e.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[];for(let n=0;n<e.length;n++)n===t?i.push(`int(getIndices(${r[n]}))`):i.push(`${r[n]}`);return i.join()}(e,n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}class Rt{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=Ee(t.length),i=Ee(n.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${o};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function bt(e,t){const n=ce();return C(e,t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function wt(e,t){return y(e,t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function yt(e,t){return E(e,t,new Uint16Array([0,1,2,2,1,3]))}function Et(e,t,n,r,i,o,a){I(n,r);const s=A(e,t),u=e.TEXTURE_2D;return f(e,t,()=>e.bindTexture(u,s)),f(e,t,()=>e.texParameteri(u,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),f(e,t,()=>e.texParameteri(u,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),f(e,t,()=>e.texParameteri(u,e.TEXTURE_MIN_FILTER,e.NEAREST)),f(e,t,()=>e.texParameteri(u,e.TEXTURE_MAG_FILTER,e.NEAREST)),f(e,t,()=>e.texImage2D(u,0,i,n,r,0,o,a,null)),f(e,t,()=>e.bindTexture(e.TEXTURE_2D,null)),s}function At(e,t,n,r,i){const[o,a]=c(n,r);return Et(e,t,o,a,i.internalFormatFloat,i.textureFormatFloat,e.FLOAT)}function It(e,t,n,r,i){const[o,a]=c(n,r);return Et(e,t,o,a,i.internalFormatHalfFloat,i.textureFormatFloat,i.textureTypeHalfFloat)}function Tt(e,t,n,r,i){const[o,a]=c(n,r);return Et(e,t,o,a,e.RGBA,e.RGBA,e.UNSIGNED_BYTE)}function _t(e,t,n,r,i){const[o,a]=h(n,r);return Et(e,t,o,a,i.internalFormatPackedFloat,e.RGBA,e.FLOAT)}function Ot(e,t,n,r,i){const[o,a]=h(n,r);return Et(e,t,o,a,i.internalFormatPackedHalfFloat,e.RGBA,i.textureTypeHalfFloat)}function Nt(e,t,n,r){return f(e,t,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),_(e,t,n,"clipSpacePos",r,3,20,0)&&_(e,t,n,"uv",r,2,20,12)}function St(e,t,n,r,i,o,a){let s,u,l;f(e,t,()=>e.bindTexture(e.TEXTURE_2D,n)),o instanceof Uint8Array?(s=new Uint8Array(r*i*4),u=e.UNSIGNED_BYTE,l=e.RGBA):(s=new Float32Array(r*i*4),u=e.FLOAT,l=a.internalFormatPackedFloat),s.set(o),f(e,t,()=>e.texImage2D(e.TEXTURE_2D,0,l,r,i,0,e.RGBA,u,s)),f(e,t,()=>e.bindTexture(e.TEXTURE_2D,null))}function Ft(e,t,n,r){f(e,t,()=>e.bindTexture(e.TEXTURE_2D,n)),r.data instanceof Uint8Array?f(e,t,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r.width,r.height,0,e.RGBA,e.UNSIGNED_BYTE,r.data)):f(e,t,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r)),f(e,t,()=>e.bindTexture(e.TEXTURE_2D,null))}function Dt(e,t,n,r,i){const o=e.createBuffer();f(e,t,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,o));const a=16*n*r;return f(e,t,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),f(e,t,()=>e.readPixels(0,0,r,n,e.RGBA,e.FLOAT,0)),f(e,t,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),o}function Bt(e,t,n){const r=e,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function Pt(e,t,n,r,i){const[o,a]=c(n,r),s=new Uint8Array(n*r*4);return f(e,t,()=>e.readPixels(0,0,o,a,i.downloadTextureFormat,e.UNSIGNED_BYTE,s)),new Float32Array(s.buffer)}function Lt(e,t,n,r,i,o,a,s){const u=e,l=new Float32Array(function(e,t){const[n,r]=h(e,t);return n*r*4}(o,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function kt(e,t,n,r){const i=new Float32Array(n*r*4);return f(e,t,()=>e.readPixels(0,0,r,n,e.RGBA,e.FLOAT,i)),i}var Vt=Object.freeze({__proto__:null,createVertexShader:bt,createVertexBuffer:wt,createIndexBuffer:yt,createFloat32MatrixTexture:At,createFloat16MatrixTexture:It,createUnsignedBytesMatrixTexture:Tt,createPackedMatrixTexture:_t,createFloat16PackedMatrixTexture:Ot,bindVertexProgramAttributeStreams:Nt,uploadDenseMatrixToTexture:St,uploadPixelDataToTexture:Ft,createBufferFromOutputTexture:Dt,downloadFloat32MatrixFromBuffer:Bt,downloadByteEncodedFloatMatrixFromOutputTexture:Pt,downloadPackedMatrixFromBuffer:Lt,downloadMatrixFromPackedOutputTexture:kt});class Wt{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const n=t.env().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,o(n,e)):this.gl=a(n);let r="WEBGL_color_buffer_float";if(1===t.env().getNumber("WEBGL_VERSION")){const e="OES_texture_float",n="OES_texture_half_float";if(this.textureFloatExtension=m(this.gl,this.debug,e),Q(this.gl,n))this.textureHalfFloatExtension=m(this.gl,this.debug,n);else if(t.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Q(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=m(this.gl,this.debug,"EXT_color_buffer_half_float");else if(t.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Q(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Q(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=wt(this.gl,this.debug),this.indexBuffer=yt(this.gl,this.debug),this.framebuffer=T(this.gl,this.debug),this.textureConfig=p(this.gl,this.textureHalfFloatExtension)}get debug(){return t.env().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;f(e,this.debug,()=>e.finish()),f(e,this.debug,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),f(e,this.debug,()=>e.deleteFramebuffer(this.framebuffer)),f(e,this.debug,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),f(e,this.debug,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),f(e,this.debug,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),At(this.gl,this.debug,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),It(this.gl,this.debug,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Tt(this.gl,this.debug,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Ft(this.gl,this.debug,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),St(this.gl,this.debug,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Ot(this.gl,this.debug,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),_t(this.gl,this.debug,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(B(this.gl,this.debug,this.framebuffer),this.outputTexture=null),f(this.gl,this.debug,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Pt(this.gl,this.debug,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,i,o){return Lt(this.gl,e,0,0,0,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Bt(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=Dt(this.gl,this.debug,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(t.env().getBool("WEBGL_FENCE_API_ENABLED")){const t=e,i=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const e=t.clientWaitSync(i,0,0);return e===t.ALREADY_SIGNALED||e===t.CONDITION_SATISFIED},n=i}else t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>kt(this.gl,this.debug,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=v(t,this.debug,e),r=bt(t,this.debug),i=R(t,this.debug);return f(t,this.debug,()=>t.attachShader(i,r)),f(t,this.debug,()=>t.attachShader(i,n)),b(t,this.debug,i),this.debug&&w(t,this.debug,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=Nt(t,this.debug,this.program,this.vertexBuffer)),i}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&f(this.gl,this.debug,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&w(this.gl,this.debug,this.program),f(this.gl,this.debug,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?N(this.gl,this.debug,e,t):S(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),f(this.gl,this.debug,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),F(this.gl,this.debug,this.program,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,i]=h(t,n);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&w(this.gl,this.debug,this.program),P(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),f(e,this.debug,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),f(this.gl,this.debug,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=m(this.gl,this.debug,2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await t.util.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1||t.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),D(this.gl,this.debug,e,this.framebuffer),this.debug&&P(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(D(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&P(this.gl)):B(this.gl,this.debug,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;D(r,this.debug,e,this.framebuffer),this.debug&&P(r),this.outputTexture=e,f(r,this.debug,()=>r.viewport(0,0,t,n)),f(r,this.debug,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),f(this.gl,this.debug,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Ut(e,n){if(e.length!==n.length)throw Error(`Binary was compiled with ${e.length} inputs, but `+`was executed with ${n.length} inputs`);e.forEach((e,r)=>{const i=e.logicalShape,o=n[r],a=o.shape;if(!t.util.arraysEqual(i,a))throw Error("Binary was compiled with different shapes than "+`the current args. Shapes ${i} and ${a} must match`);if(e.isUniform&&o.isUniform)return;const s=e.texShape,u=o.isUniform?null:o.texData.texShape;if(!t.util.arraysEqual(s,u))throw Error("Binary was compiled with different texture shapes than the"+` current args. Shape ${s} and ${u} must match`)})}class Mt{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:i,strideWidth:o,strideHeight:a,padInfo:s,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:d}=n,{left:h,top:p}=s,f=i*r,x=ce(),g="channelsLast"===d,m=g?0:1,C=g?1:2;let v="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)v+=`\n          blockIndex = rc.y + ${r};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${a} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[m]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${o}. - ${h}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${i}.));\n\n              if(d1 < ${t[C]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${i}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+r}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+r}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${x.output} = result;\n      }\n    `}}class Gt{constructor(e,t,n,r,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;let s;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;s=.5===i?`inversesqrt(${u})`:1===i?`1.0/(${u})`:`exp(log(${u}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${s};\n        setOutput(val);\n      }\n    `}}class zt{constructor(e,t,n,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class Xt{constructor(e,t,n,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;let s;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;s=.5===i?`inversesqrt(${u})`:1===i?`1.0/(${u})`:`exp(log(${u}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${s};\n        setOutput(result);\n      }\n    `}}class Ht{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,s=o-1-e.padInfo.left,u=i*o-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class jt{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,s=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=s-1-e.padInfo.front,d=u-1-e.padInfo.top,h=l-1-e.padInfo.left,p=s*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${s};\n           wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${o}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Kt{constructor(e,t,n=!1,r=!1,i=!1,o=null,a=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const s=n?e[1]:e[2],u=Math.ceil(s/2),l=n?"i * 2, rc.y":"rc.y, i * 2",c=r?"rc.z, i * 2":"i * 2, rc.z",d=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let p="",f="";o&&(p=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,f="result = activation(result);");const x=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${p}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          vec4 a = getMatrixA(rc.x, ${l});\n          vec4 b = getMatrixB(rc.x, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${h[0]});\n          result += (${d[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${f}\n\n        setOutput(result);\n      }\n    `}}class Yt{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}class qt{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class Qt{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=le("rc",t),r=Ee(t),i=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let r="";for(let i=e-2;i<e;i++)r+=`${n[i]} >= ${t[i]}`,i<e-1&&(r+="||");return r}(t,e,n),o=function(e,t,n,r){if(1===e)return"";const i=r.slice(-2);return`\n    int r = ${i[0]};\n    int c = ${i[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),a=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let o=`${0===r?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let n=2;n<e;n++)o=`${t[t.length-1-n]},`+o;n.push(o)}return n}(n,t);if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;return`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${i}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class Zt{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,i=Ee(r),o=t.map(e=>e[0]).join(","),a=t.map((t,n)=>t[0]+e[n]).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${s}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Jt{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,i=Ee(r),o=t.map(e=>e[0]).join(","),a=t.map((t,n)=>t[0]+e[n]).join(","),s=le("rc",r),u=le("source",r),l=`${s[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${s[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${s[r-2]} += 1;\n       if(${s[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${s[r-1]} += 1;\n         if(${l}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(${n});\n        } else {\n          ${i} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}class en{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let m="0.0";if(f||(m="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${s});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?i?x:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let C=`${t}(${t}(${t}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(C="avgValue / count");const v=4*Math.floor(o/4),$=o%4,R=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${R}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===$}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${2===$}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${3===$}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${R}\n          }\n        }\n        setOutput(${C});\n      }\n    `}}class tn{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,s=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,x=e.padInfo.front,g=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const C="avg"===t;let v="0.0";if(C||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${s}, ${u});\n        const ivec3 pads = ivec3(${x}, ${g}, ${m});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let $=`${t}(${t}(${t}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&($="avgValue / count");const R=4*Math.floor(o/4),b=o%4,w=`\n      if (${C}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${s}, ${u});\n      const ivec3 pads = ivec3(${x}, ${g}, ${m});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${R}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${w}\n            }\n\n            int xC = xCCorner + ${R};\n            if (${1===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${w}\n            } else if (${2===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${w}\n            } else if (${3===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${w}\n            }\n          }\n          setOutput(${$});\n        }\n      }\n    `}}class nn{constructor(e,t){this.variableNames=["x"];const n=e.windowSize,r=e.batchSize,i=e.inSize,o=Math.ceil(i/n);this.outputShape=[r,o];let a="0.0",s="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",s="min"):"max"===t&&(a="-1.0 / 1e-20",s="max");let u=`${t}(${t}(${t}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${s}(values, minMaxValue);\n      }\n    `,h="vec4";"all"===t?(a="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(a="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";i%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}class rn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${de(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${he(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class on{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;const[,r,i]=t.shape,[,o,a]=e.shape,s=[n&&o>1?r-1:r,n&&a>1?i-1:i],u=[n&&o>1?o-1:o,n&&a>1?a-1:a],l=s[0]/u[0],c=s[1]/u[1],d=1/l,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class an{constructor(e,t,n,r){this.variableNames=["A"],this.outputShape=[];const[i,o,a,s]=e;this.outputShape=[i,t,n,s];const u=[r&&t>1?o-1:o,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class sn{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,a,s]=e;this.outputShape=[i,t,n,s];const u=[r&&t>1?o-1:o,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${s-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class un{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;const[,r,i]=t.shape,[,o,a]=e.shape,s=[n&&o>1?r-1:r,n&&a>1?i-1:i],u=[n&&o>1?o-1:o,n&&a>1?a-1:a],l=s[0]/u[0],c=s[1]/u[1],d=1/l,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${s[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${s[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class ln{constructor(e,t,n,r){this.variableNames=["A"],this.outputShape=[];const[i,o,a,s]=e;this.outputShape=[i,t,n,s];const u=[r&&t>1?o-1:o,r&&n>1?a-1:a],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class cn{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),i=Ee(n);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class dn{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=le("rc",n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Ee(n);function s(n){const r=e.map((r,i)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(i,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return s(e)}(r.slice())};\n          if(${i}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",s(e)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice())};\n            if(${i}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class hn{constructor(e,t,n,r,i,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const s=Ee(i.length),u=Ee(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const c=`getIndices(${l})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`,p=t>1?"strides[j]":"strides";this.userCode=`\n        ${s} strides = ${s}(${i});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class pn{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/n);this.outputShape=[r,a];const s=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";i%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let d="";i%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class fn{constructor(e,t,n){let r,i;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)i="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=[];for(let r=0;r<t.length;r++)a.push(`${n[r]}`),r<e&&o.push(`${n[r]}`);r=o.join(),i=a.join()}const o=Ee(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}class xn{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Ee(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return gn.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let i;i=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${gn[t]} = start[${t}] + coords.${gn[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${i}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the `+`length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const gn=["x","y","z","w","u","v"];class mn{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=Ee(this.rank),n=le("coords",this.rank),r=le("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`\n      result.x = ${o};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,s=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${s}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the `+`length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}class Cn{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,i=Ee(n.length),o=Ee(n.length);let a="";if(1===r)a="coords * strides + begin";else{let e=0;a=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${e});\n      ${i} strides = ${i}(${t});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class vn{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=$n(t,n),i=Rn(e,r,n);if(i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]),this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();const e=this.freeTextures[i].shift();return this.usedTextures[i].push(e),e}let o;return this.numUsedTextures++,this.log(),r===l.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===l.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===l.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===l.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===l.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(o),o}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const i=Rn(t,$n(n,r),r);i in this.freeTextures||(this.freeTextures[i]=[]),this.freeTextures[i].push(e),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures[i],a=o.indexOf(e);if(a<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(a,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`)}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}}}function $n(e,n){if(e===u.UPLOAD)return l.PACKED_2X2_FLOAT32;if(e===u.RENDER||null==e)return function(e){return t.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?l.PACKED_2X2_FLOAT32:l.UNPACKED_FLOAT32:e?l.PACKED_2X2_FLOAT16:l.UNPACKED_FLOAT16}(n);if(e===u.DOWNLOAD||e===u.PIXELS)return l.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Rn(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class bn{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=Ee(this.rank),i=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}class wn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const yn="if (isnan(x)) return x;",En="return abs(x);",An=yn+"\n  return (x < 0.0) ? 0.0 : x;\n",In=yn+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Tn="return (x >= 0.0) ? x : (exp(x) - 1.0);",_n=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${t.backend_util.SELU_SCALEALPHA};\n  float scale = ${t.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;const On="return -x;",Nn="return ceil(x);",Sn="return floor(x);",Fn="return exp(x);",Dn="return exp(x) - 1.0;",Bn=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${t.backend_util.ERF_P};\n  float a1 = ${t.backend_util.ERF_A1};\n  float a2 = ${t.backend_util.ERF_A2};\n  float a3 = ${t.backend_util.ERF_A3};\n  float a4 = ${t.backend_util.ERF_A4};\n  float a5 = ${t.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,Pn="return x;",Ln="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",kn="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Vn="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class Wn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Un{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=le("rc",t),r=Ee(t),i=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const{segment_util:Mn}=t.backend_util,Gn=t.kernel_impls.split,zn=t.kernel_impls.tile,Xn=t.kernel_impls.topkImpl,Hn=t.kernel_impls.whereImpl,jn={};function Kn(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?Ln:An;if("elu"===e)return t?Vn:Tn;if("relu6"===e)return t?kn:In;if("prelu"===e)return t?Ue:Ve;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Yn extends t.KernelBackend{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!t.env().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=a(t.env().getNumber("WEBGL_VERSION"));this.binaryCache=((n=t.env().getNumber("WEBGL_VERSION"))in jn||(jn[n]={}),jn[n]),this.gpgpu=new Wt(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var n;this.textureManager=new vn(this.gpgpu),this.numMBBeforeWarning=null==t.env().global.screen?1024:t.env().global.screen.height*t.env().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new t.DataStorage(this,t.engine())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,n,r){if(t.env().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={};return this.texData.set(i,{shape:n,dtype:r,values:e,usage:u.UPLOAD}),i}move(e,n,r,i){if(t.env().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:i,values:n,usage:u.UPLOAD})}readSync(e){const n=this.texData.get(e),{values:r,dtype:i,complexTensors:o,slice:a,shape:s,isPacked:u}=n;if(null!=a){let t;t=u?new Wn(s,Pn):new wn(s,Pn);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:i}],i),r=this.readSync(n.dataId);return this.disposeData(n.dataId),r}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===i)return r;const l=null!=this.activeTimers;let c,d;if(l&&(c=t.util.now()),"complex64"===i){const e=o.real.dataSync(),n=o.imag.dataSync();d=t.backend_util.mergeRealAndImagArrays(e,n)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=t.util.now()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const n=this.texData.get(e),{values:r,shape:i,slice:o,dtype:a,complexTensors:s,isPacked:u}=n;if(null!=o){let t;t=u?new Wn(i,Pn):new wn(i,Pn);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:a}],a),r=this.read(n.dataId);return this.disposeData(n.dataId),r}if(null!=r)return this.convertAndCacheOnCPU(e);if(!t.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===t.env().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,h=null;if("complex64"!==a&&t.env().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);h=this.gpgpu.createBufferFromTexture(t.texture,...d(i))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([s.real.data(),s.imag.data()]),n=e[0],r=e[1];c=t.backend_util.mergeRealAndImagArrays(n,r)}else if(null==h)c=this.getValuesFromTexture(e);else{const e=t.util.sizeFromShape(i);c=this.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}null!=l&&this.disposeData(l.dataId);const p=this.convertAndCacheOnCPU(e,c),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(e=>e(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e),this.pendingDeletes--),p}checkNumericalProblems(e){if(null!=e)for(let n=0;n<e.length;n++){const r=e[n];if(!x(r)){if(t.env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${r} cannot be represented with your `+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error(`The value ${r} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:i}=this.texData.get(e),o=t.util.sizeFromShape(n);if(t.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const t=this.decode(e),r=this.texData.get(t.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...d(n)).subarray(0,o);return this.disposeData(t.dataId),i}const a=t.env().getBool("WEBGL_PACK")&&!0===i,s=a?M(n):n,u=a?new pt(s):new ht(s),l=this.runWebGLProgram(u,[{shape:s,dtype:r,dataId:e}],"float32"),c=this.texData.get(l.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeData(l.dataId),h}async time(e){const n=this.activeTimers,r=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=t.util.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),a=t.util.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=n,i&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);s.kernelMs=t.util.sum(e),s.getExtraProfileInfo=()=>e.map((e,t)=>({name:a[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}}startTimer(){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:t.util.now(),endMs:null}}endTimer(e){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=t.util.now(),e)}async getQueryTime(e){if(t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e){if(this.pendingDisposal.has(e))return;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(!this.texData.has(e))return;this.releaseGPUData(e);const{complexTensors:t}=this.texData.get(e);null!=t&&(t.real.dispose(),t.imag.dispose()),this.texData.delete(e)}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(e),s=a&&a.origDataId||e,u=this.dataRefCount.get(s);u>1?this.dataRefCount.set(s,u-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,i,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return t.env().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=t.engine().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,n=128){return null!=this.getCPUBackend()&&e.every(e=>null==this.texData.get(e.dataId).texture&&t.util.sizeFromShape(e.shape)<n)}getGPGPUContext(){return this.gpgpu}complex(e,n){const r=this.makeOutput(e.shape,"complex64");return this.texData.get(r.dataId).complexTensors={real:t.engine().keep(e.clone()),imag:t.engine().keep(n.clone())},r}real(e){return this.texData.get(e.dataId).complexTensors.real.clone()}imag(e){return this.texData.get(e.dataId).complexTensors.imag.clone()}slice(e,n,r){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.slice(e,n,r);if(0===t.util.sizeFromShape(r))return t.tensor([],r,e.dtype);const{isPacked:i}=this.texData.get(e.dataId),o=t.slice_util.isSliceContinous(e.shape,n,r);if(i||!o){const i=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mn(r):new xn(r),o=i.getCustomSetupFunc(n);return this.compileAndRun(i,[e],null,o)}return this.uploadToGPU(e.dataId),this.shallowSlice(e,n,r)}shallowSlice(e,n,r){const i=this.texData.get(e.dataId),o=this.makeOutput(r,e.dtype),a=this.texData.get(o.dataId);Object.assign(a,i),a.shape=r,a.dtype=e.dtype;let s=t.slice_util.computeFlatOffset(n,e.strides);i.slice&&(s+=i.slice.flatOffset),a.slice={flatOffset:s,origDataId:i.slice&&i.slice.origDataId||e.dataId};const u=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,u+1),o}stridedSlice(e,n,r,i){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.stridedSlice(e,n,r,i);const o=t.slice_util.computeOutShape(n,r,i);if(o.some(e=>0===e))return t.tensor([],o);const a=new Cn(n,i,o);return this.compileAndRun(a,[e])}reverse(e,n){const r=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dn(e.shape,n):new cn(e.shape,n);return this.compileAndRun(r,[e])}concat(e,n){if("complex64"===e[0].dtype){const r=e.map(e=>t.real(e)),i=e.map(e=>t.imag(e));return t.complex(this.concat(r,n),this.concat(i,n))}if(this.shouldExecuteOnCPU(e))return this.cpuBackend.concat(e,n);if(1===e.length)return e[0];if(e.length>t.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(e.length/2),r=this.concat(e.slice(0,t),n),i=this.concat(e.slice(t),n);return this.concat([r,i],n)}if(t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].rank>1){const t=new je(e.map(e=>e.shape),n);return this.compileAndRun(t,e)}const r=t.backend_util.computeOutShape(e.map(e=>e.shape),n),i=e.map(e=>e.as2D(-1,t.util.sizeFromShape(e.shape.slice(n)))),o=new He(i.map(e=>e.shape));return this.compileAndRun(o,i).reshape(r)}neg(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.neg(e);if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,On,e.dtype);const n=new wn(e.shape,On);return this.compileAndRun(n,[e])}batchMatMul(e,n,r,i){const o=r?e.shape[2]:e.shape[1],a=i?n.shape[1]:n.shape[2],s=r?e.shape[1]:e.shape[2],[u,,]=e.shape;if((1===o||1===a)&&s>1e3){r&&(e=t.transpose(e,[0,2,1])),i&&(n=t.transpose(n,[0,2,1]));const o=1===a?e:e.as3D(u,s,1),l=1===a?2:1,c=1===a?n.as3D(u,1,s):n;return this.multiply(o,c).sum(l,!0)}const l=t.upcastType(e.dtype,n.dtype),c=new Kt(e.shape,[u,o,a],r,i);return this.compileAndRun(c,[e,n],l)}fusedBatchMatMul({a:e,b:n,transposeA:r,transposeB:i,bias:o,activation:a,preluActivationWeights:s}){const u=r?e.shape[2]:e.shape[1],l=i?n.shape[1]:n.shape[2],[c,,]=e.shape,d=t.upcastType(e.dtype,n.dtype),h=null!=o,p=null!=s,f=a?Kn(a,!0):null,x=new Kt(e.shape,[c,u,l],r,i,h,f,p),g=[e,n];return o&&g.push(o),s&&g.push(s),this.compileAndRun(x,g,d)}multiply(e,n){if("complex64"===e.dtype){const t=this.texData.get(e.dataId),r=this.texData.get(n.dataId),i=new Be(Fe,e.shape,n.shape),o=new Be(De,e.shape,n.shape),a=[this.makeComplexComponentTensorInfo(e,t.complexTensors.real),this.makeComplexComponentTensorInfo(e,t.complexTensors.imag),this.makeComplexComponentTensorInfo(n,r.complexTensors.real),this.makeComplexComponentTensorInfo(n,r.complexTensors.imag)],s=this.compileAndRun(i,a),u=this.compileAndRun(o,a),l=this.complex(s,u);return s.dispose(),u.dispose(),l}if(this.shouldExecuteOnCPU([e,n]))return this.cpuBackend.multiply(e,n);if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,ke,e.dtype);const r=new We(ke,e.shape,n.shape);return this.compileAndRun(r,[e,n],e.dtype)}batchNorm(e,n,r,i,o,a){const s=[e,n,r];let u=null;null!=i&&(u=i.shape,s.push(i));let l=null;if(null!=o&&(l=o.shape,s.push(o)),t.env().getBool("WEBGL_PACK_NORMALIZATION")){const t=new Se(e.shape,n.shape,r.shape,u,l,a);return this.compileAndRun(t,s)}const c=new Ne(e.shape,n.shape,r.shape,u,l,a);return this.compileAndRun(c,s)}localResponseNormalization4D(e,n,r,i,o){const a=t.env().getBool("WEBGL_PACK_NORMALIZATION")?new Xt(e.shape,n,r,i,o):new Gt(e.shape,n,r,i,o);return this.compileAndRun(a,[e])}LRNGrad(e,t,n,r,i,o,a){const s=new zt(t.shape,r,i,o,a);return this.compileAndRun(s,[t,n,e])}tile(e,n){if("string"===e.dtype){const r=this.readSync(e.dataId).map(e=>t.util.decodeString(e)),i=t.buffer(e.shape,e.dtype,r);return zn(i,n)}const r=new bn(e.shape,n);return this.compileAndRun(r,[e])}pad(e,n,r){const i=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jt(e.shape,n,r):new Zt(e.shape,n,r);return this.compileAndRun(i,[e])}gather(e,t,n){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.gather(e,t,n);const r=new $t(e.shape,t.size,n);return this.compileAndRun(r,[e,t])}batchToSpaceND(e,n,r){t.util.assert(e.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=n.reduce((e,t)=>e*t),o=t.backend_util.getReshaped(e.shape,n,i),a=t.backend_util.getPermuted(o.length,n.length),s=t.backend_util.getReshapedPermuted(e.shape,n,i),u=t.backend_util.getSliceBeginCoords(r,n.length),l=t.backend_util.getSliceSize(s,r,n.length);return t.transpose(e.reshape(o),a).reshape(s).slice(u,l)}spaceToBatchND(e,n,r){t.util.assert(e.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=n.reduce((e,t)=>e*t),o=[[0,0]];o.push(...r);for(let t=1+n.length;t<e.shape.length;++t)o.push([0,0]);const a=e.pad(o),s=t.backend_util.getReshaped(a.shape,n,i,!1),u=t.backend_util.getPermuted(s.length,n.length,!1),l=t.backend_util.getReshapedPermuted(a.shape,n,i,!1);return t.transpose(a.reshape(s),u).reshape(l)}reduce(e,n,r){const i=e.shape[0],o=e.shape[1],a=t.backend_util.computeOptimalWindowSize(o),s=new nn({windowSize:a,inSize:o,batchSize:i},n),u=this.compileAndRun(s,[e],r);return 1===u.shape[1]?u:this.reduce(u,n,r)}argReduce(e,n,r=null){let i=e.shape[0],o=e.shape[1];null!=r&&(i=r.shape[0],o=r.shape[1]);const a=t.backend_util.computeOptimalWindowSize(o),s=new se({windowSize:a,inSize:o,batchSize:i},n,null==r),u=[e];null!=r&&u.push(r);const l=this.compileAndRun(s,u,"int32");return 1===l.shape[1]?l:this.argReduce(e,n,l)}argReducePacked(e,n,r=null){const i=null!=r?r.shape:e.shape,o=i[i.length-1],a=t.backend_util.computeOptimalWindowSize(o),s=new Te(i,a,n,null==r),u=null==r?[e]:[e,r],l=this.compileAndRun(s,u,"int32");return l.rank===e.rank?this.argReducePacked(e,n,l):l}sum(e,n){t.backend_util.assertAxesAreInnerMostDims("sum",n,e.rank);const[r,i]=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=t.util.sizeFromShape(i),a=e.as2D(-1,o),s=t.sumOutType(e.dtype);return this.reduce(a,"sum",s).reshape(r)}prod(e,n){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.prod(e,n);const[r,i]=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=t.util.sizeFromShape(i),a=e.as2D(-1,o),s=t.sumOutType(e.dtype);return this.reduce(a,"prod",s).reshape(r)}unsortedSegmentSum(e,n,r){let i=0;const o=t.backend_util.getAxesPermutation([i],e.rank);let a=e;null!=o&&(a=t.transpose(e,o),i=t.backend_util.getInnerMostAxes(1,e.rank)[0]);const s=Mn.computeOutShape(a.shape,i,r),u=t.util.sizeFromShape([a.shape[i]]),l=a.as2D(-1,u),c=t.sumOutType(e.dtype);let d=this.segOpCompute(l,"unsortedSegmentSum",n,c,r).reshape(s);return null!=o&&(d=t.transpose(d,t.backend_util.getUndoAxesPermutation(o))),d}segOpCompute(e,n,r,i,o){const a=e.shape[0],s=e.shape[1],u=Mn.segOpComputeOptimalWindowSize(s,o),l=new pn({windowSize:u,inSize:s,batchSize:a,numSegments:o},n),c=this.compileAndRun(l,[e,r],i);return c.shape[1]===o?c:(r=t.range(0,o).tile([s/u]),this.segOpCompute(c,n,r,i,o))}argMinMaxReduce(e,n,r){const i=[n];if(t.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.rank),!t.env().getBool("WEBGL_PACK_REDUCE")||e.rank<=2){const[n,o]=t.backend_util.computeOutAndReduceShapes(e.shape,i),a=t.util.sizeFromShape(o),s=e.as2D(-1,a);return this.argReduce(s,r).reshape(n)}return this.argReducePacked(e,r)}argMin(e,t){return this.argMinMaxReduce(e,t,"min")}argMax(e,t){return this.argMinMaxReduce(e,t,"max")}cumsum(e,t,n,r){if(t!==e.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${e.rank-1} `+`but got axis=${t}`);const i=new at(e.shape,n,r);return this.compileAndRun(i,[e])}equal(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(equal(a, b));\n","bool");const r=new We("return float(a == b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}notEqual(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(notEqual(a, b));\n","bool");const r=new We("return float(a != b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}less(e,n){if(this.shouldExecuteOnCPU([e,n]))return this.cpuBackend.less(e,n);if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(lessThan(a, b));\n","bool");const r=new We("return float(a < b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}lessEqual(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(lessThanEqual(a, b));\n","bool");const r=new We("return float(a <= b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}greater(e,n){if(this.shouldExecuteOnCPU([e,n]))return this.cpuBackend.greater(e,n);if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(greaterThan(a, b));\n","bool");const r=new We("return float(a > b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}greaterEqual(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const r=new We("return float(a >= b);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}logicalNot(e){const t=new wn(e.shape,"return float(!(x >= 1.0));");return this.compileAndRun(t,[e])}logicalAnd(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const r=new We("return float(a >= 1.0 && b >= 1.0);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}logicalOr(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const r=new We("return float(a >= 1.0 || b >= 1.0);",e.shape,n.shape);return this.compileAndRun(r,[e,n],"bool")}select(e,n,r){const i=new fn(e.rank,n.shape,n.rank);return this.compileAndRun(i,[e,n,r],t.upcastType(n.dtype,r.dtype))}where(e){t.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return Hn(e.shape,n)}topk(e,t,n){const r=e.dataSync();return Xn(r,e.shape,e.dtype,t,n)}min(e,n){t.backend_util.assertAxesAreInnerMostDims("min",n,e.rank);const[r,i]=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=t.util.sizeFromShape(i),a=e.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(r)}minimum(e,n){if(this.shouldExecuteOnCPU([e,n]))return this.cpuBackend.minimum(e,n);const r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new We("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",e.shape,n.shape);return this.compileAndRun(r,[e,n])}mod(e,n){const r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new We("if (b == 0.0) return NAN;\n  return mod(a, b);",e.shape,n.shape);return this.compileAndRun(r,[e,n])}maximum(e,n){if(this.shouldExecuteOnCPU([e,n]))return this.cpuBackend.maximum(e,n);const r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new We("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",e.shape,n.shape);return this.compileAndRun(r,[e,n])}all(e,n){t.backend_util.assertAxesAreInnerMostDims("all",n,e.rank);const[r,i]=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=t.util.sizeFromShape(i),a=e.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(r)}any(e,n){t.backend_util.assertAxesAreInnerMostDims("any",n,e.rank);const[r,i]=t.backend_util.computeOutAndReduceShapes(e.shape,n),o=t.util.sizeFromShape(i),a=e.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(r)}floorDiv(e,n){if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");const r=new We("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",e.shape,n.shape);return this.compileAndRun(r,[e,n],"int32")}add(e,n){if("complex64"===e.dtype&&"complex64"===n.dtype)return this.complexSeparableBinaryOp(e,n,Pe);if(this.shouldExecuteOnCPU([e,n]))return this.cpuBackend.add(e,n);const r=t.upcastType(e.dtype,n.dtype);if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,Pe,r);const i=new We(Pe,e.shape,n.shape);return this.compileAndRun(i,[e,n],r)}packedUnaryOp(e,t,n){const r=new Wn(e.shape,t);return this.compileAndRun(r,[e],n)}packedBinaryOp(e,t,n,r,i=!1){const o=new Me(n,e.shape,t.shape,i);return this.compileAndRun(o,[e,t],r)}complexSeparableBinaryOp(e,n,r){const i=this.texData.get(e.dataId),o=this.texData.get(n.dataId),[a,s]=[[i.complexTensors.real,o.complexTensors.real],[i.complexTensors.imag,o.complexTensors.imag]].map(i=>{const[o,a]=i,s=this.makeComplexComponentTensorInfo(e,o),u=this.makeComplexComponentTensorInfo(n,a),l=new We(r,e.shape,n.shape);return this.compileAndRun(l,[s,u],t.upcastType(o.dtype,a.dtype))}),u=this.complex(a,s);return a.dispose(),s.dispose(),u}makeComplexComponentTensorInfo(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}addN(e){if(1===e.length)return e[0];if(e.length>t.env().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(e.length/2),n=this.addN(e.slice(0,t)),r=this.addN(e.slice(t));return this.addN([n,r])}const n=e.map(e=>e.dtype).reduce((e,n)=>t.upcastType(e,n)),r=e.map(e=>e.shape),i=t.env().getBool("WEBGL_PACK")?new ae(e[0].shape,r):new oe(e[0].shape,r);return this.compileAndRun(i,e,n)}subtract(e,n){if("complex64"===e.dtype&&"complex64"===n.dtype)return this.complexSeparableBinaryOp(e,n,Le);if(this.shouldExecuteOnCPU([e,n]))return this.cpuBackend.subtract(e,n);const r=t.upcastType(e.dtype,n.dtype);if(t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,n,Le,e.dtype);const i=new We(Le,e.shape,n.shape);return this.compileAndRun(i,[e,n],r)}pow(e,n){const r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new We("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",e.shape,n.shape),i=t.upcastType(e.dtype,n.dtype);return this.compileAndRun(r,[e,n],i)}ceil(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.ceil(e);if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Nn,e.dtype);const n=new wn(e.shape,Nn);return this.compileAndRun(n,[e])}floor(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.floor(e);if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Sn,e.dtype);const n=new wn(e.shape,Sn);return this.compileAndRun(n,[e])}sign(e){const t=new wn(e.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(t,[e])}isNaN(e){const t=new wn(e.shape,"return float(isnan(x));");return this.compileAndRun(t,[e],"bool")}isInf(e){const t=new wn(e.shape,"return float(isinf(x));");return this.compileAndRun(t,[e],"bool")}isFinite(e){const t=new wn(e.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(t,[e],"bool")}round(e){const t=new wn(e.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(t,[e])}exp(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.exp(e);if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Fn,e.dtype);const n=new wn(e.shape,Fn);return this.compileAndRun(n,[e])}expm1(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.expm1(e);if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Dn,e.dtype);const n=new wn(e.shape,Dn);return this.compileAndRun(n,[e])}softmax(e,n){const r=t.util.parseAxisParam([n],e.shape),i=t.max(e,r),o=t.backend_util.expandShapeToKeepDim(i.shape,r),a=this.subtract(e,i.reshape(o)),s=this.exp(a),u=this.sum(s,r).reshape(o);return t.div(s,u)}log(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.log(e);if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",e.dtype);const n=new wn(e.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(n,[e])}log1p(e){const t=new wn(e.shape,"return log(1.0 + x);");return this.compileAndRun(t,[e])}sqrt(e){const t=new wn(e.shape,"return sqrt(x);");return this.compileAndRun(t,[e])}rsqrt(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.rsqrt(e);const t=new wn(e.shape,"return inversesqrt(x);");return this.compileAndRun(t,[e])}reciprocal(e){const t=new wn(e.shape,"return 1.0 / x;");return this.compileAndRun(t,[e])}relu(e){let n;return n=t.env().getBool("WEBGL_PACK")?new Wn(e.shape,Ln):new wn(e.shape,An),this.compileAndRun(n,[e])}relu6(e){let n;return n=t.env().getBool("WEBGL_PACK")?new Wn(e.shape,kn):new wn(e.shape,In),this.compileAndRun(n,[e])}prelu(e,n){const r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me(Ue,e.shape,n.shape):new We(Ve,e.shape,n.shape);return this.compileAndRun(r,[e,n])}elu(e){if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Vn,e.dtype);const n=new wn(e.shape,Tn);return this.compileAndRun(n,[e])}eluDer(e,n){const r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",e.shape,n.shape):new We("return (b >= 1.0) ? a : a * (b + 1.0);",e.shape,n.shape);return this.compileAndRun(r,[e,n])}selu(e){const t=new wn(e.shape,_n);return this.compileAndRun(t,[e])}int(e){const t=new wn(e.shape,"return float(int(x));");return this.compileAndRun(t,[e],"int32")}clip(e,n,r){let i;i=t.env().getBool("WEBGL_PACK_CLIP")?new ze(e.shape):new Ge(e.shape);const o=i.getCustomSetupFunc(n,r);return this.compileAndRun(i,[e],null,o)}abs(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.abs(e);if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,En,e.dtype);const n=new wn(e.shape,En);return this.compileAndRun(n,[e])}complexAbs(e){const t=this.texData.get(e.dataId),n=new Xe(e.shape),r=[this.makeComplexComponentTensorInfo(e,t.complexTensors.real),this.makeComplexComponentTensorInfo(e,t.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(e){const t=new wn(e.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(t,[e])}softplus(e){const t=new wn(e.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(t,[e])}sin(e){const t=new wn(e.shape,"if (isnan(x)) return x;\n  return sin(x);\n");return this.compileAndRun(t,[e])}cos(e){const t=new wn(e.shape,"if (isnan(x)) return x;\n  return cos(x);\n");return this.compileAndRun(t,[e])}tan(e){const t=new wn(e.shape,"return tan(x);");return this.compileAndRun(t,[e])}asin(e){const t=new wn(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(t,[e])}acos(e){const t=new wn(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(t,[e])}atan(e){const t=new wn(e.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(t,[e])}atan2(e,n){const r=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,n.shape):new We("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",e.shape,n.shape);return this.compileAndRun(r,[e,n])}sinh(e){const t=new wn(e.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])}cosh(e){const t=new wn(e.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])}tanh(e){const t=new wn(e.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(t,[e])}asinh(e){const t=new wn(e.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(t,[e])}acosh(e){const t=new wn(e.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(t,[e])}atanh(e){const t=new wn(e.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(t,[e])}erf(e){const t=new wn(e.shape,Bn);return this.compileAndRun(t,[e])}step(e,t){const n=new wn(e.shape,function(e=0){return yn+`\n    return x > 0.0 ? 1.0 : float(${e});\n  `}(t));return this.compileAndRun(n,[e])}conv2dByMatMul(e,n,r,i,o,a){const s=e.shape,u=this.texData.get(e.dataId),l=r.inChannels,c=s[0]*s[1]*s[2],d=r.outChannels,h="channelsLast"===r.dataFormat,p=(1===c||1===d)&&l>1e3,f=s[2]%2!=0&&!!u.isPacked;if(p||!t.env().getBool("WEBGL_LAZILY_UNPACK")||!t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!f){const t=h?s[0]*s[1]*s[2]:s[0]*s[2]*s[3],u=this.reshape(e,[1,t,r.inChannels]),l=this.reshape(n,[1,r.inChannels,r.outChannels]);return this.reshape(this.fusedBatchMatMul({a:u,b:l,transposeA:!1,transposeB:!1,bias:i,activation:o,preluActivationWeights:a}),r.outShape)}const x=h?s[0]*s[1]*(s[2]+1):s[0]*s[2]*(s[3]+1),g={dataId:e.dataId,shape:[1,x,r.inChannels],dtype:e.dtype},m=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,t.util.assert(X(u.shape,g.shape),()=>`packed reshape ${u.shape} to ${g.shape} isn't free`);const C=this.reshape(n,[1,r.inChannels,r.outChannels]),v=this.fusedBatchMatMul({a:g,b:C,transposeA:!1,transposeB:!1,bias:i,activation:o,preluActivationWeights:a}),$=this.texData.get(v.dataId);return t.util.assert($.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=m,$.shape=r.outShape,t.engine().makeTensorFromDataId(v.dataId,r.outShape,v.dtype)}conv2dWithIm2Row(e,t,n,r,i,o){const{filterWidth:a,filterHeight:s,inChannels:u,outWidth:l,outHeight:c,dataFormat:d}=n,h="channelsLast"===d,p=a*s*u,f=c*l,x=[p,f],g=e.squeeze([0]),m=t.reshape([1,p,-1]),C=new Mt(x,g.shape,n),v=this.compileAndRun(C,[g]).reshape([1,x[0],x[1]]),$=null!=r,R=null!=o,b=i?Kn(i,!0):null,w=new Kt(v.shape,[1,f,n.outChannels],!0,!1,$,b,R),y=[v,m];r&&y.push(r),R&&y.push(o);const E=this.compileAndRun(w,y);return h?E.reshape([1,c,l,n.outChannels]):E.reshape([1,n.outChannels,c,l])}fusedConv2d({input:e,filter:n,convInfo:r,bias:i,activation:o,preluActivationWeights:a}){if(1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type))return this.conv2dByMatMul(e,n,r,i,o,a);if(t.env().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,n,r,i,o,a);const s=null!=i,u=null!=a,l=o?Kn(o,!1):null,c=new tt(r,s,l,u),d=[e,n];return i&&d.push(i),a&&d.push(a),this.compileAndRun(c,d)}conv2d(e,n,r){if(1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type))return this.conv2dByMatMul(e,n,r);if(t.env().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,n,r);const i=new tt(r);return this.compileAndRun(i,[e,n])}conv2dDerInput(e,t,n){const r=new qe(n);return this.compileAndRun(r,[e,t])}conv2dDerFilter(e,t,n){const r=new Ye(n);return this.compileAndRun(r,[e,t])}fusedDepthwiseConv2D({input:e,filter:n,convInfo:r,bias:i,activation:o,preluActivationWeights:a}){const s=t.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&r.strideWidth<=2&&r.outChannels/r.inChannels==1,u=o?Kn(o,s):null,l=[e,n],c=null!=i,d=null!=a;let h;return c&&l.push(i),d&&l.push(a),s?(h=new it(r,c,u,d),this.compileAndRun(h,l)):(h=new rt(r,c,u,d),this.compileAndRun(h,l))}depthwiseConv2D(e,n,r){let i;return t.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&r.strideWidth<=2&&r.outChannels/r.inChannels==1?(i=new it(r),this.compileAndRun(i,[e,n])):(i=new rt(r),this.compileAndRun(i,[e,n]))}depthwiseConv2DDerInput(e,t,n){const r=new et(n);return this.compileAndRun(r,[e,t])}depthwiseConv2DDerFilter(e,t,n){const r=new Je(n);return this.compileAndRun(r,[e,t])}conv3d(e,t,n){const r=new nt(n);return this.compileAndRun(r,[e,t])}conv3dDerInput(e,t,n){const r=new Ze(n);return this.compileAndRun(r,[e,t])}conv3dDerFilter(e,t,n){const r=new Qe(n);return this.compileAndRun(r,[e,t])}maxPool(e,t){const n=new en(t,"max",!1);return this.compileAndRun(n,[e])}avgPool(e,t){const n=new en(t,"avg",!1);return this.compileAndRun(n,[e],"float32")}maxPoolBackprop(e,t,n,r){const i=new en(r,"max",!0),o=this.compileAndRun(i,[t]),a=new Ht(r),s=this.compileAndRun(a,[e,o],t.dtype);return o.dispose(),s}avgPoolBackprop(e,t,n){const r=new _e(n);return this.compileAndRun(r,[e],t.dtype)}cast(e,n){return t.backend_util.castTensor(e,n,this)}unstack(e,t){const n=e.shape[t],r=new Array(e.rank-1);let i=0;for(let n=0;n<e.rank;n++)n!==t&&(r[i++]=e.shape[n]);const o=new Array(e.rank).fill(0),a=e.shape.slice();a[t]=1;const s=new Array(n);for(let n=0;n<s.length;n++)o[t]=n,s[n]=this.slice(e,o,a).reshape(r);return s}avgPool3d(e,t){const n=new tn(t,"avg",!1);return this.compileAndRun(n,[e],"float32")}avgPool3dBackprop(e,t,n){const r=new Oe(n);return this.compileAndRun(r,[e],t.dtype)}maxPool3d(e,t){const n=new tn(t,"max",!1);return this.compileAndRun(n,[e],"float32")}maxPool3dBackprop(e,t,n,r){const i=new tn(r,"max",!0),o=this.compileAndRun(i,[t]),a=new jt(r),s=this.compileAndRun(a,[e,o],t.dtype);return o.dispose(),s}reshape(e,n){const r=this.texData.get(e.dataId);if(r.isPacked&&!X(e.shape,n)&&(null===r.texture||!X(r.shape,n))){const r=this.packedReshape(e,n);return t.engine().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}return t.backend_util.reshapeTensor(e,n)}resizeBilinear(e,n,r,i){const o=t.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sn(e.shape,n,r,i):new an(e.shape,n,r,i);return this.compileAndRun(o,[e],"float32")}resizeBilinearBackprop(e,t,n){const r=new on(e,t,n);return this.compileAndRun(r,[e])}resizeNearestNeighbor(e,t,n,r){const i=new ln(e.shape,t,n,r);return this.compileAndRun(i,[e])}resizeNearestNeighborBackprop(e,t,n){const r=new un(e,t,n);return this.compileAndRun(r,[e])}multinomial(e,n,r,i){const o=n?e:t.softmax(e),a=o.shape[0],s=o.shape[1],u=new Yt(a,s,r),l=u.getCustomSetupFunc(i);return this.compileAndRun(u,[o],"int32",l)}oneHot(e,t,n,r){const i=new qt(e.size,t,n,r);return this.compileAndRun(i,[e])}diag(e){const t=new dt(e.size);return this.compileAndRun(t,[e])}cropAndResize(e,t,n,r,i,o){const a=new ot(e.shape,t.shape,r,i,o);return this.compileAndRun(a,[e,t,n],"float32")}depthToSpace(e,n,r){t.util.assert(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`);const i=e.shape[0],o="NHWC"===r?e.shape[1]:e.shape[2],a="NHWC"===r?e.shape[2]:e.shape[3],s="NHWC"===r?e.shape[3]:e.shape[1],u=o*n,l=a*n,c=s/(n*n),d=new ct("NHWC"===r?[i,u,l,c]:[i,c,u,l],n,r);return this.compileAndRun(d,[e])}split(e,t,n){return Gn(e,t,n)}scatterND(e,n,r){const{sliceRank:i,numUpdates:o,sliceSize:a,strides:s,outputSize:u}=t.backend_util.calculateShapes(n,e,r),l=[u/a,a],c=e.reshape([o,i]),d=n.reshape([o,a]);if(0===u)return t.backend_util.reshapeTensor(t.tensor([]),r);const h=t.scalar(0),p=new hn(o,i,c.rank,d.rank,s,l);return this.compileAndRun(p,[d,c,h]).reshape(r)}sparseToDense(e,n,r,i){const{sliceRank:o,numUpdates:a,strides:s,outputSize:u}=t.backend_util.calculateShapes(n,e,r),l=new hn(a,o,e.rank,n.rank,s,[u,1],!1);return this.compileAndRun(l,[n,e,i]).reshape(r)}fft(e){return this.fftImpl(e,!1)}ifft(e){return this.fftImpl(e,!0)}fftImpl(e,t){const n=this.texData.get(e.dataId),r=new Ct(gt,e.shape,t),i=new Ct(mt,e.shape,t),o=[this.makeComplexComponentTensorInfo(e,n.complexTensors.real),this.makeComplexComponentTensorInfo(e,n.complexTensors.imag)],a=this.compileAndRun(r,o),s=this.compileAndRun(i,o),u=this.complex(a,s).as2D(e.shape[0],e.shape[1]);return a.dispose(),s.dispose(),u}gatherND(e,n){const r=n.shape,i=r[r.length-1],[o,a,s,u]=t.backend_util.prepareAndValidate(e,n),l=n.reshape([a,i]),c=e.reshape([e.size/s,s]),d=new Rt(i,u,[a,s]);return this.compileAndRun(d,[c,l]).reshape(o)}fill(e,n,r){if("string"===(r=r||t.util.inferDtype(n))){const i=t.util.getArrayFromDType(r,t.util.sizeFromShape(e));return i.fill(n),t.engine().makeTensor(i,e,r,this)}{const t=new vt(e,n),i=t.getCustomSetupFunc(n);return this.compileAndRun(t,[],r,i)}}onesLike(e){if("string"===e.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(e.shape,1,e.dtype)}zerosLike(e){return this.fill(e.shape,"string"===e.dtype?"":0,e.dtype)}linspace(e,n,r){return t.backend_util.linspaceImpl(e,n,r)}makeTensorInfo(e,t){const n=this.write(null,e,t);return this.texData.get(n).usage=null,{dataId:n,shape:e,dtype:t}}makeOutput(e,n){const{dataId:r}=this.makeTensorInfo(e,n);return t.engine().makeTensorFromDataId(r,e,n,this)}unpackTensor(e){const t=new Un(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Qt(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[W(e.shape),...U(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},i=[W(t),...U(t)],o=new rn(i,n),a=this.runWebGLProgram(o,[r],e.dtype,null,!0);return{dataId:a.dataId,shape:t,dtype:a.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:i}=t,o=M(r);let a;a=n?new lt(o):new ut(o);return{dtype:i,shape:r,dataId:this.runWebGLProgram(a,[{shape:o,dtype:i,dataId:e}],i,null,!0).dataId}}runWebGLProgram(e,n,r,i,o=!1){const a=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(a.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===s.DENSE){const t=d(e.outputShape);u.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===t.util.sizeFromShape(a.shape))return u.values=t.util.getTypedArrayFromDType(a.dtype,0),a;const l=[],c=n.map(n=>{if("complex64"===n.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let r=this.texData.get(n.dataId);if(null==r.texture){if(!e.packedInputs&&t.util.sizeFromShape(n.shape)<=t.env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:n.shape,texData:null,isUniform:!0,uniformValues:r.values};e.packedInputs&&(r.isPacked=!0,r.shape=n.shape)}else if(!!r.isPacked!=!!e.packedInputs)n=r.isPacked?this.unpackTensor(n):this.packTensor(n),l.push(n),r=this.texData.get(n.dataId);else if(r.isPacked&&!X(r.shape,n.shape)){const e=n,t=n.shape;n.shape=r.shape,n=this.packedReshape(n,t),l.push(n),r=this.texData.get(n.dataId),e.shape=t}return this.uploadToGPU(n.dataId),{shape:n.shape,texData:r,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:u,isUniform:!1},p=function(e,t,n){let r="";t.concat(n).forEach(e=>{const t=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,n=e.isUniform?"uniform":e.texData.texShape;r+=`${e.shape}_${n}_${t}`});const i=e.userCode;let o=e.constructor.name;return o+="_"+r+"_"+i,o}(e,c,h),f=this.getAndSaveBinary(p,()=>function(e,n,r,i){const o=n.userCode,a=r.map((e,t)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:n.variableNames[t],shapeInfo:r}}),s=a.map(e=>e.shapeInfo),u={logicalShape:i.shape,texShape:i.texData.texShape,isUniform:!1,isPacked:i.texData.isPacked,flatOffset:null},l=xe(a,u,o,n.packedInputs),c=e.createProgram(l);let d=null;const h=e.getUniformLocation(c,"NAN",!1);1===t.env().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(c,"INFINITY",!1));const p={};for(let t=0;t<n.variableNames.length;t++){const r=n.variableNames[t],i=!1;p[r]=e.getUniformLocation(c,r,i),p[`offset${r}`]=e.getUniformLocation(c,`offset${r}`,i)}return{program:n,source:l,webGLProgram:c,uniformLocations:p,inShapeInfos:s,outShapeInfo:u,infLoc:d,nanLoc:h}}(this.gpgpu,e,c,h)),x=null!=this.activeTimers;let g;if(x&&(g=this.startTimer()),function(e,n,r,i,o){Ut(n.inShapeInfos,r),Ut([n.outShapeInfo],[i]);const a=i.texData.texture,s=i.texData.texShape;i.texData.isPacked?e.setOutputPackedMatrixTexture(a,s[0],s[1]):e.setOutputMatrixTexture(a,s[0],s[1]),e.setProgram(n.webGLProgram),1===t.env().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&e.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&e.gl.uniform1f(n.nanLoc,NaN),r.forEach((r,i)=>{const o=n.program.variableNames[i],a=n.uniformLocations[o],s=n.uniformLocations[`offset${o}`];if(null!=a)if(r.isUniform)if(t.util.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture,a,i)}),null!=o&&o(e,n.webGLProgram),e.executeProgram()}(this.gpgpu,f,c,h,i),l.forEach(e=>this.disposeData(e.dataId)),x&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)})),!t.env().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===o){const e=this.unpackTensor(a);return this.disposeData(a.dataId),e}return a}compileAndRun(e,n,r,i,o=!1){r=r||n[0].dtype;const a=this.runWebGLProgram(e,n,r,i,o);return t.engine().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!t.env().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=t.tidy(()=>{if(!t.env().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=t.env().getBool("DEBUG");t.env().set("DEBUG",!1);const n=this.abs(t.scalar(1e-8)).dataSync()[0];if(t.env().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:i,values:o,texture:a,usage:s,isPacked:l}=n;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=t.util.now());let p=n.texShape;if(null==p&&(p=G(r,l),n.texShape=p),null!=o){const e=M(r);let a,s=p[1],f=p[0];const x=o instanceof Uint8Array;l?([s,f]=h(p[0],p[1]),a=new xt(e,[f,s],x)):a=new ft(e,[f,s],x);const g=this.makeTensorInfo([f,s],i);this.texData.get(g.dataId).usage=x?u.PIXELS:u.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),s,f,o);const m=!0,C=this.runWebGLProgram(a,[g],i,null,m),v=this.texData.get(C.dataId);n.texture=v.texture,n.texShape=v.texShape,n.isPacked=v.isPacked,n.usage=v.usage,this.disposeData(g.dataId),this.texData.delete(C.dataId),n.values=null,c&&(this.uploadWaitMs+=t.util.now()-d)}else{const e=this.acquireTexture(p,s,i,l);n.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, `+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,n){return e[0]*e[1]*t.util.bytesPerElement(n)}}const qn={kernelName:t.Div,backendName:"webgl",kernelFunc:({inputs:e,backend:n})=>{const{a:r,b:i}=e;return function(e,n,r){let i=new We("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",e.shape,n.shape);return t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&(i=new Me("\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",e.shape,n.shape,!0)),r.runWebGLProgram(i,[e,n],"float32")}(r,i,n)}};class Qn{constructor(e){this.variableNames=["A"];const t=ce(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Zn{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ce(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const Jn={kernelName:t.FromPixels,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e;let{pixels:o}=n;const{numChannels:a}=i,s="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,[c,d]=s?[o.videoWidth,o.videoHeight]:[o.width,o.height],h=[d,c],p=[d,c,a];(l||s)&&(null==er&&(er=document.createElement("canvas").getContext("2d")),er.canvas.width=c,er.canvas.height=d,er.drawImage(o,0,0,c,d),o=er.canvas);const f=r.makeTensorInfo(h,"int32");r.texData.get(f.dataId).usage=u.PIXELS,r.gpgpu.uploadPixelDataToTexture(r.getTexture(f.dataId),o);const x=t.env().getBool("WEBGL_PACK")?new Zn(p):new Qn(p),g=r.runWebGLProgram(x,[f],"int32");return r.disposeData(f.dataId),g}};let er;var tr=Object.freeze({__proto__:null,maxImpl:function(e,n,r,i){const o=t.util.getTypedArrayFromDType(i,t.util.sizeFromShape(r));for(let t=0;t<o.length;++t){const r=t*n;let i=e[r];for(let t=0;t<n;++t){const n=e[r+t];n>i&&(i=n)}o[t]=i}return o},transposeImpl:function(e,n,r,i,o){const a=n.length,s=t.util.sizeFromShape(n),u=t.util.computeStrides(n),l=t.util.computeStrides(o),c=t.util.getTypedArrayFromDType(r,t.util.sizeFromShape(o));for(let n=0;n<s;++n){const r=t.util.indexToLoc(n,a,u),o=new Array(r.length);for(let e=0;e<o.length;e++)o[e]=r[i[e]];c[t.util.locToIndex(o,a,l)]=e[n]}return c}});t.kernel_impls.nonMaxSuppressionV3,t.kernel_impls.split,t.kernel_impls.tile,t.kernel_impls.topkImpl,t.kernel_impls.whereImpl;const{maxImpl:nr,transposeImpl:rr}=tr;function ir(e,t,n){const r=n.texData.get(e.dataId);return!r.isPacked||X(e.shape,t)||null!==r.texture&&X(r.shape,t)?{dataId:e.dataId,shape:t,dtype:e.dtype}:function(e,t,n){const r=[W(e.shape),...U(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},o=[W(t),...U(t)],a=new rn(o,r),s=n.runWebGLProgram(a,[i],e.dtype,null,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}(e,t,n)}function or(e,n,r,i){const o=t.util.sizeFromShape(n),a=ir(e,[t.util.sizeFromShape(e.shape)/o,o],i),s=function e(n,r,i,o){const[a,s]=n.shape,u=t.backend_util.computeOptimalWindowSize(s),l=new nn({windowSize:u,inSize:s,batchSize:a},i),c=o.runWebGLProgram(l,[n],r);return 1===c.shape[1]?c:e(c,r,i,o)}(a,e.dtype,"max",i);return a.dataId!==e.dataId&&i.disposeData(a.dataId),ir(s,r,i)}class ar{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=Ee(this.rank),i=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class sr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Ee(this.rank),i=ue("rc",this.rank),o=new Array(this.rank);for(let e=0;e<t.length;e++)o[t[e]]=i[e];const a=`vec2(${o.slice(-2).join()})`,s=`++${i[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${s}) {\n        result[1] = ${u};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${s}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function ur(e,n,r){const i=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sr(e.shape,n):new ar(e.shape,n);return r.runWebGLProgram(i,[e],e.dtype)}const lr={kernelName:t.Max,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:r})=>{const{x:i}=e,{reductionIndices:o}=n,a=r,s=i.shape.length;let u=t.util.parseAxisParam(o,i.shape);const l=t.backend_util.getAxesPermutation(u,s),c=null!=l,d=a.shouldExecuteOnCPU([i]);let h=i;if(c){if(d){const e=a.texData.get(h.dataId).values,t=new Array(s);for(let e=0;e<t.length;e++)t[e]=i.shape[l[e]];const n=rr(e,i.shape,i.dtype,l,t);h=a.makeTensorInfo(t,i.dtype),a.texData.get(h.dataId).values=n}else h=ur(i,l,a);u=t.backend_util.getInnerMostAxes(u.length,s)}t.backend_util.assertAxesAreInnerMostDims("max",u,s);const[p,f]=t.backend_util.computeOutAndReduceShapes(h.shape,u);let x;if(d){const e=a.texData.get(h.dataId).values,n=nr(e,t.util.sizeFromShape(f),p,i.dtype);x=a.makeTensorInfo(p,i.dtype),a.texData.get(x.dataId).values=n}else x=or(h,f,p,a);return c&&a.disposeData(h.dataId),x}};const cr={kernelName:t.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:r})=>{const{x:i}=e,{filterSize:o,strides:a,pad:s,includeBatchInIndex:u}=n,l=r;t.util.assert(4===i.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);const c=[1,1];t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(a,c),()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${a} and dilations '${c}'`);const d=t.backend_util.computePool2DInfo(i.shape,o,a,c,s),[h,p]=function(e,t,n,r){let i=new en(n,"max",!1);const o=r.runWebGLProgram(i,[e],"float32");return i=new en(n,"max",!0,!0,t),[o,r.runWebGLProgram(i,[e],"float32")]}(i,u,d,l);return[h,p]}},dr={kernelName:t.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:r})=>{t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:i,scores:o}=e,{maxOutputSize:a,iouThreshold:s,scoreThreshold:u}=r,l=n,c=l.readSync(i.dataId),d=l.readSync(o.dataId),h=a,p=s,f=u;return t.kernel_impls.nonMaxSuppressionV3(c,d,h,p,f)}},hr=t.kernel_impls.nonMaxSuppressionV5,pr=[lr,Jn,qn,dr,{kernelName:t.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:r})=>{t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:i,scores:o}=e,{maxOutputSize:a,iouThreshold:s,scoreThreshold:u,softNmsSigma:l}=r,c=n,d=c.readSync(i.dataId),h=c.readSync(o.dataId),p=a,f=s,x=u,g=l,{selectedIndices:m,selectedScores:C}=hr(d,h,p,f,x,g);return[m,C]}},{kernelName:t.Square,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,i=new wn(n.shape,"return x * x;");return r.runWebGLProgram(i,[n],n.dtype)}},{kernelName:t.SquaredDifference,backendName:"webgl",kernelFunc:({inputs:e,backend:n})=>{const{a:r,b:i}=e,o=n,a=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Me("return (a - b) * (a - b);",r.shape,i.shape):new We("return (a - b) * (a - b);",r.shape,i.shape);return o.compileAndRun(a,[r,i])}},{kernelName:t.Transpose,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{perm:i}=t,o=n,a=r.shape.length,s=new Array(a);for(let e=0;e<s.length;e++)s[e]=r.shape[i[e]];let u;if(o.shouldExecuteOnCPU([r])){const e=o.texData.get(r.dataId).values,t=rr(e,r.shape,r.dtype,i,s);u=o.makeTensorInfo(s,r.dtype),o.texData.get(u.dataId).values=t}else u=ur(r,i,o);return u}},cr];for(const e of pr)t.registerKernel(e);function fr(){t.env().set("WEBGL_FORCE_F16_TEXTURES",!0)}t.device_util.isBrowser()&&t.registerBackend("webgl",()=>new Yn,2);const xr={forceHalfFloat:fr};e.GPGPUContext=Wt,e.MathBackendWebGL=Yn,e.forceHalfFloat=fr,e.gpgpu_util=Vt,e.setWebGLContext=o,e.version_webgl="2.0.1",e.webgl=xr,e.webgl_util=re,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-webgl.es2017.min.js.map
