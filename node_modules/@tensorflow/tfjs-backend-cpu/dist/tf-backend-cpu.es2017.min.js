/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],e):e((t=t||self).tf=t.tf||{},t.tf,t.seedrandom)}(this,(function(t,e,a){"use strict";function r(t,a,r,n){const s=e.util.getTypedArrayFromDType(n,e.util.sizeFromShape(r));for(let e=0;e<s.length;++e){const r=e*a;let n=t[r];for(let e=0;e<a;++e){const a=t[r+e];a>n&&(n=a)}s[e]=n}return s}function n(t,a,r,n,s){const o=a.length,i=e.util.sizeFromShape(a),l=e.util.computeStrides(a),d=e.util.computeStrides(s),h=e.util.getTypedArrayFromDType(r,e.util.sizeFromShape(s));for(let a=0;a<i;++a){const r=e.util.indexToLoc(a,o,l),s=new Array(r.length);for(let t=0;t<s.length;t++)s[t]=r[n[t]];h[e.util.locToIndex(s,o,d)]=t[a]}return h}var s=Object.freeze({__proto__:null,maxImpl:r,transposeImpl:n});function o(t,a){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&e.util.assert("complex64"!==t.dtype,()=>`${a} does not support complex64 tensors in the CPU backend.`)})}function i(t,a,r,n,s,o){const i=s.strideHeight,l=s.strideWidth,d=s.dilationHeight,h=s.dilationWidth,c=s.effectiveFilterHeight,u=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=e.buffer(s.outShape,r),g=y.values,S=s.outShape[1]*s.outShape[2]*s.outShape[3],I=s.outShape[2]*s.outShape[3],b=s.outShape[3];for(let e=0;e<s.batchSize;++e){const a=e*S,r=e*n[0];for(let e=0;e<s.inChannels;++e)for(let y=0;y<s.outHeight;++y){const S=y*i-p,k=Math.max(0,S),M=Math.min(s.inHeight,c+S),x=a+y*I;for(let a=0;a<s.outWidth;++a){const i=a*l-f,c=Math.max(0,i),p=Math.min(s.inWidth,u+i);let y=m,S=0,I=0;for(let a=k;a<M;a+=d){const s=r+a*n[1];for(let a=c;a<p;a+=h){const r=t[s+a*n[2]+e];"max"===o&&r>y?y=r:"avg"===o&&(S+=r,I++)}if(isNaN(y))break}g[x+a*b+e]="avg"===o?S/I:y}}}return y}function l(t,a,r,n,s=!1,o=!1){const i=e.buffer(n.outShape,"int32"),l=n.strideHeight,d=n.strideWidth,h=n.dilationHeight,c=n.dilationWidth,u=n.effectiveFilterHeight,p=n.effectiveFilterWidth,f=n.padInfo.top,m=n.padInfo.left,y=e.buffer(a,r,t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let a=0;a<n.outHeight;++a){const r=a*l-f;let g=r;for(;g<0;)g+=h;const S=Math.min(n.inHeight,u+r);for(let l=0;l<n.outWidth;++l){const u=l*d-m;let f=u;for(;f<0;)f+=c;const I=Math.min(n.inWidth,p+u);let b=Number.NEGATIVE_INFINITY,k=-1;for(let a=g;a<S;a+=h){const i=a-r;for(let r=f;r<I;r+=c){const l=r-u,d=y.get(t,a,r,e);d>b&&(b=d,k=s?o?((t*n.inHeight+a)*n.inWidth+r)*n.inChannels+e:(a*n.inWidth+r)*n.inChannels+e:i*p+l)}}i.set(k,t,a,l,e)}}return i}const d=e.kernel_impls.nonMaxSuppressionV3,h=e.kernel_impls.split,c=e.kernel_impls.tile,u=e.kernel_impls.topkImpl,p=e.kernel_impls.whereImpl;function f(t,e,a,r){if("linear"===a)return t.linear(e);if("relu"===a)return t.relu(e);if("elu"===a)return t.elu(e);if("relu6"===a)return t.relu6(e);if("prelu"===a)return t.prelu(e,r);throw new Error(`Activation ${a} has not been implemented for the CPU backend.`)}class m extends e.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new e.DataStorage(this,e.engine())}write(t,a,r){this.firstUse&&(this.firstUse=!1,e.env().get("IS_NODE")&&e.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const n={};return this.data.set(n,{values:t,dtype:r}),n}move(t,e,a,r){this.data.set(t,{values:e,dtype:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:a,complexTensors:r}=this.data.get(t);if("complex64"===a){const t=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return e.backend_util.mergeRealAndImagArrays(t,a)}return this.data.get(t).values}bufferSync(t){const a=this.readSync(t.dataId);let r=a;if("string"===t.dtype)try{r=a.map(t=>e.util.decodeString(t))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return e.buffer(t.shape,t.dtype,r)}makeOutput(t,a,r){const n=this.write(t,a,r);return e.engine().makeTensorFromDataId(n,a,r,this)}disposeData(t){if(this.data.has(t)){const{complexTensors:e}=this.data.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}}async time(t){const a=e.util.now();return t(),{kernelMs:e.util.now()-a}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(t,a){const r=this.makeOutput(null,t.shape,"complex64");return this.data.get(r.dataId).complexTensors={real:e.engine().keep(t.clone()),imag:e.engine().keep(a.clone())},r}real(t){return this.data.get(t.dataId).complexTensors.real.clone()}imag(t){return this.data.get(t.dataId).complexTensors.imag.clone()}slice(t,a,r){if(o(t,"slice"),e.slice_util.isSliceContinous(t.shape,a,r)){const n=e.slice_util.computeFlatOffset(a,t.strides),s=e.util.sizeFromShape(r),o=this.readSync(t.dataId);return e.tensor(o.subarray(n,n+s),r,t.dtype)}const n=e.buffer(r,t.dtype),s=this.bufferSync(t);for(let t=0;t<n.size;++t){const e=n.indexToLoc(t).map((t,e)=>t+a[e]);n.values[t]=s.get(...e)}return n.toTensor()}stridedSlice(t,a,r,n){o(t,"stridedSlice");const s=e.slice_util.computeOutShape(a,r,n);if(s.some(t=>0===t))return e.tensor([],s);const i=e.buffer(s,t.dtype),l=this.bufferSync(t);for(let t=0;t<i.size;t++){const e=i.indexToLoc(t),r=new Array(e.length);for(let t=0;t<r.length;t++)r[t]=e[t]*n[t]+a[t];i.set(l.get(...r),...e)}return i.toTensor()}diag(t){const a=this.readSync(t.dataId),r=e.buffer([t.size,t.size],t.dtype),n=r.values;for(let e=0;e<a.length;e++)n[e*t.size+e]=a[e];return r.toTensor()}unstack(t,e){const a=t.shape[e],r=new Array(t.rank-1);let n=0;for(let a=0;a<t.rank;a++)a!==e&&(r[n++]=t.shape[a]);const s=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const i=new Array(a);for(let a=0;a<i.length;a++)s[e]=a,i[a]=this.slice(t,s,o).reshape(r);return i}reverse(t,a){o(t,"reverse");const r=e.buffer(t.shape,t.dtype),n=this.bufferSync(t);for(let e=0;e<r.size;e++){const s=r.indexToLoc(e),o=s.slice();a.forEach(e=>o[e]=t.shape[e]-1-o[e]),r.set(n.get(...o),...s)}return r.toTensor()}concat(t,a){if("complex64"===t[0].dtype){const r=t.map(t=>e.real(t)),n=t.map(t=>e.imag(t));return e.complex(this.concat(r,a),this.concat(n,a))}const r=t.map(t=>{const r=e.util.sizeFromShape(t.shape.slice(a));return t.as2D(-1,r)}),n=e.backend_util.computeOutShape(r.map(t=>t.shape),1),s=e.buffer(n,t[0].dtype).values;if(1===r[0].shape[0]){let t=0;r.forEach(e=>{s.set(this.readSync(e.dataId),t),t+=e.size})}else{let t=0;r.forEach(e=>{const a=this.readSync(e.dataId);let r=0;for(let o=0;o<e.shape[0];++o){const i=o*n[1]+t;for(let t=0;t<e.shape[1];++t)s[i+t]=a[r++]}t+=e.shape[1]})}const o=e.backend_util.computeOutShape(t.map(t=>t.shape),a);return e.tensor(s,o,t[0].dtype)}neg(t){return o(t,"neg"),this.multiply(e.scalar(-1),t)}add(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,r)=>({real:t+a,imag:e+r})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t+e)}addN(t){o(t,"addN");const a=t.map(t=>this.readSync(t.dataId)),r=e.buffer(t[0].shape,t[0].dtype),n=r.values;for(let e=0;e<t.length;e++){const t=a[e];for(let e=0;e<n.length;e++)n[e]+=t[e]}return r.toTensor()}softmax(t,a){const r=e.util.parseAxisParam([a],t.shape),n=e.max(t,r),s=e.backend_util.expandShapeToKeepDim(n.shape,r),o=this.subtract(t,n.reshape(s)),i=this.exp(o),l=this.sum(i,r).reshape(s);return e.div(i,l)}subtract(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,r)=>({real:t-a,imag:e-r})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t-e)}pow(t,e){return o([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}batchMatMul(t,a,r,n){o([t,a],"matMul");const s=r?t.shape[1]:t.shape[2],i=r?t.shape[2]:t.shape[1],l=n?a.shape[1]:a.shape[2],d=t.shape[0],h=this.readSync(t.dataId),c=this.readSync(a.dataId),[u,p,f]=r?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],[m,y,g]=n?[1,a.strides[1],a.strides[0]]:[a.strides[1],1,a.strides[0]],S=i*l,I=e.buffer([d,i,l],t.dtype),b=I.values,k=this.blockSize;for(let t=0;t<d;t++)for(let e=0;e<i;e+=k)for(let a=0;a<l;a+=k)for(let r=0;r<s;r+=k){const n=Math.min(e+k,i),o=Math.min(a+k,l),d=Math.min(r+k,s);for(let s=e;s<n;s++)for(let e=a;e<o;e++){let a=0;for(let n=r;n<d;n++)a+=h[t*u+s*p+n*f]*c[n*m+e*y+t*g];b[t*S+(s*l+e)]+=a}}return I.toTensor()}fusedBatchMatMul({a:t,b:e,transposeA:a,transposeB:r,bias:n,activation:s,preluActivationWeights:o}){let i=this.batchMatMul(t,e,a,r);return n&&(i=this.add(i,n)),s&&(i=f(this,i,s,o)),i}multiply(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,r)=>({real:t*a-e*r,imag:t*r+e*a})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t*e)}floorDiv(t,e){o([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",(t,e)=>Math.floor(t/e))}sum(t,a){o(t,"sum"),e.backend_util.assertAxesAreInnerMostDims("sum",a,t.rank);const[r,n]=e.backend_util.computeOutAndReduceShapes(t.shape,a),s=e.upcastType(t.dtype,"int32"),i=e.zeros(r,s),l=e.util.sizeFromShape(n),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=0;for(let t=0;t<l;++t)a+=h[e+t];d[t]=a}return i}prod(t,a){o(t,"sum");const[r,n]=e.backend_util.computeOutAndReduceShapes(t.shape,a),s=e.upcastType(t.dtype,"int32"),i=e.zeros(r,s),l=e.util.sizeFromShape(n),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=1;for(let t=0;t<l;++t)a*=h[e+t];d[t]=a}return i}unsortedSegmentSum(t,a,r){o(t,"unsortedSegmentSum");const n=[],s=t.rank-a.rank;for(let t=0;t<s;++t)a=a.expandDims(t+1);for(let s=0;s<r;++s){const r=e.scalar(s,"int32"),o=e.equal(r,a).asType("float32").mul(t).sum(0);n.push(o)}return e.stack(n)}argMin(t,a){o(t,"argMin");const r=[a];e.backend_util.assertAxesAreInnerMostDims("argMin",r,t.rank);const[n,s]=e.backend_util.computeOutAndReduceShapes(t.shape,r),i=e.zeros(n,"int32"),l=e.util.sizeFromShape(s),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=h[e],r=0;for(let t=0;t<l;++t){const n=h[e+t];n<a&&(a=n,r=t)}d[t]=r}return i}argMax(t,a){o(t,"argMax");const r=[a];e.backend_util.assertAxesAreInnerMostDims("argMax",r,t.rank);const[n,s]=e.backend_util.computeOutAndReduceShapes(t.shape,r),i=e.zeros(n,"int32"),l=e.util.sizeFromShape(s),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=h[e],r=0;for(let t=0;t<l;++t){const n=h[e+t];n>a&&(a=n,r=t)}d[t]=r}return i}cumsum(t,a,r,n){if(o(t,"cumsum"),a!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} `+`but got axis=${a}`);const s=e.upcastType(t.dtype,"int32"),i=e.zeros(t.shape,s),l=this.readSync(i.dataId),d=this.readSync(t.dataId),h=t.shape[t.rank-1],c=n?(t,e)=>t+h-e-1:(t,e)=>t+e;for(let t=0;t<d.length;t+=h)for(let e=0;e<h;e++){const a=c(t,e);if(0===e)l[a]=r?0:d[a];else{const n=c(t,e-1);l[a]=r?d[n]+l[n]:d[a]+l[n]}}return i}equal(t,e){return o([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t===e?1:0)}notEqual(t,e){return o([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t!==e?1:0)}less(t,e){return o([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<e?1:0)}lessEqual(t,e){return o([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<=e?1:0)}greater(t,e){return o([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>e?1:0)}greaterEqual(t,e){return o([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>=e?1:0)}logicalNot(t){o(t,"logicalNot");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)a[t]=e[t]?0:1;return this.makeOutput(a,t.shape,"bool")}logicalAnd(t,e){return o([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t&&e)}logicalOr(t,e){return o([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t||e)}select(t,a,r){o([t,a,r],"select");const n=this.readSync(t.dataId),s=this.readSync(a.dataId),i=this.readSync(r.dataId),l=e.zeros(a.shape,e.upcastType(a.dtype,r.dtype)),d=this.readSync(l.dataId);let h=0;const c=0===t.rank||t.rank>1||1===a.rank?1:e.util.sizeFromShape(a.shape.slice(1));for(let t=0;t<n.length;t++)for(let e=0;e<c;e++)1===n[t]?d[h++]=s[t]:d[h++]=i[t];return l}where(t){o([t],"where");const e=this.readSync(t.dataId);return p(t.shape,e)}topk(t,e,a){o(t,"topk");const r=this.readSync(t.dataId);return u(r,t.shape,t.dtype,e,a)}min(t,a){o(t,"min"),e.backend_util.assertAxesAreInnerMostDims("min",a,t.rank);const[r,n]=e.backend_util.computeOutAndReduceShapes(t.shape,a),s=e.zeros(r,t.dtype),i=e.util.sizeFromShape(n),l=this.readSync(s.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const r=d[e+t];r<a&&(a=r)}l[t]=a}return s}minimum(t,e){return o([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return o([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const a=t%e;return t<0&&e<0||t>=0&&e>=0?a:(a+e)%e})}maximum(t,e){return o([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(t,a){o(t,"all"),e.backend_util.assertAxesAreInnerMostDims("all",a,t.rank);const[r,n]=e.backend_util.computeOutAndReduceShapes(t.shape,a),s=e.zeros(r,t.dtype),i=e.util.sizeFromShape(n),l=this.readSync(s.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const r=d[e+t];a=a&&r}l[t]=a}return s}any(t,a){o(t,"any"),e.backend_util.assertAxesAreInnerMostDims("any",a,t.rank);const[r,n]=e.backend_util.computeOutAndReduceShapes(t.shape,a),s=e.zeros(r,t.dtype),i=e.util.sizeFromShape(n),l=this.readSync(s.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const r=d[e+t];a=a||r}l[t]=a}return s}squaredDifference(t,e){return o([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const a=t-e;return a*a})}ceil(t){o(t,"ceil");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.ceil(e[t]);return this.makeOutput(a,t.shape,"float32")}floor(t){o(t,"floor");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.floor(e[t]);return this.makeOutput(a,t.shape,"float32")}sign(t){o(t,"x");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)e[t]<0?a[t]=-1:e[t]>0?a[t]=1:a[t]=0;return this.makeOutput(a,t.shape,"float32")}isNaN(t){o(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isNaN(e[t])&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}isInf(t){o(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Math.abs(e[t])===1/0&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}isFinite(t){o(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isFinite(e[t])&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}round(t){o(t,"round");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=Math.floor(e[t]);e[t]-r<.5?a[t]=Math.floor(e[t]):e[t]-r>.5?a[t]=Math.ceil(e[t]):a[t]=r%2==0?r:r+1}return this.makeOutput(a,t.shape,"float32")}exp(t){o(t,"exp");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.exp(e[t]);return this.makeOutput(a,t.shape,"float32")}expm1(t){o(t,"expm1");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.expm1(e[t]);return this.makeOutput(a,t.shape,"float32")}log(t){o(t,"log");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.log(r)}return this.makeOutput(a,t.shape,"float32")}log1p(t){o(t,"log1p");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.log1p(r)}return this.makeOutput(a,t.shape,"float32")}sqrt(t){o(t,"sqrt");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.sqrt(r)}return this.makeOutput(a,t.shape,"float32")}rsqrt(t){o(t,"rsqrt");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=1/Math.sqrt(r)}return this.makeOutput(a,t.shape,"float32")}reciprocal(t){o(t,"reciprocal");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=1/e[t];return this.makeOutput(a,t.shape,"float32")}linear(t){return t}relu(t){o(t,"relu");const a=e.zeros(t.shape,t.dtype),r=this.readSync(a.dataId),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)r[t]=Math.max(0,n[t]);return a}relu6(t){o(t,"relu");const a=e.zeros(t.shape,t.dtype),r=this.readSync(a.dataId),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)r[t]=Math.min(Math.max(0,n[t]),6);return a}prelu(t,e){return o([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>t<0?e*t:t)}elu(t){o(t,"elu");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t){const r=a[t];e[t]=r>=0?r:Math.exp(r)-1}return this.makeOutput(e,t.shape,"float32")}eluDer(t,e){o([t,e],"eluDer");const a=new Float32Array(e.size),r=this.readSync(e.dataId),n=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const e=r[t];a[t]=e>=1?n[t]:n[t]*(e+1)}return this.makeOutput(a,e.shape,"float32")}selu(t){o(t,"selu");const a=e.backend_util.SELU_SCALEALPHA,r=e.backend_util.SELU_SCALE,n=new Float32Array(t.size),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t){const e=s[t];n[t]=e>=0?r*e:a*(Math.exp(e)-1)}return this.makeOutput(n,t.shape,"float32")}clip(t,e,a){o(t,"clip");const r=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t){const s=n[t];r[t]=s>a?a:s<e?e:s}return this.makeOutput(r,t.shape,"float32")}abs(t){const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.abs(a[t]);return this.makeOutput(e,t.shape,"float32")}complexAbs(t){const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let r=0;r<t.size;++r){const t=a[2*r],n=a[2*r+1];e[r]=Math.hypot(t,n)}return this.makeOutput(e,t.shape,"float32")}int(t){o(t,"int");const e=new Int32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=a[t];return this.makeOutput(e,t.shape,"int32")}sigmoid(t){o(t,"sigmoid");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=1/(1+Math.exp(-a[t]));return this.makeOutput(e,t.shape,"float32")}softplus(t){o(t,"softplus");const e=Math.log(1.1920928955078125e-7)+2,a=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const n=r[t]>-e,s=r[t]<e,o=Math.exp(r[t]);let i;i=s?o:n?r[t]:Math.log(1+o),a[t]=i}return this.makeOutput(a,t.shape,"float32")}sin(t){o(t,"sin");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.sin(a[t]);return this.makeOutput(e,t.shape,"float32")}cos(t){o(t,"cos");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.cos(a[t]);return this.makeOutput(e,t.shape,"float32")}tan(t){o(t,"tan");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.tan(a[t]);return this.makeOutput(e,t.shape,"float32")}asin(t){o(t,"asin");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.asin(a[t]);return this.makeOutput(e,t.shape,"float32")}acos(t){o(t,"acos");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.acos(a[t]);return this.makeOutput(e,t.shape,"float32")}atan(t){o(t,"atan");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.atan(a[t]);return this.makeOutput(e,t.shape,"float32")}atan2(t,e){return o([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}sinh(t){o(t,"sinh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.sinh(a[t]);return this.makeOutput(e,t.shape,"float32")}cosh(t){o(t,"cosh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.cosh(a[t]);return this.makeOutput(e,t.shape,"float32")}tanh(t){o(t,"tanh");const a=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t)a[t]=e.util.tanh(r[t]);return this.makeOutput(a,t.shape,"float32")}asinh(t){o(t,"asinh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.asinh(a[t]);return this.makeOutput(e,t.shape,"float32")}acosh(t){o(t,"acosh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.acosh(a[t]);return this.makeOutput(e,t.shape,"float32")}atanh(t){o(t,"atanh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.atanh(a[t]);return this.makeOutput(e,t.shape,"float32")}erf(t){o(t,"erf");const a=new Float32Array(t.size),r=this.readSync(t.dataId),n=e.backend_util.ERF_P,s=e.backend_util.ERF_A1,i=e.backend_util.ERF_A2,l=e.backend_util.ERF_A3,d=e.backend_util.ERF_A4,h=e.backend_util.ERF_A5;for(let t=0;t<r.length;++t){const e=Math.sign(r[t]),o=Math.abs(r[t]),c=1/(1+n*o);a[t]=e*(1-((((h*c+d)*c+l)*c+i)*c+s)*c*Math.exp(-o*o))}return this.makeOutput(a,t.shape,"float32")}step(t,e=0){o(t,"step");const a=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const n=r[t];isNaN(n)?a[t]=NaN:a[t]=n>0?1:e}return this.makeOutput(a,t.shape,"float32")}fusedConv2d({input:t,filter:e,convInfo:a,bias:r,activation:n,preluActivationWeights:s}){let o=this.conv2d(t,e,a);return r&&(o=this.add(o,r)),n&&(o=f(this,o,n,s)),o}conv2d(t,a,r){o([t,a],"conv2d");const n=r.filterHeight,s=r.filterWidth,i=r.dilationHeight,l=r.dilationWidth,d=r.padInfo.left,h=r.padInfo.top,c="channelsLast"===r.dataFormat,u=e.buffer(r.outShape,t.dtype),p=t.strides[0],f=c?t.strides[1]:t.strides[2],m=c?t.strides[2]:1,y=c?1:t.strides[1],g=u.strides[0],S=c?u.strides[1]:u.strides[2],I=c?u.strides[2]:1,b=c?1:u.strides[1],k=this.readSync(t.dataId),M=this.readSync(a.dataId),x=u.values;for(let t=0;t<r.batchSize;++t){const e=t*p,o=t*g;for(let t=0;t<r.outHeight;++t){const c=o+t*S,u=t*r.strideHeight-h;for(let t=0;t<n;t++){const n=u+t*i;if(n<0||n>=r.inHeight)continue;const o=t*a.strides[0],h=e+n*f;for(let t=0;t<r.outWidth;++t){const e=c+t*I,n=t*r.strideWidth-d;for(let t=0;t<s;t++){const s=n+t*l;if(s<0||s>=r.inWidth)continue;const i=h+s*m;let d=o+t*a.strides[1];for(let t=0;t<r.inChannels;++t){const a=k[i+t*y];for(let t=0;t<r.outChannels;++t)x[e+t*b]+=a*M[d+t];d+=r.outChannels}}}}}}return u.toTensor()}conv3d(t,a,r){const n=r.filterDepth,s=r.filterHeight,o=r.filterWidth,i=r.dilationDepth,l=r.dilationHeight,d=r.dilationWidth,h=r.padInfo.front,c=r.padInfo.left,u=r.padInfo.top,p=e.buffer(r.outShape,t.dtype),f=this.readSync(t.dataId),m=this.readSync(a.dataId),y=p.values;for(let e=0;e<r.batchSize;++e){const g=e*t.strides[0],S=e*p.strides[0];for(let e=0;e<r.outDepth;++e){const I=S+e*p.strides[1],b=e*r.strideDepth-h;for(let e=0;e<n;e++){const n=b+e*i;if(n<0||n>=r.inDepth)continue;const h=e*a.strides[0],S=g+n*t.strides[1];for(let e=0;e<r.outHeight;++e){const n=I+e*p.strides[2],i=e*r.strideHeight-u;for(let e=0;e<s;e++){const s=i+e*l;if(s<0||s>=r.inHeight)continue;const u=h+e*a.strides[1],p=S+s*t.strides[2];for(let t=0;t<r.outWidth;++t){const e=n+t*r.outChannels,s=t*r.strideWidth-c;for(let t=0;t<o;t++){const n=s+t*d;if(n<0||n>=r.inWidth)continue;const o=u+t*a.strides[2],i=p+n*r.inChannels;let l=o;for(let t=0;t<r.inChannels;++t){const a=f[i+t];for(let t=0;t<r.outChannels;++t)y[e+t]+=a*m[l+t];l+=r.outChannels}}}}}}}}return p.toTensor()}conv2dDerInput(t,a,r){o([t,a],"conv2dDerInput");const n=e.buffer(r.inShape,"float32"),s=n.values,i=this.readSync(t.dataId),l=this.readSync(a.dataId),[d,h,c]=a.strides,{batchSize:u,filterHeight:p,filterWidth:f,inChannels:m,inHeight:y,inWidth:g,outChannels:S,outHeight:I,outWidth:b,strideHeight:k,strideWidth:M,dataFormat:x}=r,A=p-1-r.padInfo.top,F=f-1-r.padInfo.left,v="channelsLast"===x,w=n.strides[0],T=v?n.strides[1]:n.strides[2],z=v?n.strides[2]:1,D=v?1:n.strides[1],W=t.strides[0],_=v?t.strides[1]:t.strides[2],O=v?t.strides[2]:1,H=v?1:t.strides[1];for(let t=0;t<u;++t)for(let e=0;e<m;++e)for(let a=0;a<y;++a){const r=a-A,n=Math.max(0,Math.ceil(r/k)),o=Math.min(I,(p+r)/k);for(let u=0;u<g;++u){const m=u-F,y=Math.max(0,Math.ceil(m/M)),g=Math.min(b,(f+m)/M);let I=0;for(let a=n;a<o;++a){const n=a*k-r;for(let r=y;r<g;++r){const s=W*t+_*a+O*r,o=d*(p-1-n)+h*(f-1-(r*M-m))+c*e;for(let t=0;t<S;++t){I+=i[s+H*t]*l[o+t]}}}s[w*t+T*a+z*u+D*e]=I}}return n.toTensor()}conv3dDerInput(t,a,r){const n=e.buffer(r.inShape,"float32"),s=n.values,[o,i,l,d]=n.strides,h=this.readSync(t.dataId),[c,u,p,f]=t.strides,m=this.readSync(a.dataId),[y,g,S,I]=a.strides,{batchSize:b,filterDepth:k,filterHeight:M,filterWidth:x,inChannels:A,inDepth:F,inHeight:v,inWidth:w,outChannels:T,outDepth:z,outHeight:D,outWidth:W,strideDepth:_,strideHeight:O,strideWidth:H}=r,N=k-1-r.padInfo.front,B=M-1-r.padInfo.top,C=x-1-r.padInfo.left;for(let t=0;t<b;++t)for(let e=0;e<A;++e)for(let a=0;a<F;++a){const r=a-N,n=Math.max(0,Math.ceil(r/_)),b=Math.min(z,(k+r)/_);for(let A=0;A<v;++A){const F=A-B,v=Math.max(0,Math.ceil(F/O)),z=Math.min(D,(M+F)/O);for(let D=0;D<w;++D){const w=D-C,N=Math.max(0,Math.ceil(w/H)),B=Math.min(W,(x+w)/H);let E=0;for(let a=n;a<b;++a){const n=a*_-r;for(let r=v;r<z;++r){const s=r*O-F;for(let o=N;o<B;++o){const i=c*t+u*a+p*r+f*o,l=y*(k-1-n)+g*(M-1-s)+S*(x-1-(o*H-w))+I*e;for(let t=0;t<T;++t){E+=h[i+t]*m[l+t]}}}}s[o*t+i*a+l*A+d*D+e]=E}}}return n.toTensor()}conv2dDerFilter(t,a,r){o([t,a],"conv2dDerFilter");const n=r.strideHeight,s=r.strideWidth,i=r.filterHeight,l=r.filterWidth,d="channelsLast"===r.dataFormat,h=e.buffer(r.filterShape,"float32"),c=r.padInfo.left,u=r.padInfo.top,p=this.bufferSync(t),f=this.bufferSync(a);for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((u-t)/n)),a=Math.min(r.outHeight,(r.inHeight+u-t)/n);for(let o=0;o<l;++o){const i=Math.max(0,Math.ceil((c-o)/s)),l=Math.min(r.outWidth,(r.inWidth+c-o)/s);for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outChannels;++y){let g=0;for(let h=0;h<r.batchSize;++h)for(let r=e;r<a;++r){const e=t+r*n-u;for(let t=i;t<l;++t){const a=o+t*s-c;g+=d?p.get(h,e,a,m)*f.get(h,r,t,y):p.get(h,m,e,a)*f.get(h,y,r,t)}}h.set(g,t,o,m,y)}}}return h.toTensor()}conv3dDerFilter(t,a,r){const n=r.strideDepth,s=r.strideHeight,o=r.strideWidth,i=r.filterDepth,l=r.filterHeight,d=r.filterWidth,h=e.buffer(r.filterShape,"float32"),c=h.values,[u,p,f,m]=h.strides,y=this.readSync(a.dataId),[g,S,I,b]=a.strides,k=this.readSync(t.dataId),[M,x,A,F]=t.strides,v=r.padInfo.front,w=r.padInfo.left,T=r.padInfo.top;for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((v-t)/n)),a=Math.min(r.outDepth,(r.inDepth+v-t)/n),i=t*u;for(let h=0;h<l;++h){const l=Math.max(0,Math.ceil((T-h)/s)),u=Math.min(r.outHeight,(r.inHeight+T-h)/s),z=h*p+i;for(let i=0;i<d;++i){const d=Math.max(0,Math.ceil((w-i)/o)),p=Math.min(r.outWidth,(r.inWidth+w-i)/o),D=i*f+z;for(let f=0;f<r.inChannels;++f){const z=f*m+D;for(let m=0;m<r.outChannels;++m){let D=0;for(let c=0;c<r.batchSize;++c){const r=c*M,z=c*g;for(let c=e;c<a;++c){const e=(t+c*n-v)*x+r,a=c*S+z;for(let t=l;t<u;++t){const r=(h+t*s-T)*A+e,n=t*I+a;for(let t=d;t<p;++t){const e=t*b+n;D+=k[(i+t*o-w)*F+r+f]*y[e+m]}}}}c[z+m]=D}}}}}return h.toTensor()}fusedDepthwiseConv2D({input:t,filter:e,convInfo:a,bias:r,activation:n,preluActivationWeights:s}){let o=this.depthwiseConv2D(t,e,a);return r&&(o=this.add(o,r)),n&&(o=f(this,o,n,s)),o}depthwiseConv2D(t,a,r){o([t,a],"depthwiseConv2D");const n=r.filterHeight,s=r.filterWidth,i=r.dilationHeight,l=r.dilationWidth,d=r.padInfo.left,h=r.padInfo.top,c=r.outChannels/r.inChannels,u=e.buffer(r.outShape,t.dtype),p=this.readSync(t.dataId),f=this.readSync(a.dataId),m=u.values;for(let e=0;e<r.batchSize;++e){const o=e*t.strides[0],y=e*u.strides[0];for(let e=0;e<r.outHeight;++e){const g=y+e*u.strides[1],S=e*r.strideHeight-d;for(let e=0;e<n;++e){const n=S+e*i;if(n<0||n>=r.inHeight)continue;const d=e*a.strides[0],y=o+n*t.strides[1];for(let t=0;t<r.outWidth;++t){const e=g+t*u.strides[2],n=t*r.strideWidth-h;for(let t=0;t<s;++t){const s=n+t*l;if(s<0||s>=r.inWidth)continue;const o=d+t*a.strides[1],i=y+s*r.inChannels;let h=e,u=o;for(let t=0;t<r.inChannels;++t){const e=p[i+t];for(let t=0;t<c;++t)m[h+t]+=e*f[u+t];h+=c,u+=c}}}}}}return u.toTensor()}depthwiseConv2DDerInput(t,a,r){o([t,a],"depthwiseConv2DDerInput");const n=e.buffer(r.inShape,"float32"),s=n.values,[i,l,d]=n.strides,h=this.readSync(t.dataId),[c,u,p]=t.strides,f=this.readSync(a.dataId),[m,y,g]=a.strides,{batchSize:S,filterHeight:I,filterWidth:b,inChannels:k,inHeight:M,inWidth:x,outChannels:A,outHeight:F,outWidth:v,strideHeight:w,strideWidth:T}=r,z=I-1-r.padInfo.top,D=b-1-r.padInfo.left,W=A/k;for(let t=0;t<S;++t)for(let e=0;e<k;++e)for(let a=0;a<M;++a){const r=a-z,n=Math.max(0,Math.ceil(r/w)),o=Math.min(F,(I+r)/w);for(let S=0;S<x;++S){const k=S-D,M=Math.max(0,Math.ceil(k/T)),x=Math.min(v,(b+k)/T);let A=0;for(let a=n;a<o;++a){const n=a*w-r;for(let r=M;r<x;++r){const s=c*t+u*a+p*r,o=m*(I-1-n)+y*(b-1-(r*T-k))+g*e;for(let t=0;t<W;++t){A+=h[s+(e*W+t)]*f[o+t]}}}s[i*t+l*a+d*S+e]=A}}return n.toTensor()}depthwiseConv2DDerFilter(t,a,r){o([t,a],"depthwiseConv2DDerFilter");const n=r.strideHeight,s=r.strideWidth,i=r.filterHeight,l=r.filterWidth,d=e.buffer(r.filterShape,"float32"),h=r.padInfo.left,c=r.padInfo.top,u=r.outChannels/r.inChannels,p=this.bufferSync(t),f=this.bufferSync(a);for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((c-t)/n)),a=Math.min(r.outHeight,(r.inHeight+c-t)/n);for(let o=0;o<l;++o){const i=Math.max(0,Math.ceil((h-o)/s)),l=Math.min(r.outWidth,(r.inWidth+h-o)/s);for(let m=0;m<r.outChannels;++m){const y=Math.trunc(m/u),g=m%u;let S=0;for(let d=0;d<r.batchSize;++d)for(let r=e;r<a;++r){const e=t+r*n-c;for(let t=i;t<l;++t){const a=o+t*s-h;S+=p.get(d,e,a,y)*f.get(d,r,t,m)}}d.set(S,t,o,y,g)}}}return d.toTensor()}tile(t,e){return o(t,"tile"),c(this.bufferSync(t),e)}pad(t,a,r){o(t,"pad");const n=a.map((e,a)=>e[0]+t.shape[a]+e[1]),s=a.map(t=>t[0]),i=this.bufferSync(t),l=e.buffer(n,t.dtype);0!==r&&l.values.fill(r);for(let e=0;e<t.size;e++){const t=i.indexToLoc(e),a=t.map((t,e)=>t+s[e]);l.set(i.get(...t),...a)}return l.toTensor()}gather(t,a,r){o([t,a],"gather");const n=t.shape.slice(),s=this.readSync(a.dataId);n[r]=s.length;const i=e.buffer(n,t.dtype),l=this.bufferSync(t);for(let t=0;t<i.size;++t){const e=i.indexToLoc(t),a=e.slice();a[r]=s[e[r]];const n=l.locToIndex(a);i.values[t]=l.values[n]}return i.toTensor()}batchToSpaceND(t,a,r){o([t],"batchToSpaceND");const n=a.reduce((t,e)=>t*e),s=e.backend_util.getReshaped(t.shape,a,n),i=e.backend_util.getPermuted(s.length,a.length),l=e.backend_util.getReshapedPermuted(t.shape,a,n),d=e.backend_util.getSliceBeginCoords(r,a.length),h=e.backend_util.getSliceSize(l,r,a.length);return e.transpose(t.reshape(s),i).reshape(l).slice(d,h)}spaceToBatchND(t,a,r){o([t],"spaceToBatchND");const n=a.reduce((t,e)=>t*e),s=[[0,0]];s.push(...r);for(let e=1+a.length;e<t.shape.length;++e)s.push([0,0]);const i=t.pad(s),l=e.backend_util.getReshaped(i.shape,a,n,!1),d=e.backend_util.getPermuted(l.length,a.length,!1),h=e.backend_util.getReshapedPermuted(i.shape,a,n,!1);return e.transpose(i.reshape(l),d).reshape(h)}maxPool(t,e){return o(t,"maxPool"),i(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"max").toTensor()}maxPoolBackprop(t,a,r,n){o([a,r],"maxPoolBackprop");const s=this.readSync(a.dataId),i=e.buffer(n.outShape,a.dtype,l(s,a.shape,a.dtype,n).values),d=n.strideHeight,h=n.strideWidth,c=n.dilationHeight,u=n.dilationWidth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=f-1-n.padInfo.left,y=p-1-n.padInfo.top,g=e.buffer(a.shape,"float32"),S=this.bufferSync(t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let a=0;a<n.inHeight;++a)for(let r=0;r<n.inWidth;++r){const s=a-y,o=r-m;let l=0;for(let a=0;a<p;a+=c){const r=(s+a)/d;if(!(r<0||r>=n.outHeight||Math.floor(r)!==r))for(let s=0;s<f;s+=u){const d=(o+s)/h;if(d<0||d>=n.outWidth||Math.floor(d)!==d)continue;const c=p*f-1-i.get(t,r,d,e)===a*f+s?1:0;0!==c&&(l+=S.get(t,r,d,e)*c)}}g.set(l,t,a,r,e)}return g.toTensor()}avgPoolBackprop(t,a,r){o([t,a],"avgPoolBackprop");const n=r.strideHeight,s=r.strideWidth,i=r.filterHeight,l=r.filterWidth,d=r.dilationHeight,h=r.dilationWidth,c=r.effectiveFilterHeight,u=r.effectiveFilterWidth,p=u-1-r.padInfo.left,f=c-1-r.padInfo.top,m=e.buffer(a.shape,"float32"),y=1/(i*l),g=this.bufferSync(t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let a=0;a<r.inHeight;++a)for(let o=0;o<r.inWidth;++o){const i=a-f,l=o-p;let S=0;for(let a=0;a<c;a+=d){const o=(i+a)/n;if(!(o<0||o>=r.outHeight||Math.floor(o)!==o))for(let a=0;a<u;a+=h){const n=(l+a)/s;n<0||n>=r.outWidth||Math.floor(n)!==n||(S+=g.get(t,o,n,e))}}m.set(S*y,t,a,o,e)}return m.toTensor()}pool3d(t,a,r){o(t,"pool3d");const n=a.strideDepth,s=a.strideHeight,i=a.strideWidth,l=a.dilationDepth,d=a.dilationHeight,h=a.dilationWidth,c=a.effectiveFilterDepth,u=a.effectiveFilterHeight,p=a.effectiveFilterWidth,f=a.padInfo.front,m=a.padInfo.top,y=a.padInfo.left,g="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=this.readSync(t.dataId),I=e.buffer(a.outShape,t.dtype),b=I.values,k=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],M=a.outShape[2]*a.outShape[3]*a.outShape[4],x=a.outShape[3]*a.outShape[4],A=a.outShape[4];for(let e=0;e<a.batchSize;++e){const o=e*k,I=e*t.strides[0];for(let e=0;e<a.inChannels;++e)for(let k=0;k<a.outDepth;++k){const F=k*n-f;let v=F;for(;v<0;)v+=l;const w=Math.min(a.inDepth,c+F),T=o+k*M;for(let n=0;n<a.outHeight;++n){const o=n*s-m;let c=o;for(;c<0;)c+=d;const f=Math.min(a.inHeight,u+o),k=T+n*x;for(let n=0;n<a.outWidth;++n){const s=n*i-y;let o=s;for(;o<0;)o+=h;const u=Math.min(a.inWidth,p+s),m=k+n*A;let M=g,x=0,F=0;for(let a=v;a<w;a+=l){const n=I+a*t.strides[1];for(let a=c;a<f;a+=d){const s=n+a*t.strides[2];for(let a=o;a<u;a+=h){const n=S[s+a*t.strides[3]+e];if("max"===r&&n>M?M=n:"avg"===r&&(x+=n,F++),isNaN(M))break}if(isNaN(M))break}if(isNaN(M))break}b[m+e]="avg"===r?x/F:M}}}}return I.toTensor()}avgPool3d(t,e){return o(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,a,r){o([t,a],"avgPool3dBackprop");const n=r.strideDepth,s=r.strideHeight,i=r.strideWidth,l=r.filterDepth,d=r.filterHeight,h=r.filterWidth,c=r.dilationDepth,u=r.dilationHeight,p=r.dilationWidth,f=r.effectiveFilterDepth,m=r.effectiveFilterHeight,y=r.effectiveFilterWidth,g=f-1-r.padInfo.front,S=y-1-r.padInfo.left,I=m-1-r.padInfo.top,b=e.buffer(a.shape,"float32"),k=1/(l*d*h),M=this.bufferSync(t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let a=0;a<r.inDepth;++a)for(let o=0;o<r.inHeight;++o)for(let l=0;l<r.inWidth;++l){const d=a-g,h=o-I,x=l-S;let A=0;for(let a=0;a<f;a+=c){const o=(d+a)/n;if(!(o<0||o>=r.outDepth||Math.floor(o)!==o))for(let a=0;a<m;a+=u){const n=(h+a)/s;if(!(n<0||n>=r.outHeight||Math.floor(n)!==n))for(let a=0;a<y;a+=p){const s=(x+a)/i;s<0||s>=r.outWidth||Math.floor(s)!==s||(A+=M.get(t,o,n,s,e))}}}b.set(A*k,t,a,o,l,e)}return b.toTensor()}maxPool3d(t,e){return o(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,a){const r=e.buffer(a.outShape,"int32"),n=a.strideDepth,s=a.strideHeight,o=a.strideWidth,i=a.dilationDepth,l=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,c=a.effectiveFilterHeight,u=a.effectiveFilterWidth,p=a.padInfo.front,f=a.padInfo.top,m=a.padInfo.left,y=this.bufferSync(t);for(let t=0;t<a.batchSize;++t)for(let e=0;e<a.inChannels;++e)for(let g=0;g<a.outDepth;++g){const S=g*n-p;let I=S;for(;I<0;)I+=i;const b=Math.min(a.inDepth,h+S);for(let n=0;n<a.outHeight;++n){const h=n*s-f;let p=h;for(;p<0;)p+=l;const k=Math.min(a.inHeight,c+h);for(let s=0;s<a.outWidth;++s){const f=s*o-m;let M=f;for(;M<0;)M+=d;const x=Math.min(a.inWidth,u+f);let A=Number.NEGATIVE_INFINITY,F=-1;for(let a=I;a<b;a+=i){const r=a-S;for(let n=p;n<k;n+=l){const s=n-h;for(let o=M;o<x;o+=d){const i=o-f,l=y.get(t,a,n,o,e);l>=A&&(A=l,F=r*c*u+s*c+i)}}}r.set(F,t,g,n,s,e)}}}return r.toTensor()}maxPool3dBackprop(t,a,r,n){o([a,r],"maxPool3dBackprop");const s=this.maxPool3dPositions(a,n),i=n.strideDepth,l=n.strideHeight,d=n.strideWidth,h=n.dilationDepth,c=n.dilationHeight,u=n.dilationWidth,p=n.effectiveFilterDepth,f=n.effectiveFilterHeight,m=n.effectiveFilterWidth,y=p-1-n.padInfo.front,g=m-1-n.padInfo.left,S=f-1-n.padInfo.top,I=e.buffer(a.shape,"float32"),b=this.bufferSync(s),k=this.bufferSync(t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let a=0;a<n.inDepth;++a)for(let r=0;r<n.inHeight;++r)for(let s=0;s<n.inWidth;++s){const o=a-y,M=r-S,x=s-g;let A=0;for(let a=0;a<p;a+=h){const r=(o+a)/i;if(!(r<0||r>=n.outDepth||Math.floor(r)!==r))for(let s=0;s<f;s+=c){const o=(M+s)/l;if(!(o<0||o>=n.outHeight||Math.floor(o)!==o))for(let i=0;i<m;i+=u){const l=(x+i)/d;if(l<0||l>=n.outWidth||Math.floor(l)!==l)continue;const h=p*f*m-1-b.get(t,r,o,l,e)===a*f*m+s*m+i?1:0;0!==h&&(A+=k.get(t,r,o,l,e)*h)}}}I.set(A,t,a,r,s,e)}return I.toTensor()}cast(t,a){return e.backend_util.castTensor(t,a,this)}reshape(t,a){return e.backend_util.reshapeTensor(t,a)}avgPool(t,e){return o(t,"avgPool"),o(t,"maxPool"),i(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"avg").toTensor().toFloat()}resizeBilinear(t,a,r,n){o(t,"resizeBilinear");const[s,i,l,d]=t.shape,h=this.readSync(t.dataId),c=new Float32Array(e.util.sizeFromShape([s,a,r,d])),u=[n&&a>1?i-1:i,n&&r>1?l-1:l],p=[n&&a>1?a-1:a,n&&r>1?r-1:r];let f=0;const m=u[0]/p[0],y=u[1]/p[1];for(let e=0;e<s;e++)for(let n=0;n<a;n++){const a=m*n,s=Math.floor(a),o=a-s,u=Math.min(i-1,Math.ceil(a)),p=e*t.strides[0]+s*t.strides[1],g=e*t.strides[0]+u*t.strides[1];for(let e=0;e<r;e++){const a=y*e,r=Math.floor(a),n=a-r,s=Math.min(l-1,Math.ceil(a)),i=p+r*t.strides[2],u=g+r*t.strides[2],m=p+s*t.strides[2],S=g+s*t.strides[2];for(let t=0;t<d;t++){const e=h[i+t],a=h[u+t],r=e+(h[m+t]-e)*n,s=r+(a+(h[S+t]-a)*n-r)*o;c[f++]=s}}}return e.tensor(c,[s,a,r,d])}resizeBilinearBackprop(t,a,r){o([t,a],"resizeBilinearBackprop");const[n,s,i,l]=a.shape,[,d,h]=t.shape,c=new Float32Array(n*s*i*l),u=[r&&d>1?s-1:s,r&&h>1?i-1:i],p=[r&&d>1?d-1:d,r&&h>1?h-1:h],f=u[0]/p[0],m=u[1]/p[1],y=this.readSync(t.dataId);let g=0;for(let t=0;t<n;t++){const e=t*a.strides[0];for(let t=0;t<d;t++){const r=t*f,n=Math.floor(r),o=Math.min(Math.ceil(r),s-1),d=e+n*a.strides[1],u=e+o*a.strides[1],p=r-n,S=1-p;for(let t=0;t<h;t++){const e=t*m,r=Math.floor(e),n=Math.min(Math.ceil(e),i-1),s=e-r,o=1-s,h=d+r*a.strides[2],f=d+n*a.strides[2],I=u+r*a.strides[2],b=u+n*a.strides[2],k=S*o,M=S*s,x=p*o,A=p*s;for(let t=0;t<l;t++){const e=y[g++];c[h+t]+=e*k,c[f+t]+=e*M,c[I+t]+=e*x,c[b+t]+=e*A}}}}return e.tensor4d(c,[n,i,s,l],a.dtype)}resizeNearestNeighbor(t,a,r,n){o(t,"resizeNearestNeighbor");const[s,i,l,d]=t.shape,h=this.readSync(t.dataId),c=new Float32Array(s*a*r*d),u=[n&&a>1?i-1:i,n&&r>1?l-1:l],p=[n&&a>1?a-1:a,n&&r>1?r-1:r],f=u[0]/p[0],m=u[1]/p[1];let y=0;for(let e=0;e<s;e++){const s=e*t.strides[0];for(let e=0;e<a;e++){const a=f*e,o=s+Math.min(i-1,n?Math.round(a):Math.floor(a))*t.strides[1];for(let e=0;e<r;e++){const a=m*e,r=o+Math.min(l-1,n?Math.round(a):Math.floor(a))*t.strides[2];for(let t=0;t<d;t++){const e=h[r+t];c[y++]=e}}}}return e.tensor(c,[s,a,r,d],t.dtype)}resizeNearestNeighborBackprop(t,a,r){o([t,a],"resizeNearestNeighborBackprop");const[n,s,i,l]=a.shape,[,d,h]=t.shape,c=new Float32Array(n*s*i*l),u=this.readSync(t.dataId),p=[r&&d>1?s-1:s,r&&h>1?i-1:i],f=[r&&d>1?d-1:d,r&&h>1?h-1:h],m=p[0]/f[0],y=p[1]/f[1],g=1/m,S=1/y,I=2*Math.ceil(g)+2,b=2*Math.ceil(S)+2;for(let e=0;e<n;e++){const n=e*a.strides[0];for(let e=0;e<s;e++){const o=n+e*a.strides[1],p=Math.floor(e*g),f=Math.floor(p-I/2);for(let p=0;p<i;p++){const g=o+p*a.strides[2],k=Math.floor(p*S),M=Math.floor(k-b/2);for(let a=0;a<l;a++){let o=0;for(let l=0;l<I;l++){const c=l+f;if(c<0||c>=d)continue;const g=n+c*t.strides[1],S=c*m;if(e===Math.min(s-1,r?Math.round(S):Math.floor(S)))for(let e=0;e<b;e++){const n=e+M;if(n<0||n>=h)continue;const s=g+n*t.strides[2],l=n*y;p===Math.min(i-1,r?Math.round(l):Math.floor(l))&&(o+=u[s+a])}}c[g+a]=o}}}}return e.tensor4d(c,a.shape,a.dtype)}batchNorm(t,a,r,n,s,i){o([t,a,r,s,n],"batchNorm");const l=this.readSync(t.dataId),d=this.readSync(a.dataId),h=this.readSync(r.dataId),c=s?this.readSync(s.dataId):new Float32Array([1]),u=n?this.readSync(n.dataId):new Float32Array([0]),p=new Float32Array(l.length),f=u.length,m=c.length,y=h.length,g=d.length;let S=0,I=0,b=0,k=0;for(let t=0;t<l.length;++t)p[t]=u[S++]+(l[t]-d[I++])*c[b++]/Math.sqrt(h[k++]+i),S>=f&&(S=0),I>=g&&(I=0),b>=m&&(b=0),k>=y&&(k=0);return e.tensor4d(p,t.shape)}localResponseNormalization4D(t,a,r,n,s){o(t,"localResponseNormalization4D");const i=t.shape[3],l=i-1,d=this.readSync(t.dataId),h=t.size,c=new Float32Array(h);function u(t){const e=t%i;let r=t-e+Math.max(0,e-a);const n=t-e+Math.min(e+a,l);let s=0;for(;r<=n;r++){const t=d[r];s+=t*t}return s}for(let t=0;t<h;t++){const e=u(t),a=d[t]*Math.pow(r+n*e,-s);c[t]=a}return e.tensor4d(c,t.shape)}LRNGrad(t,a,r,n,s,i,l){o(t,"LRNGrad");const d=t.shape[3],h=this.readSync(t.dataId),c=this.readSync(a.dataId),u=this.readSync(r.dataId),p=new Float32Array(t.size),f=t.size;for(let t=0;t<f;t++){const e=t%d,a=t-e+Math.max(0,e-n),r=t-e+Math.min(d,e+n+1);let o=0;for(let t=a;t<r;t++)o+=Math.pow(c[t],2);o=i*o+s;for(let e=a;e<r;e++){let a=-2*i*l*c[e]*u[t]/o;t===e&&(a+=Math.pow(o,-l)),a*=h[t],p[e]+=a}}return e.tensor4d(p,t.shape)}multinomial(t,r,n,s){o(t,"multinomial");const i=r?t:e.softmax(t),l=i.shape[0],d=i.shape[1],h=e.zeros([l,n],"int32"),c=this.readSync(h.dataId),u=this.readSync(i.dataId);for(let t=0;t<l;++t){const e=t*d,r=new Float32Array(d-1);r[0]=u[e];for(let t=1;t<r.length;++t)r[t]=r[t-1]+u[e+t];const o=a.alea(s.toString()),i=t*n;for(let t=0;t<n;++t){const e=o();c[i+t]=r.length;for(let a=0;a<r.length;a++)if(e<r[a]){c[i+t]=a;break}}}return h}oneHot(t,a,r,n){o(t,"oneHot");const s=new Float32Array(t.size*a);s.fill(n);const i=this.readSync(t.dataId);for(let e=0;e<t.size;++e)i[e]>=0&&i[e]<a&&(s[e*a+i[e]]=r);return e.tensor2d(s,[t.size,a],"int32")}nonMaxSuppression(t,e,a,r,n){o(t,"nonMaxSuppression");const s=this.readSync(t.dataId),i=this.readSync(e.dataId);return d(s,i,a,r,n)}fft(t){return this.fftBatch(t,!1)}ifft(t){return this.fftBatch(t,!0)}fftBatch(t,a){const r=t.shape[0],n=t.shape[1],s=e.buffer(t.shape,"float32"),o=e.buffer(t.shape,"float32"),i=e.real(t).as2D(r,n),l=e.imag(t).as2D(r,n);for(let t=0;t<r;t++){const r=i.slice([t,0],[1,n]),d=l.slice([t,0],[1,n]),h=e.complex(r,d),c=this.readSync(this.fftImpl(h,a).dataId);for(let a=0;a<n;a++){const r=e.backend_util.getComplexWithIndex(c,a);s.values[t*n+a]=r.real,o.values[t*n+a]=r.imag}}return e.complex(s.toTensor(),o.toTensor()).as2D(r,n)}fftImpl(t,a){const r=t.as1D(),n=r.size;if(this.isExponentOf2(n)){let s=this.fftRadix2(r,n,a).as2D(t.shape[0],t.shape[1]);return a&&(s=e.complex(e.real(s).div(e.scalar(n)),e.imag(s).div(e.scalar(n)))),s}{const r=this.readSync(t.dataId),s=this.fourierTransformByMatmul(r,n,a),o=e.backend_util.splitRealAndImagArrays(s);return e.complex(o.real,o.imag).as2D(t.shape[0],t.shape[1])}}isExponentOf2(t){return 0==(t&t-1)}fftRadix2(t,a,r){if(1===a)return t;const n=this.readSync(t.dataId),s=a/2,o=e.backend_util.complexWithEvenIndex(n);let i=e.complex(o.real,o.imag).as1D();const l=e.backend_util.complexWithOddIndex(n);let d=e.complex(l.real,l.imag).as1D();i=this.fftRadix2(i,s,r),d=this.fftRadix2(d,s,r);const h=e.backend_util.exponents(a,r),c=e.complex(h.real,h.imag).mul(d),u=i.add(c),p=i.sub(c),f=e.real(u).concat(e.real(p)),m=e.imag(u).concat(e.imag(p));return e.complex(f,m).as1D()}fourierTransformByMatmul(t,a,r){const n=new Float32Array(2*a);for(let s=0;s<a;s++){let o=0,i=0;for(let n=0;n<a;n++){const l=e.backend_util.exponent(s*n,a,r),d=e.backend_util.getComplexWithIndex(t,n);o+=d.real*l.real-d.imag*l.imag,i+=d.real*l.imag+d.imag*l.real}r&&(o/=a,i/=a),e.backend_util.assignToTypedArray(n,o,i,s)}return n}depthToSpace(t,a,r){e.util.assert("NHWC"===r,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`),e.util.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const n=t.shape[0],s=t.shape[1],o=t.shape[2],i=t.shape[3],l=s*a,d=o*a,h=i/(a*a),c=this.readSync(t.dataId),u=new Float32Array(n*l*d*h);let p=0;for(let t=0;t<n;++t)for(let e=0;e<l;++e){const r=Math.floor(e/a),n=e%a;for(let e=0;e<d;++e){const l=Math.floor(e/a),d=(n*a+e%a)*h;for(let e=0;e<h;++e){const a=e+d+i*(l+o*(r+s*t));u[p++]=c[a]}}}return e.tensor4d(u,[n,l,d,h])}broadcastedBinaryOp(t,a,r,n){const s=e.backend_util.assertAndGetBroadcastShape(t.shape,a.shape),o=e.buffer(s,r),i=this.readSync(t.dataId),l=this.readSync(a.dataId),d=e.backend_util.getBroadcastDims(t.shape,s),h=e.backend_util.getBroadcastDims(a.shape,s),c=o.values;if(d.length+h.length===0)for(let t=0;t<c.length;++t)c[t]=n(i[t%i.length],l[t%l.length]);else{const e=this.bufferSync(t),r=this.bufferSync(a);for(let s=0;s<c.length;++s){const u=o.indexToLoc(s),p=u.slice(-t.rank);d.forEach(t=>p[t]=0);const f=e.locToIndex(p),m=u.slice(-a.rank);h.forEach(t=>m[t]=0);const y=r.locToIndex(m);c[s]=n(i[f],l[y])}}return o.toTensor()}broadcastedBinaryComplexOp(t,a,r){const n=e.backend_util.assertAndGetBroadcastShape(t.shape,a.shape),s=e.buffer(n,"float32"),o=e.buffer(n,"float32"),i=this.readSync(t.dataId),l=this.readSync(a.dataId),d=e.backend_util.getBroadcastDims(t.shape,n),h=e.backend_util.getBroadcastDims(a.shape,n),c=s.values,u=o.values;if(d.length+h.length===0)for(let t=0;t<c.length;t++){const e=t%i.length,a=t%l.length,n=r(i[2*e],i[2*e+1],l[2*a],l[2*a+1]);c[t]=n.real,u[t]=n.imag}else{const e=this.bufferSync(this.data.get(t.dataId).complexTensors.real),n=this.bufferSync(this.data.get(a.dataId).complexTensors.real);for(let o=0;o<c.length;o++){const p=s.indexToLoc(o),f=p.slice(-t.rank);d.forEach(t=>f[t]=0);const m=e.locToIndex(f),y=p.slice(-a.rank);h.forEach(t=>y[t]=0);const g=n.locToIndex(y),S=r(i[2*m],i[2*m+1],l[2*g],l[2*g+1]);c[o]=S.real,u[o]=S.imag}}return this.complex(s.toTensor(),o.toTensor())}split(t,e,a){return h(t,e,a)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,a,r,n,s,o){const[i,l,d,h]=t.shape,c=a.shape[0],[u,p]=n,f=e.buffer([c,u,p,h],"float32"),m=this.readSync(a.dataId),y=this.readSync(r.dataId),g=this.readSync(t.dataId),S=t.strides,I=f.strides;for(let t=0;t<c;t++){const e=4*t,a=m[e],r=m[e+1],n=m[e+2],c=m[e+3],b=y[t];if(b>=i)continue;const k=u>1?(n-a)*(l-1)/(u-1):0,M=p>1?(c-r)*(d-1)/(p-1):0;for(let e=0;e<u;e++){const i=u>1?a*(l-1)+e*k:.5*(a+n)*(l-1);if(i<0||i>l-1)for(let a=0;a<p;a++)for(let r=0;r<h;r++){const n=r+a*I[2]+e*I[1]+t*I[0];f.values[n]=o}else if("bilinear"===s){const a=Math.floor(i),n=Math.ceil(i),s=i-a;for(let i=0;i<p;i++){const l=p>1?r*(d-1)+i*M:.5*(r+c)*(d-1);if(l<0||l>d-1){for(let a=0;a<h;a++){const r=a+i*I[2]+e*I[1]+t*I[0];f.values[r]=o}continue}const u=Math.floor(l),m=Math.ceil(l),y=l-u;for(let r=0;r<h;r++){let o=r+u*S[2]+a*S[1]+b*S[0];const l=g[o];o=r+m*S[2]+a*S[1]+b*S[0];const d=g[o];o=r+u*S[2]+n*S[1]+b*S[0];const h=g[o];o=r+m*S[2]+n*S[1]+b*S[0];const c=l+(d-l)*y,p=h+(g[o]-h)*y;o=r+i*I[2]+e*I[1]+t*I[0],f.values[o]=c+(p-c)*s}}}else for(let a=0;a<p;++a){const n=p>1?r*(d-1)+a*M:.5*(r+c)*(d-1);if(n<0||n>d-1){for(let r=0;r<h;r++){const n=r+a*I[2]+e*I[1]+t*I[0];f.values[n]=o}continue}const s=Math.round(n),l=Math.round(i);for(let r=0;r<h;r++){const n=r+s*S[2]+l*S[1]+b*S[0],o=r+a*I[2]+e*I[1]+t*I[0];f.values[o]=g[n]}}}}return f.toTensor()}sparseToDense(t,a,r,n){const{sliceRank:s,numUpdates:o,sliceSize:i,strides:l,outputSize:d}=e.backend_util.calculateShapes(a,t,r);return this.scatter(t,a,r,d,i,o,s,l,n,!1)}gatherND(t,a){const r=a.shape,n=r[r.length-1],[s,o,i,l]=e.backend_util.prepareAndValidate(t,a);if(0===o)return e.tensor([],s,t.dtype);const d=new e.TensorBuffer([o,i],t.dtype),h=this.readSync(a.dataId),c=this.readSync(t.dataId);for(let e=0;e<o;e++){const a=[];let r=0;for(let t=0;t<n;t++){const s=h[e*n+t];r+=s*l[t],a.push(s)}if(r<0||r>=t.size/i)throw new Error(`Invalid indices: ${a} does not index into ${t.shape}`);for(let t=0;t<i;t++)d.values[e*i+t]=c[r*i+t]}return d.toTensor().reshape(s)}scatterND(t,a,r){const{sliceRank:n,numUpdates:s,sliceSize:o,strides:i,outputSize:l}=e.backend_util.calculateShapes(a,t,r),d=e.scalar(0);return this.scatter(t,a,r,l,o,s,n,i,d,!0)}fill(t,a,r){r=r||e.util.inferDtype(a);const n=e.util.getArrayFromDType(r,e.util.sizeFromShape(t));return n.fill(a),e.engine().makeTensor(n,t,r,this)}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)}zerosLike(t){const a=e.util.getArrayFromDType(t.dtype,e.util.sizeFromShape(t.shape));return this.makeOutput(a,t.shape,t.dtype)}linspace(t,a,r){return e.backend_util.linspaceImpl(t,a,r)}scatter(t,a,r,n,s,o,i,l,d,h){const c=[n/s,s],u=this.readSync(t.dataId),p=this.readSync(a.dataId);if(0===n)return e.tensor([],r,a.dtype);const f=new e.TensorBuffer(c,a.dtype);f.values.fill(this.readSync(d.dataId)[0]);for(let t=0;t<o;t++){const e=[];let o=0;for(let a=0;a<i;a++){const r=u[t*i+a];e.push(r),o+=r*l[a]}if(o<0||o>=n/s)throw new Error(`Invalid indices: ${e} does not index into ${r}`);for(let e=0;e<s;e++)h?f.values[o*s+e]+=p[t*s+e]:f.values[o*s+e]=0===a.rank?p[0]:p[t*s+e]}return f.toTensor().reshape(r)}}function y(t,e){return{kernelName:t,backendName:"cpu",kernelFunc:({inputs:a,backend:r})=>{const{a:n,b:s}=a,i=r;o([n,s],t);const l=i.data.get(n.dataId).values,d=i.data.get(s.dataId).values,[h,c]=e(n.shape,s.shape,l,d,n.dtype);return{dataId:i.write(h,c,n.dtype),shape:c,dtype:n.dtype}}}}function g(t){return(a,r,n,s,o)=>{const i=e.backend_util.assertAndGetBroadcastShape(a,r),l=i.length,d=e.util.computeStrides(i),h=e.util.sizeFromShape(i),c=e.util.getTypedArrayFromDType(o,h),u=a.length,p=r.length,f=e.util.computeStrides(a),m=e.util.computeStrides(r),y=e.backend_util.getBroadcastDims(a,i),g=e.backend_util.getBroadcastDims(r,i);if(y.length+g.length===0)for(let e=0;e<c.length;++e)c[e]=t(n[e%n.length],s[e%s.length]);else for(let a=0;a<c.length;++a){const r=e.util.indexToLoc(a,l,d),o=r.slice(-u);y.forEach(t=>o[t]=0);const i=e.util.locToIndex(o,u,f),h=r.slice(-p);g.forEach(t=>h[t]=0);const S=e.util.locToIndex(h,p,m);c[a]=t(n[i],s[S])}return[c,i]}}const S=g((t,e)=>t/e),I=y(e.Div,S),b={kernelName:e.Max,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:s})=>{const{x:i}=t,{reductionIndices:l}=a,d=s;let h=i.shape;const c=h.length;let u=e.util.parseAxisParam(l,h);const p=e.backend_util.getAxesPermutation(u,c);let f=d.data.get(i.dataId).values;if(null!=p){const t=new Array(c);for(let e=0;e<t.length;e++)t[e]=h[p[e]];f=n(f,h,i.dtype,p,t),u=e.backend_util.getInnerMostAxes(u.length,c),h=t}o(i,"max"),e.backend_util.assertAxesAreInnerMostDims("max",u,c);const[m,y]=e.backend_util.computeOutAndReduceShapes(h,u),g=r(f,e.util.sizeFromShape(y),m,i.dtype);return{dataId:d.write(g,m,i.dtype),shape:m,dtype:i.dtype}}};const k={kernelName:e.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:r})=>{const{x:n}=t,{filterSize:s,strides:d,pad:h,includeBatchInIndex:c}=a,u=r;o(n,"MaxPoolWithArgmax");const p=u.data.get(n.dataId).values,f=e.backend_util.computePool2DInfo(n.shape,s,d,[1,1],h),[m,y]=function(t,a,r,n,s){const o=i(t,0,r,e.util.computeStrides(a),s,"max"),d=l(t,a,r,s,!0,n);return[o.values,d.values]}(p,n.shape,n.dtype,c,f),g=u.write(m,f.outShape,n.dtype),S=u.write(y,f.outShape,n.dtype);return[{dataId:g,shape:f.outShape,dtype:n.dtype},{dataId:S,shape:f.outShape,dtype:"int32"}]}},M=e.kernel_impls.nonMaxSuppressionV5,x={kernelName:e.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:a})=>{const{boxes:r,scores:n}=t,{maxOutputSize:s,iouThreshold:i,scoreThreshold:l,softNmsSigma:d}=a,h=e;o(r,"NonMaxSuppressionWithScore");const c=h.data.get(r.dataId).values,u=h.data.get(n.dataId).values,p=s,f=i,m=l,y=d,{selectedIndices:g,selectedScores:S}=M(c,u,p,f,m,y);return[g,S]}},A={kernelName:e.Square,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:a}=t,r=e;o(a,"square");const n=r.data.get(a.dataId).values,s=new Float32Array(n.length);for(let t=0;t<n.length;++t){const e=n[t];s[t]=e*e}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},F=g((t,e)=>{const a=t-e;return a*a}),v=[x,A,y(e.SquaredDifference,F),I,{kernelName:e.Transpose,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:a})=>{const{x:r}=t,{perm:s}=e,i=a;o(r,"transpose");const l=r.shape.length,d=new Array(l);for(let t=0;t<d.length;t++)d[t]=r.shape[s[t]];const h=n(i.data.get(r.dataId).values,r.shape,r.dtype,s,d);return{dataId:i.write(h,d,r.dtype),shape:d,dtype:r.dtype}}},k,b];for(const t of v)e.registerKernel(t);e.registerBackend("cpu",()=>new m,1),t.MathBackendCPU=m,t.shared=s,t.version_cpu="2.0.1",Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-cpu.es2017.min.js.map
