/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],e):e((t=t||self).tf=t.tf||{},t.tf)}(this,(function(t,e){"use strict";var a,n;!function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(a||(a={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(n||(n={}));const r={};function s(t){return r[t]}function o(t,e,a,n){const r=e.inputParams[t];if(r&&void 0!==r.inputIndexStart){const t=r.inputIndexStart,s=0===r.inputIndexEnd?void 0:void 0===r.inputIndexEnd?t+1:r.inputIndexEnd;if("tensor"===r.type)return p(e.inputNames[r.inputIndexStart],a,n);if("tensors"===r.type){return e.inputNames.slice(t,s).map(t=>p(t,a,n))}const o=Array.prototype.slice.call(p(e.inputNames.slice(t)[0],a,n).dataSync());return"number"===r.type?o[0]:o}const s=e.attrParams[t];return s&&s.value}function p(t,e,a){const[n,r]=u(t),s=a.currentContextIds.find(t=>!!e[m(n,t)]);return void 0!==s?e[m(n,s)][r]:void 0}function i(t,e){const[a,n]=u(t);return[m(a,e&&e.currentContextId),n]}function m(t,e){return e?`${t}-${e}`:t}function u(t){const e=t.split(":");return 1===e.length?[t,0]:[e[0],Number(e[e.length-1])]}function c(t,e){const a=[];for(let n=0;n<t.length;n+=e)a.push(t.slice(n,n+e));return a}var d=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var y=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var l=Object.freeze({__proto__:null,json:[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]}]});var f=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]}]});var h=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var N=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var g=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}]});var x=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var b=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]});var T=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var _=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var O=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]});var S=Object.freeze({__proto__:null,json:[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var w=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]});var A=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var v=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class I{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[d,y,l,f,h,N,g,T,b,x,_,O,S,w,A,v].map(t=>t.json));this.opMappers=t.reduce((t,e)=>(t[e.tfOpName]=e,t),{})}transformGraph(t,e={}){const a=t.node,n=[],r=[],s=a.reduce((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")&&n.push(t[e.name]),"Const"===e.op&&r.push(t[e.name]),t),{});let o=[];const p=[];let m={},u={};null!=e&&(m=this.mapSignatureEntries(e.inputs),u=this.mapSignatureEntries(e.outputs));const c=Object.keys(s);c.forEach(t=>{const e=s[t];e.inputNames.forEach(t=>{const[a]=i(t);e.inputs.push(s[a]),s[a].children.push(e)})}),0===Object.keys(u).length?c.forEach(t=>{const e=s[t];0===e.children.length&&p.push(e)}):Object.keys(u).forEach(t=>{const[e]=i(t),a=s[e];null!=a&&(a.signatureKey=u[t],p.push(a))}),Object.keys(m).length>0?Object.keys(m).forEach(t=>{const[e]=i(t),a=s[e];a&&(a.signatureKey=m[t],o.push(a))}):o=n;let d={};return null!=t.library&&null!=t.library.function&&(d=t.library.function.reduce((t,e)=>(t[e.signature.name]=this.mapFunction(e),t),{})),{nodes:s,inputs:o,outputs:p,weights:r,placeholders:n,signature:e,functions:d}}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,a)=>(e[t[a].name]=a,e),{})}mapNode(t){const e=s(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const a={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(t=>t.startsWith("^")?t.substr(1):t),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return null!=e.inputs&&(a.inputParams=e.inputs.reduce((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t),{})),null!=e.attrs&&(a.attrParams=e.attrs.reduce((e,a)=>{const n=a.type;let r=void 0;switch(a.type){case"string":r=D(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=D(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":r=P(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=P(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":r=M(t.attr,a.tfName,a.defaultValue||0),void 0===r&&a.tfDeprecatedName&&(r=M(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":r=j(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=j(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":r=V(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=V(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":r=L(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=L(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":r=R(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=R(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":r=B(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=B(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":r=F(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=F(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":r=z(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=z(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":r=C(t.attr,a.tfName,a.defaultValue),void 0===r&&a.tfDeprecatedName&&(r=C(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return e[a.name]={value:r,type:n},e},{})),a}mapFunction(t){const e=t.nodeDef,a=[];let n={};null!=e&&(n=e.reduce((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&a.push(t[e.name]),t),{}));const r=[],s=[];t.signature.inputArg.forEach(t=>{const[e]=i(t.name),a={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:k(t.type),type:"dtype"}},children:[]};a.signatureKey=t.name,r.push(a),n[e]=a}),Object.keys(n).forEach(t=>{const e=n[t];e.inputNames.forEach(t=>{const[a]=i(t);e.inputs.push(n[a]),n[a].children.push(e)})});const o=t.ret;t.signature.outputArg.forEach(t=>{const[e,a]=i(o[t.name]),r=n[e];null!=r&&(r.defaultOutput=a,s.push(r))});const p=this.mapArgsToSignature(t);return{nodes:n,inputs:r,outputs:s,weights:a,placeholders:[],signature:p}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t),{}),outputs:t.signature.outputArg.reduce((e,a)=>(e[a.name]=this.mapArgToTensorInfo(a,t.ret),e),{})}}mapArgToTensorInfo(t,e){let a=t.name;return null!=e&&(a=e[a]),{name:a,dtype:t.type}}}function E(t,a){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const a=e.env().global;if(void 0!==a.atob)return a.atob(t);if("undefined"!=typeof Buffer)return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return a?n:n.toLowerCase()}function D(t,e,a,n=!1){const r=t[e];return null!=r?E(r.s,n):a}function V(t,e,a){const n=t[e];return n?n.b:a}function M(t,e,a){const n=t[e]||{},r=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof r?r:parseInt(r,10)}function k(t){switch("string"==typeof t&&(t=a[t]),t){case a.DT_FLOAT:return"float32";case a.DT_INT32:case a.DT_INT64:case a.DT_INT8:case a.DT_UINT8:return"int32";case a.DT_BOOL:return"bool";case a.DT_DOUBLE:return"float32";case a.DT_STRING:return"string";default:return null}}function C(t,e,a){const n=t[e];return n&&n.func?n.func.name:a}function F(t,e,a){const n=t[e];return n&&n.type?k(n.type):a}function z(t,e,a){const n=t[e];return n&&n.list&&n.list.type?n.list.type.map(t=>k(t)):a}function $(t){if(!t.unknownRank)return null!=t.dim?t.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function R(t,e,a){const n=t[e];return n&&n.shape?$(n.shape):a}function j(t,e,a){const n=t[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(t=>"number"==typeof t?t:parseInt(t,10)):a}function P(t,e,a,n=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map(t=>E(t,n)):a}function B(t,e,a){const n=t[e];return n&&n.list&&n.list.shape?n.list.shape.map(t=>$(t)):a}function L(t,e,a){const n=t[e];return n&&n.list&&n.list.b?n.list.b:a}class q{constructor(t,e,a){this.node=t,this.tensorMap=e,this.context=a,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(t=>this.getInput(t)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((t,e)=>(t[e]=this.getAttr(e),t),{}))}getInput(t){return p(t,this.tensorMap,this.context)}getAttr(t,e){const a=this.node.rawAttrs[t];if(null!=a.tensor)return p(t,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return M(this.node.rawAttrs,t,e);if(null!=a.s)return D(this.node.rawAttrs,t,e);if(null!=a.b)return V(this.node.rawAttrs,t,e);if(null!=a.shape)return R(this.node.rawAttrs,t,e);if(null!=a.type)return F(this.node.rawAttrs,t,e);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return j(this.node.rawAttrs,t,e);if(null!=a.list.s)return P(this.node.rawAttrs,t,e);if(null!=a.list.shape)return B(this.node.rawAttrs,t,e);if(null!=a.list.b)return L(this.node.rawAttrs,t,e);if(null!=a.list.type)return z(this.node.rawAttrs,t,e)}return e}}function U(t,a,n=""){e.util.assert(function(t,e){if(t.length!==e.length)return!1;for(let a=0;a<t.length;a++)if(-1!==t[a]&&-1!==e[a]&&t[a]!==e[a])return!1;return!0}(t,a),()=>n+` Shapes ${t} and ${a} must match`)}class W{constructor(t,e,a,n,r,s,o){this.name=t,this.dtype=e,this.maxSize=a,this.elementShape=n,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.id=W.nextId++}get closed(){return this.closed_}clearAndClose(){this.tensors.forEach(t=>t.tensor.dispose()),this.tensors=[],this.closed_=!0}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(t=>this.read(t))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),U(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),a&&a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(a&&a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);a.tensor=e,a.written=!0,this.tensors[t]=a}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((t,a)=>this.write(t,e[a]))}gather(t,a){if(a&&a!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${a}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return e.tensor([],[0].concat(this.elementShape));const n=this.readMany(t);return U(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),e.stack(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return e.tensor([],[0].concat(this.elementShape));const a=[];for(let t=0;t<this.size();t++)a.push(t);const n=this.readMany(a);return U(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),e.concat(n,0)}scatter(t,a){if(a.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${a.dtype}`);if(t.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${a.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,e.unstack(a,0))}split(t,a){if(a.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${a.dtype}`);let n=0;const r=t.map(t=>(n+=t,n));if(n!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${a.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:a.size/n,o=[];e.tidy(()=>{a=a.reshape([1,n,s]);for(let n=0;n<t.length;++n){const p=[0,0===n?0:r[n-1],0],i=[1,t[n],s];o[n]=e.slice(a,p,i).reshape(this.elementShape)}return o});const p=[];for(let e=0;e<t.length;e++)p[e]=e;this.writeMany(p,o)}}W.nextId=0;function G(t,a,n){const r=((t,a,n)=>{switch(t.category){case"arithmetic":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[e.add(o("a",t,a,n),o("b",t,a,n))];case"AddN":return[e.addN(o("tensors",t,a,n))];case"FloorMod":case"Mod":return[e.mod(o("a",t,a,n),o("b",t,a,n))];case"Mul":return[e.mul(o("a",t,a,n),o("b",t,a,n))];case"RealDiv":case"Div":return[e.div(o("a",t,a,n),o("b",t,a,n))];case"DivNoNan":return[e.divNoNan(o("a",t,a,n),o("b",t,a,n))];case"FloorDiv":return[e.floorDiv(o("a",t,a,n),o("b",t,a,n))];case"Sub":return[e.sub(o("a",t,a,n),o("b",t,a,n))];case"Minimum":return[e.minimum(o("a",t,a,n),o("b",t,a,n))];case"Maximum":return[e.maximum(o("a",t,a,n),o("b",t,a,n))];case"Pow":return[e.pow(o("a",t,a,n),o("b",t,a,n))];case"SquaredDifference":return[e.squaredDifference(o("a",t,a,n),o("b",t,a,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"basic_math":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"Abs":case"ComplexAbs":return[e.abs(o("x",t,a,n))];case"Acos":return[e.acos(o("x",t,a,n))];case"Acosh":return[e.acosh(o("x",t,a,n))];case"Asin":return[e.asin(o("x",t,a,n))];case"Asinh":return[e.asinh(o("x",t,a,n))];case"Atan":return[e.atan(o("x",t,a,n))];case"Atan2":return[e.atan2(o("x",t,a,n),o("y",t,a,n))];case"Atanh":return[e.atanh(o("x",t,a,n))];case"Ceil":return[e.ceil(o("x",t,a,n))];case"Complex":return[e.complex(o("real",t,a,n),o("imag",t,a,n))];case"Cos":return[e.cos(o("x",t,a,n))];case"Cosh":return[e.cosh(o("x",t,a,n))];case"Elu":return[e.elu(o("x",t,a,n))];case"Erf":return[e.erf(o("x",t,a,n))];case"Exp":return[e.exp(o("x",t,a,n))];case"Expm1":return[e.expm1(o("x",t,a,n))];case"Floor":return[e.floor(o("x",t,a,n))];case"Log":return[e.log(o("x",t,a,n))];case"Log1p":return[e.log1p(o("x",t,a,n))];case"Imag":return[e.imag(o("x",t,a,n))];case"Neg":return[e.neg(o("x",t,a,n))];case"Reciprocal":return[e.reciprocal(o("x",t,a,n))];case"Real":return[e.real(o("x",t,a,n))];case"Relu":return[e.relu(o("x",t,a,n))];case"Round":return[e.round(o("x",t,a,n))];case"Selu":return[e.selu(o("x",t,a,n))];case"Sigmoid":return[e.sigmoid(o("x",t,a,n))];case"Sin":return[e.sin(o("x",t,a,n))];case"Sign":return[e.sign(o("x",t,a,n))];case"Sinh":return[e.sinh(o("x",t,a,n))];case"Softplus":return[e.softplus(o("x",t,a,n))];case"Sqrt":return[e.sqrt(o("x",t,a,n))];case"Square":return[e.square(o("x",t,a,n))];case"Tanh":return[e.tanh(o("x",t,a,n))];case"Tan":return[e.tan(o("x",t,a,n))];case"Relu6":case"ClipByValue":return[e.clipByValue(o("x",t,a,n),o("clipValueMin",t,a,n),o("clipValueMax",t,a,n))];case"Rsqrt":return[e.rsqrt(p(t.inputNames[0],a,n))];case"Prod":return[e.prod(o("x",t,a,n),o("axes",t,a,n))];case"LeakyRelu":return[e.leakyRelu(o("x",t,a,n),o("alpha",t,a,n))];case"Prelu":return[e.prelu(o("x",t,a,n),o("alpha",t,a,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"control":return(async(t,a,n)=>{switch(t.op){case"If":case"StatelessIf":{const e=o("thenBranch",t,a,n),r=o("elseBranch",t,a,n),s=o("cond",t,a,n),p=o("args",t,a,n);return(await s.data())[0]?n.functionMap[e].executeFunctionAsync(p):n.functionMap[r].executeFunctionAsync(p)}case"While":case"StatelessWhile":{const e=o("body",t,a,n),r=o("cond",t,a,n),s=o("args",t,a,n),p=(await n.functionMap[r].executeFunctionAsync(s))[0];let i=await p.data(),m=s;for(;i[0];){m=await n.functionMap[e].executeFunctionAsync(m);const t=(await n.functionMap[r].executeFunctionAsync(m))[0];i=await t.data()}return m}case"LoopCond":return[o("pred",t,a,n).clone()];case"Switch":{const e=o("pred",t,a,n),r=o("data",t,a,n);return(await e.data())[0]?[void 0,r.clone()]:[r.clone(),void 0]}case"Merge":const r=t.inputNames.find(t=>void 0!==p(t,a,n));return r?[p(r,a,n).clone()]:void 0;case"Enter":const s=o("frameName",t,a,n),i=o("tensor",t,a,n);return n.enterFrame(s),[i.clone()];case"Exit":const m=o("tensor",t,a,n);return n.exitFrame(),[m.clone()];case"NextIteration":const u=o("tensor",t,a,n);return n.nextIteration(),[u.clone()];case"TensorArrayV3":const c=o("size",t,a,n),d=o("dtype",t,a,n),y=o("elementShape",t,a,n),l=o("dynamicSize",t,a,n),f=o("clearAfterRead",t,a,n),h=o("identicalElementShapes",t,a,n),N=o("name",t,a,n),g=new W(N,d,c,y,h,l,f);return n.addTensorArray(g),[e.scalar(g.id),e.scalar(1)];case"TensorArrayWriteV3":const x=o("tensorArrayId",t,a,n),b=o("index",t,a,n),T=o("tensor",t,a,n);return n.getTensorArray(x).write(b,T),[e.scalar(1)];case"TensorArrayReadV3":const _=o("tensorArrayId",t,a,n),O=o("index",t,a,n);return[n.getTensorArray(_).read(O)];case"TensorArrayGatherV3":const S=o("tensorArrayId",t,a,n),w=o("indices",t,a,n),A=o("dtype",t,a,n);return[n.getTensorArray(S).gather(w,A)];case"TensorArrayScatterV3":const v=o("tensorArrayId",t,a,n),I=o("indices",t,a,n),E=o("tensor",t,a,n);return n.getTensorArray(v).scatter(I,E),[e.scalar(1)];case"TensorArrayConcatV3":const D=o("tensorArrayId",t,a,n),V=n.getTensorArray(D),M=o("dtype",t,a,n);return[V.concat(M)];case"TensorArraySplitV3":const k=o("tensorArrayId",t,a,n),C=o("tensor",t,a,n),F=o("lengths",t,a,n);return n.getTensorArray(k).split(F,C),[e.scalar(1)];case"TensorArraySizeV3":const z=o("tensorArrayId",t,a,n),$=n.getTensorArray(z);return[e.scalar($.size(),"int32")];case"TensorArrayCloseV3":const R=o("tensorArrayId",t,a,n);return n.getTensorArray(R).clearAndClose(),[e.scalar(0)];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n);case"convolution":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"Conv1D":{const r=o("stride",t,a,n),s=o("pad",t,a,n),p=o("dataFormat",t,a,n).toUpperCase(),i=o("dilation",t,a,n);return[e.conv1d(o("x",t,a,n),o("filter",t,a,n),r,s,p,i)]}case"Conv2D":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("dataFormat",t,a,n).toUpperCase(),i=o("dilations",t,a,n);return[e.conv2d(o("x",t,a,n),o("filter",t,a,n),[r[1],r[2]],s,p,[i[1],i[2]])]}case"_FusedConv2D":case"FusedDepthwiseConv2dNative":{const[r,s]=o("fusedOps",t,a,n),p="biasadd"===r,i="prelu"===s,m="fusedbatchnorm"===r,u=o("numArgs",t,a,n);if(p){if(i&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(m)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const c=o("strides",t,a,n),d=o("pad",t,a,n),y=o("dataFormat",t,a,n).toUpperCase(),l=o("dilations",t,a,n),[f,h]=o("args",t,a,n);return[("_FusedConv2D"===t.op?e.fused.conv2d:e.fused.depthwiseConv2d)({x:o("x",t,a,n),filter:o("filter",t,a,n),strides:[c[1],c[2]],pad:d,dataFormat:y,dilations:[l[1],l[2]],bias:f,activation:s,preluActivationWeights:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=o("outputShape",t,a,n),s=o("strides",t,a,n),p=o("pad",t,a,n);return[e.conv2dTranspose(o("x",t,a,n),o("filter",t,a,n),r,[s[1],s[2]],p)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("dilations",t,a,n),i=o("dataFormat",t,a,n).toUpperCase();return[e.depthwiseConv2d(o("input",t,a,n),o("filter",t,a,n),[r[1],r[2]],s,i,[p[1],p[2]])]}case"Conv3D":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("dataFormat",t,a,n).toUpperCase(),i=o("dilations",t,a,n);return[e.conv3d(o("x",t,a,n),o("filter",t,a,n),[r[1],r[2],r[3]],s,p,[i[1],i[2],i[3]])]}case"AvgPool":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("kernelSize",t,a,n);return[e.avgPool(o("x",t,a,n),[p[1],p[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("kernelSize",t,a,n);return[e.maxPool(o("x",t,a,n),[p[1],p[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("kernelSize",t,a,n),i=o("includeBatchInIndex",t,a,n),{result:m,indexes:u}=e.maxPoolWithArgmax(o("x",t,a,n),[p[1],p[2]],[r[1],r[2]],s,i);return[m,u]}case"AvgPool3D":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("kernelSize",t,a,n);return[e.avgPool3d(o("x",t,a,n),[p[1],p[2],p[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=o("strides",t,a,n),s=o("pad",t,a,n),p=o("kernelSize",t,a,n);return[e.maxPool3d(o("x",t,a,n),[p[1],p[2],p[3]],[r[1],r[2],r[3]],s)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"creation":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"Fill":{const r=o("shape",t,a,n),s=o("dtype",t,a,n),p=o("value",t,a,n);return[e.fill(r,p,s)]}case"LinSpace":{const r=o("start",t,a,n),s=o("stop",t,a,n),p=o("num",t,a,n);return[e.linspace(r,s,p)]}case"Multinomial":{const r=o("logits",t,a,n),s=o("numSamples",t,a,n),p=o("seed",t,a,n);return[e.multinomial(r,s,p)]}case"OneHot":{const r=o("indices",t,a,n),s=o("depth",t,a,n),p=o("onValue",t,a,n),i=o("offValue",t,a,n);return[e.oneHot(r,s,p,i)]}case"Ones":return[e.ones(o("shape",t,a,n),o("dtype",t,a,n))];case"OnesLike":return[e.onesLike(o("x",t,a,n))];case"RandomUniform":return[e.randomUniform(o("shape",t,a,n),o("minval",t,a,n),o("maxval",t,a,n),o("dtype",t,a,n))];case"Range":{const r=o("start",t,a,n),s=o("stop",t,a,n),p=o("step",t,a,n);return[e.range(r,s,p,o("dtype",t,a,n))]}case"TruncatedNormal":{const r=o("shape",t,a,n),s=o("mean",t,a,n),p=o("stdDev",t,a,n),i=o("seed",t,a,n);return[e.truncatedNormal(r,s,p,o("dtype",t,a,n),i)]}case"Zeros":return[e.zeros(o("shape",t,a,n),o("dtype",t,a,n))];case"ZerosLike":return[e.zerosLike(o("x",t,a,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"dynamic":return(async(t,a,n)=>{switch(t.op){case"NonMaxSuppressionV5":case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const r=o("boxes",t,a,n),s=o("scores",t,a,n),p=o("maxOutputSize",t,a,n),i=o("iouThreshold",t,a,n),m=o("scoreThreshold",t,a,n);if("NonMaxSuppressionV5"===t.op){const u=o("softNmsSigma",t,a,n),c=await e.image.nonMaxSuppressionWithScoreAsync(r,s,p,i,m,u);return[c.selectedIndices,c.selectedScores]}return[await e.image.nonMaxSuppressionAsync(r,s,p,i,m)]}case"Where":{const r=o("condition",t,a,n).asType("bool"),s=[await e.whereAsync(r)];return r.dispose(),s}case"ListDiff":return e.setdiff1dAsync(o("x",t,a,n),o("y",t,a,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n);case"evaluation":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"TopKV2":{const r=o("x",t,a,n),s=o("k",t,a,n),p=o("sorted",t,a,n),i=e.topk(r,s,p);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"image":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"ResizeBilinear":{const r=o("images",t,a,n),s=o("size",t,a,n),p=o("alignCorners",t,a,n);return[e.image.resizeBilinear(r,[s[0],s[1]],p)]}case"ResizeNearestNeighbor":{const r=o("images",t,a,n),s=o("size",t,a,n),p=o("alignCorners",t,a,n);return[e.image.resizeNearestNeighbor(r,[s[0],s[1]],p)]}case"CropAndResize":{const r=o("image",t,a,n),s=o("boxes",t,a,n),p=o("boxInd",t,a,n),i=o("cropSize",t,a,n),m=o("method",t,a,n),u=o("extrapolationValue",t,a,n);return[e.image.cropAndResize(r,s,p,i,m,u)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"graph":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"Const":return a[t.name];case"PlaceholderWithDefault":const r=o("default",t,a,n);return[p(t.name,a,n)||r];case"Placeholder":return[p(t.name,a,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[o("x",t,a,n).clone()];case"IdentityN":return o("x",t,a,n).map(t=>t.clone());case"Snapshot":return[o("x",t,a,n).clone()];case"Shape":return[e.tensor1d(o("x",t,a,n).shape,"int32")];case"ShapeN":return o("x",t,a,n).map(t=>e.tensor1d(t.shape));case"Size":return[e.scalar(o("x",t,a,n).size,"int32")];case"Rank":return[e.scalar(o("x",t,a,n).rank,"int32")];case"NoOp":return[e.scalar(1)];case"Print":const s=o("x",t,a,n),i=o("data",t,a,n),m=o("message",t,a,n),u=o("summarize",t,a,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(m);for(let t=0;t<i.length;t++)console.log(Array.prototype.slice.call(i[t].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"logical":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"Equal":return[e.equal(o("a",t,a,n),o("b",t,a,n))];case"NotEqual":return[e.notEqual(o("a",t,a,n),o("b",t,a,n))];case"Greater":return[e.greater(o("a",t,a,n),o("b",t,a,n))];case"GreaterEqual":return[e.greaterEqual(o("a",t,a,n),o("b",t,a,n))];case"Less":return[e.less(o("a",t,a,n),o("b",t,a,n))];case"LessEqual":return[e.lessEqual(o("a",t,a,n),o("b",t,a,n))];case"LogicalAnd":return[e.logicalAnd(o("a",t,a,n),o("b",t,a,n))];case"LogicalNot":return[e.logicalNot(o("a",t,a,n))];case"LogicalOr":return[e.logicalOr(o("a",t,a,n),o("b",t,a,n))];case"Select":case"SelectV2":return[e.where(o("condition",t,a,n),o("a",t,a,n),o("b",t,a,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"matrices":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[e.matMul(o("a",t,a,n),o("b",t,a,n),o("transposeA",t,a,n),o("transposeB",t,a,n))];case"Transpose":return[e.transpose(o("x",t,a,n),o("perm",t,a,n))];case"_FusedMatMul":const[r,s]=o("fusedOps",t,a,n),p="biasadd"===r,i="prelu"===s,m=o("numArgs",t,a,n);if(p){if(i&&2!==m)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==m)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=o("args",t,a,n);return[e.fused.matMul({a:o("a",t,a,n),b:o("b",t,a,n),transposeA:o("transposeA",t,a,n),transposeB:o("transposeB",t,a,n),bias:u,activation:s,preluActivationWeights:c})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"normalization":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[e.batchNorm(o("x",t,a,n),o("mean",t,a,n),o("variance",t,a,n),o("offset",t,a,n),o("scale",t,a,n),o("epsilon",t,a,n))];case"LRN":return[e.localResponseNormalization(o("x",t,a,n),o("radius",t,a,n),o("bias",t,a,n),o("alpha",t,a,n),o("beta",t,a,n))];case"Softmax":return[e.softmax(o("x",t,a,n))];case"LogSoftmax":return[e.logSoftmax(o("x",t,a,n))];case"SparseToDense":return[e.sparseToDense(o("sparseIndices",t,a,n),o("outputShape",t,a,n),o("sparseValues",t,a,n),o("defaultValue",t,a,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"reduction":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"Max":{const r=o("axis",t,a,n),s=o("keepDims",t,a,n);return[e.max(o("x",t,a,n),r,s)]}case"Mean":{const r=o("axis",t,a,n),s=o("keepDims",t,a,n);return[e.mean(o("x",t,a,n),r,s)]}case"Min":{const r=o("axis",t,a,n),s=o("keepDims",t,a,n);return[e.min(o("x",t,a,n),r,s)]}case"Sum":{const r=o("axis",t,a,n),s=o("keepDims",t,a,n);return[e.sum(o("x",t,a,n),r,s)]}case"All":{const r=o("axis",t,a,n),s=o("keepDims",t,a,n);return[e.all(o("x",t,a,n),r,s)]}case"Any":{const r=o("axis",t,a,n),s=o("keepDims",t,a,n);return[e.any(o("x",t,a,n),r,s)]}case"ArgMax":{const r=o("axis",t,a,n);return[e.argMax(o("x",t,a,n),r)]}case"ArgMin":{const r=o("axis",t,a,n);return[e.argMin(o("x",t,a,n),r)]}case"Prod":{const r=o("axis",t,a,n),s=o("keepDims",t,a,n);return[e.prod(o("x",t,a,n),r,s)]}case"Cumsum":{const r=o("axis",t,a,n),s=o("exclusive",t,a,n),p=o("reverse",t,a,n);return[e.cumsum(o("x",t,a,n),r,s,p)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"slice_join":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=o("n",t,a,n),s=o("axis",t,a,n);let p=o("tensors",t,a,n);return p=p.slice(0,r),[e.concat(p,s)]}case"GatherV2":case"Gather":{const r=o("axis",t,a,n),s=o("x",t,a,n),p=o("indices",t,a,n);return[e.gather(s,p.asType("int32"),r)]}case"ReverseV2":case"Reverse":{const r=o("axis",t,a,n),s=o("x",t,a,n);return[e.reverse(s,r)]}case"Slice":{const r=o("begin",t,a,n),s=o("size",t,a,n);return[e.slice(o("x",t,a,n),r,s)]}case"StridedSlice":{const r=o("begin",t,a,n),s=o("end",t,a,n),p=o("strides",t,a,n),i=o("beginMask",t,a,n),m=o("endMask",t,a,n),u=o("ellipsisMask",t,a,n),c=o("newAxisMask",t,a,n),d=o("shrinkAxisMask",t,a,n),y=o("x",t,a,n);if(1===r.length&&y.shape.length>1)for(let t=1;t<y.shape.length;t++)r.push(0),s.push(y.shape[t]),p.push(p[0]);return[e.stridedSlice(y,r,s,p,i,m,u,c,d)]}case"Pack":return e.tidy(()=>{const r=o("axis",t,a,n),s=o("tensors",t,a,n),p=s[0].shape,i=s[0].squeeze().shape,m=s.map(t=>{const a=e.util.arraysEqual(t.shape,p);if(!a&&!e.util.arraysEqual(t.squeeze().shape,i))throw new Error("the input tensors shape does not match");return a?t:t.reshape(p)});return[e.stack(m,r)]});case"Unpack":return e.tidy(()=>{const r=o("axis",t,a,n),s=o("tensor",t,a,n);return e.unstack(s,r)});case"Tile":{const r=o("reps",t,a,n);return[e.tile(o("x",t,a,n),r)]}case"Split":case"SplitV":{const r=o("axis",t,a,n),s=o("numOrSizeSplits",t,a,n);return e.split(o("x",t,a,n),s,r)}case"ScatterNd":{const r=o("indices",t,a,n),s=o("values",t,a,n),p=o("shape",t,a,n);return[e.scatterND(r,s,p)]}case"GatherNd":{const r=o("x",t,a,n),s=o("indices",t,a,n);return[e.gatherND(r,s)]}case"SparseToDense":{const r=o("sparseIndices",t,a,n),s=o("outputShape",t,a,n),p=o("sparseValues",t,a,n),i=o("defaultValue",t,a,n);return[e.sparseToDense(r,p,s,p.dtype===i.dtype?i:i.asType(p.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"spectral":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"FFT":return[e.fft(o("x",t,a,n))];case"IFFT":return[e.ifft(o("x",t,a,n))];case"RFFT":return[e.rfft(o("x",t,a,n))];case"IRFFT":return[e.irfft(o("x",t,a,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"transformation":return e.tidy(()=>((t,a,n)=>{switch(t.op){case"Cast":return[e.cast(o("x",t,a,n),o("dtype",t,a,n))];case"ExpandDims":{const r=o("axis",t,a,n);return[e.expandDims(o("x",t,a,n),r)]}case"Squeeze":{const r=o("axis",t,a,n);return[e.squeeze(o("x",t,a,n),r)]}case"Reshape":return[e.reshape(o("x",t,a,n),o("shape",t,a,n))];case"PadV2":case"Pad":return[e.pad(o("x",t,a,n),c(o("padding",t,a,n),2),o("constantValue",t,a,n))];case"SpaceToBatchND":{const r=o("blockShape",t,a,n),s=c(o("paddings",t,a,n),2);return[e.spaceToBatchND(o("x",t,a,n),r,s)]}case"BatchToSpaceND":{const r=o("blockShape",t,a,n),s=c(o("crops",t,a,n),2);return[e.batchToSpaceND(o("x",t,a,n),r,s)]}case"DepthToSpace":{const r=o("blockSize",t,a,n),s=o("dataFormat",t,a,n).toUpperCase();return[e.depthToSpace(o("x",t,a,n),r,s)]}case"BroadcastTo":return[e.broadcastTo(o("x",t,a,n),o("shape",t,a,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n));case"custom":const r=s(t.op);if(r&&r.customExecutor)return r.customExecutor(new q(t,a,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,a,n);return r instanceof Promise?r.then(t=>[].concat(t)):[].concat(r)}class H{constructor(t,e,a={}){this.weightMap=t,this.tensorArrayMap=e,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const a=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(a))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}}function Q(t,e,a){const n=new Set,r=[];let s=null,o=null;const p=new Set,i=Object.keys(t).map(t=>u(t)[0]),m=[...e];for(;m.length>0;){const t=m.pop();(Z(t)||Y(t))&&null==s&&(s=t,o=s.children.map(t=>t.name).filter(t=>n.has(t))),n.add(t.name),null==a[t.name]&&(-1===i.indexOf(t.name)&&(0!==t.inputs.length?t.inputs.forEach(t=>{p.has(t.name)||(p.add(t.name),m.push(t))}):r.push(t.name)))}return{inputs:t,outputs:e,usedNodes:n,missingInputs:r,dynamicNode:s,syncInputs:o}}const K=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile"],X=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];function Z(t){return K.indexOf(t.op)>=0}function Y(t){return X.indexOf(t.op)>=0}class J{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(e=>{this._functionExecutorMap[e]=new J(t.functions[e],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(e=>t[e].map(t=>t.id));this._weightIds=[].concat(...e),this._weightMap=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const a=t.map(t=>t.name).sort(),n=e.map(t=>t.name).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(t,e){const a=Q(t,e,this.weightMap),{missingInputs:n,dynamicNode:r,syncInputs:s}=a;if(null!=r)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(n.length>0){const a=e.map(t=>t.name),r=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${r}]. Missing the following inputs: [${n}]`)}return function(t,e,a){const{usedNodes:n,inputs:r}=a,s=[];Object.keys(r).map(t=>u(t)[0]).map(e=>t.nodes[e]).forEach(t=>{n.has(t.name)&&s.push(t)}),t.weights.forEach(t=>{n.has(t.name)&&s.push(t)});const o=new Set,p=[];for(;s.length>0;){const t=s.pop();o.add(t.name),e[t.name]||p.push(t),t.children.forEach(t=>{!o.has(t.name)&&n.has(t.name)&&t.inputs.every(t=>o.has(t.name))&&s.push(t)})}return p}(this.graph,this.weightMap,a)}execute(t,a){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),a=this.mapOutputs(a),this.checkOutputs(a);const r=n.map(t=>this.graph.nodes[u(t)[0]]),s=a.map(t=>this.graph.nodes[u(t)[0]]),o=this.getCompilationKey(r,s);let i=this.compiledMap.get(o);null==i&&(i=this.compile(t,s),this.compiledMap.set(o,i));const m={};return e.tidy(()=>{const e=new H(this.weightMap,m,this.functionExecutorMap),n=Object.assign({},this.weightMap);Object.keys(t).forEach(e=>{const[a,r]=u(e),s=[];s[r]=t[e],n[a]=s});const r=this.getFrozenTensorIds(n),s={};for(let t=0;t<i.length;t++){const o=i[t];if(!n[o.name]){const t=G(o,n,e);if(t instanceof Promise)throw new Error(`The execution of the op '${o.op}' returned a promise. Please use model.executeAsync() instead.`);n[o.name]=t,this.checkTensorForDisposal(o.name,o,n,e,r,a,s)}}return a.map(t=>p(t,n,e))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(e=>t[e]).map(t=>t.map(t=>t.id)));return new Set(e)}checkTensorForDisposal(t,e,a,n,r,s,o){"control"!==e.category&&-1===s.indexOf(t)&&(a[t].forEach(t=>{null!=t&&(o[t.id]=(o[t.id]||0)+e.children.length)}),e.inputs.forEach(t=>{if("control"!==t.category){const e=function(t,e,a){return e[m(t,a.currentContextId)]}(t.name,a,n);null!=e&&e.forEach(t=>{if(t&&!r.has(t.id)){const e=o[t.id];1===e?(t.dispose(),delete o[t.id]):null!=e&&o[t.id]--}})}}))}async executeAsync(t,e,a=!1){t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const n=new H(this.weightMap,{},this.functionExecutorMap),r=await this.executeWithControlFlow(t,n,e,a),s=e.map(t=>p(t,r,n)),o=new Set(s.map(t=>t.id)),i=new Set(Object.keys(t).map(e=>t[e].id));return Object.keys(r).forEach(t=>{r[t].forEach(t=>{!t||t.isDisposed||o.has(t.id)||i.has(t.id)||-1!==this.weightIds.indexOf(t.id)||t.dispose()})}),s}async executeFunctionAsync(t){const e=t.reduce((t,e,a)=>(t[this.inputs[a].name]=e,t),{});return this.executeAsync(e,this.outputNodes,!0)}async executeWithControlFlow(t,e,a,n){const r=Object.keys(t),s=r.map(t=>this.graph.nodes[u(t)[0]]),o=a.map(t=>this.graph.nodes[u(t)[0]]),{usedNodes:i,missingInputs:m,dynamicNode:c,syncInputs:d}=Q(t,o,this.weightMap),y=[...s,...this.graph.weights].map(t=>({node:t,contexts:e.currentContext})),l=Object.assign({},this.weightMap);Object.keys(t).forEach(e=>{const[a,n]=u(e),r=[];r[n]=t[e],l[a]=r});const f={},h=this.getFrozenTensorIds(l),N={};for(;y.length>0;){const t=this.processStack(s,y,e,l,N,h,a,f,i);await Promise.all(t)}null!=c||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const g=o.filter(t=>!Z(t)&&!p(t.name,l,e)).map(t=>t.name);if(g.length>0){let t="";throw null!=c&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${g}] from the provided inputs [${r}]. Consider providing the following inputs: [${m}]. ${t}`)}return l}processStack(t,e,a,n,r,s,p,m,u){const c=[];for(;e.length>0;){const d=e.pop();a.currentContext=d.contexts;let y="";if("Enter"===d.node.op&&o("isConstant",d.node,n,a)&&([y]=i(d.node.name,a)),-1===t.indexOf(d.node)){const t=G(d.node,n,a);y||([y]=i(d.node.name,a));const o=a.currentContext;t instanceof Promise?c.push(t.then(t=>(n[y]=t,a.currentContext=o,this.checkTensorForDisposal(y,d.node,n,a,s,p,m),this.processChildNodes(d.node,e,a,n,r,u),t))):(n[y]=t,this.checkTensorForDisposal(y,d.node,n,a,s,p,m),this.processChildNodes(d.node,e,a,n,r,u))}else this.processChildNodes(d.node,e,a,n,r,u)}return c}processChildNodes(t,e,a,n,r,s){t.children.forEach(t=>{const[o]=i(t.name,a);!r[o]&&s.has(t.name)&&("Merge"===t.op?t.inputNames.some(t=>!!p(t,n,a))&&(r[o]=!0,e.push({contexts:a.currentContext,node:t})):t.inputNames.every(t=>!!p(t,n,a))&&(r[o]=!0,e.push({contexts:a.currentContext,node:t})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(t=>t.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(a=>{const n=t[a],[r]=u(a),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const t=s.attrParams.shape.value,a=t.length===n.shape.length&&n.shape.every((e,a)=>-1===t[a]||t[a]===e);e.util.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&e.util.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){const e={};for(const a in t)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]){e[this._signature.inputs[a].name]=t[a]}else e[a]=t[a];return e}checkInputs(t){const e=Object.keys(t).filter(t=>{const[e]=u(t);return null==this.graph.nodes[e]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(t=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]){return this._signature.outputs[t].name}return t},{})}checkOutputs(t){t.forEach(t=>{const[e]=u(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)})}}class tt{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={})}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=e.io.browserHTTPRequest(t,this.loadOptions);else{const a=e.io.getLoadHandlers(t,this.loadOptions);if(0===a.length)a.push(e.io.browserHTTPRequest(t,this.loadOptions));else if(a.length>1)throw new Error(`Found more than one (${a.length}) load handlers for URL '${[t]}'`);this.handler=a[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;const a=this.artifacts.modelTopology;let n={};null!=this.artifacts.userDefinedMetadata&&(n=this.artifacts.userDefinedMetadata.signature),this.version=`${a.versions.producer}.${a.versions.minConsumer}`;const r=e.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);return this.executor=new J(I.Instance.transformGraph(a,n)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),!0}async save(t,a){if("string"==typeof t){const a=e.io.getSaveHandlers(t);if(0===a.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(a.length>1)throw new Error(`Found more than one (${a.length}) save handlers for URL '${t}'`);t=a[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof e.Tensor||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,a,n)=>(e[a]=t[n],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const a=this.executor.execute(t,e);return a.length>1?a:a[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const a=await this.executor.executeAsync(t,e);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,a)=>(e[a]=[t[a]],e),{})}dispose(){this.executor.dispose()}}t.GraphModel=tt,t.deregisterOp=function(t){delete r[t]},t.loadGraphModel=async function(t,e={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t+="model.json?tfjs-format=file");const a=new tt(t,e);return await a.load(),a},t.registerOp=function(t,e){const a={tfOpName:t,category:"custom",inputs:[],attrs:[],customExecutor:e};r[t]=a},t.version_converter="2.0.1",Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-converter.es2017.min.js.map
